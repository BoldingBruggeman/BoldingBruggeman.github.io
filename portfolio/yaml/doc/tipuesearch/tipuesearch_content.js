var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program Hi, my name is kb. This is a project which I wrote. This file will provide the documents. I'm\nwriting the body of the text here. It contains an overall description of the\nproject. It might explain how to go about installing/compiling it. It might\nprovide a change-log for the code. linalg Maybe it will talk about the\nhistory and/or motivation for this software. Note You can include any notes (or bugs, warnings, or todos) like so. Bug You can have multi-paragraph versions of these too! That means you can\ninclude ordered lists unordered lists images etc. Isn't that cool? Bug Hey I'm doing it again... This ones ends mid... ...paragraph. You can have as many paragraphs as you like here and can use headlines, links,\nimages, etc. Basically, you can use anything in Markdown and Markdown-Extra.\nFurthermore, you can insert LaTeX into your documentation. So, for example,\nyou can provide inline math using like y = x&#94;2 or math on its own line\nlike x = \\sqrt{y} or e = mc&#94;2. You can even use LaTeX environments!\nSo you can get numbered equations like this: \\begin{equation}\n  PV = nRT\n\\end{equation} So let your imagination run wild. As you can tell, I'm more or less just\nfilling in space now. This will be the last sentence. Developer Info Jorn Bruggeman","tags":"home","loc":"index.html"},{"title":"yaml.F90 – Fortran Program","text":"This file depends on sourcefile~~yaml.f90~~EfferentGraph sourcefile~yaml.f90 yaml.F90 sourcefile~yaml_types.f90 yaml_types.F90 sourcefile~yaml.f90->sourcefile~yaml_types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~yaml.f90~~AfferentGraph sourcefile~yaml.f90 yaml.F90 sourcefile~test_yaml.f90 test_yaml.F90 sourcefile~test_yaml.f90->sourcefile~yaml.f90 sourcefile~yaml_settings.f90 yaml_settings.F90 sourcefile~yaml_settings.f90->sourcefile~yaml.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaml Source Code yaml.F90 Source Code ! ----------------------------------------------------------------------------- ! This file is part of Fortran-YAML: a lightweight YAML parser written in ! object-oriented Fortran. ! ! Official repository: https://github.com/BoldingBruggeman/fortran-yaml ! ! Copyright 2013-2016 Bolding & Bruggeman ApS. ! ! This is free software: you can redistribute it and/or modify it under ! the terms of the GNU General Public License as published by the Free Software ! Foundation (https://www.gnu.org/licenses/gpl.html). It is distributed in the ! hope that it will be useful, but WITHOUT ANY WARRANTY; without even the ! implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ! A copy of the license is provided in the COPYING file. ! ----------------------------------------------------------------------------- module yaml use yaml_types implicit none private public parse , error_length integer , parameter :: line_length = 2048 integer , parameter :: error_length = 2048 type type_file integer :: unit = - 1 character ( line_length ) :: line = '' integer :: indent = 0 logical :: eof = . false . integer :: iline = 0 character ( error_length ) :: error_message = '' logical :: has_error = . false . contains procedure :: next_line procedure :: set_error end type contains function parse ( path , unit , error ) result ( root ) integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: path character ( error_length ), intent ( out ) :: error class ( type_node ), pointer :: root type ( type_file ) :: file logical :: already_open nullify ( root ) error = '' inquire ( unit = unit , opened = already_open ) if (. not . already_open ) open ( unit = unit , file = path , status = 'old' , action = 'read' , err = 90 ) file % unit = unit file % eof = . false . call file % next_line () if (. not . file % has_error ) root => read_value ( file ) if (. not . already_open ) close ( file % unit ) if ( file % has_error ) then write ( error , '(a,a,i0,a,a)' ) trim ( path ), ', line ' , file % iline , ': ' , trim ( file % error_message ) elseif (. not . file % eof ) then if ( associated ( root )) then select type ( root ) class is ( type_dictionary ) write ( error , '(a,a,i0,a)' ) trim ( path ), ', line ' , file % iline , ': unexpected decrease in indentation.' class is ( type_scalar ) write ( error , '(a,a,i0,a)' ) trim ( path ), ', line ' , file % iline , ': expected end of file after reading & &one scalar value.' class default write ( error , '(a,a,i0,a)' ) trim ( path ), ', line ' , file % iline , ': expected end of file.' end select else write ( error , '(a,a,i0,a)' ) trim ( path ), ', line ' , file % iline , ': expected end of file.' end if end if if ( associated ( root )) call root % set_path ( '' ) return 90 error = 'Unable to open ' // trim ( path ) // ' for reading.' end function subroutine next_line ( file ) class ( type_file ), intent ( inout ) :: file integer :: i logical :: done done = . false . do while (. not . done ) ! Read entire line read ( file % unit , '(A)' , end = 91 ) file % line file % iline = file % iline + 1 ! Determine indentation and strip this. file % indent = len ( file % line ) do i = 1 , len ( file % line ) if ( file % line ( i : i ) == achar ( 9 )) then ! Found tabs in indentation: not allowed. call file % set_error ( 'tab in indentation is not allowed.' ) return elseif ( file % line ( i : i ) /= ' ' ) then ! Found non-space: indentation ends here. file % indent = i - 1 exit end if end do file % line = file % line ( file % indent + 1 :) ! If the line starts with comment character; move to next. if ( file % line ( 1 : 1 ) == '#' ) cycle ! Search for whitespace delimited comment within the string; remove if found. do i = 1 , len_trim ( file % line ) - 1 if ( is_whitespace ( file % line ( i : i )). and . file % line ( i + 1 : i + 1 ) == '#' ) then file % line = file % line (: i - 1 ) exit end if end do ! Strip trailing whitespace do i = len ( file % line ), 1 , - 1 if (. not . is_whitespace ( file % line ( i : i ))) then ! We found a non-whitespace character. Strip trailing whitespace and report we have a valid line. file % line = file % line (: i ) done = . true . exit end if end do end do ! Check for unsupported YAML features. do i = 1 , len_trim ( file % line ) if ( file % line ( i : i ) == '[' . or . file % line ( i : i ) == ']' . or . file % line ( i : i ) == '{' . or . file % line ( i : i ) == '}' ) then call file % set_error ( 'flow mappings and sequences using []{} are not supported.' ) return end if if ( file % line ( i : i ) == '\"' . or . file % line ( i : i ) == '''' ) then call file % set_error ( 'single- and double-quoted strings are not supported.' ) return end if end do return 91 file % indent = 0 file % eof = . true . end subroutine recursive function read_value ( file ) result ( node ) class ( type_file ), intent ( inout ) :: file class ( type_node ), pointer :: node integer :: icolon , icolon_stop , firstindent type ( type_key_value_pair ) :: pair class ( type_node ), pointer :: list_item nullify ( node ) if ( file % eof ) return if ( file % line ( 1 : 2 ) == '- ' ) then allocate ( type_list :: node ) firstindent = file % indent do file % line = file % line ( 3 :) file % indent = file % indent + 2 list_item => read_value ( file ) if ( file % has_error ) return select type ( node ) class is ( type_list ) call node % append ( list_item ) end select ! Check indentation of next line. if ( file % indent > firstindent ) then call file % set_error ( 'unexpected increase in indentation following list item.' ) return elseif ( file % eof . or . file % indent < firstindent ) then ! End-of-file or decrease in indentation signifies that the list has ended. return end if end do end if ! Find the first colon (if any) call find_mapping_character ( file % line , icolon , icolon_stop ) if ( icolon ==- 1 ) then ! No colon found: item is a value allocate ( type_scalar :: node ) select type ( node ) class is ( type_scalar ) node % string = trim ( file % line ) end select call file % next_line () else ! Colon found: item starts a mapping allocate ( type_dictionary :: node ) firstindent = file % indent do pair = read_key_value_pair ( file , icolon , icolon_stop ) if ( file % has_error ) return select type ( node ) class is ( type_dictionary ) call node % set ( pair % key , pair % value ) end select ! Check indentation of next line. if ( file % indent > firstindent ) then call file % set_error ( 'unexpected increase in indentation following key-value pair \"' // trim ( pair % key ) // '\".' ) return elseif ( file % eof . or . file % indent < firstindent ) then ! End-of-file or decrease in indentation signifies that the mapping has ended. exit end if ! We are expecting a new key-value pair, since indentation has not changed. Find position of colon. call find_mapping_character ( file % line , icolon , icolon_stop ) if ( icolon ==- 1 ) then call file % set_error ( 'expected a key indicated by inline \": \" or trailing :' ) return end if end do end if end function recursive function read_key_value_pair ( file , icolon , icolon_stop ) result ( pair ) class ( type_file ), intent ( inout ) :: file integer , intent ( in ) :: icolon , icolon_stop type ( type_key_value_pair ) :: pair integer :: istop , baseindent istop = len_trim ( file % line ) pair % key = file % line (: icolon - 1 ) if ( icolon_stop == istop ) then ! Colon ends the line; we need to read the value from the next line. baseindent = file % indent call file % next_line () if ( file % has_error ) return if ( file % eof . or . file % indent < baseindent . or . ( file % indent == baseindent . and . file % line ( 1 : 2 ) /= '- ' )) then ! Indentation equal to, or below, that of label (or file ends after label). ! That implies the value of the key-value pair is null. ! See YAML specification, section 7.2. Empty Nodes. allocate ( type_null :: pair % value ) else ! Value on next line with higher indentation - read it. pair % value => read_value ( file ) end if else ! Value follows colon-space. Skip the label and read the value. file % line = file % line ( icolon_stop + 1 :) file % indent = file % indent + icolon_stop pair % value => read_value ( file ) end if end function subroutine find_mapping_character ( string , istart , istop ) character ( len =* ), intent ( in ) :: string integer , intent ( out ) :: istart , istop integer :: i , length ! Default: mapping indicator not found. istart = - 1 istop = - 1 ! Search for mapping indicator length = len_trim ( string ) do i = 1 , length - 1 if ( string ( i : i + 1 ) == ': ' ) then ! Found \"colon space\" mapping indicator istart = i exit end if end do ! No mapping indicator found yet; check whether string ends with colon. if ( istart ==- 1 . and . string ( length : length ) == ':' ) istart = length ! If we have not found a mapping indicator by now, there isn't one: return. if ( istart ==- 1 ) return ! Eliminate all trailing whitespace istop = istart do i = istart + 1 , length if (. not . is_whitespace ( string ( i : i ))) then istop = i - 1 exit end if end do ! Eliminate all preceding whitespace do i = istart - 1 , 1 , - 1 if (. not . is_whitespace ( string ( i : i ))) then istart = i + 1 exit end if end do end subroutine logical function is_whitespace ( string ) character ( len =* ), intent ( in ) :: string ! White space in YAML includes spaces and tabs only (NB tabs are not allowed in indentation!) is_whitespace = ( string ( 1 : 1 ) == ' ' . or . string ( 1 : 1 ) == achar ( 9 )) end function subroutine set_error ( file , error ) class ( type_file ), intent ( inout ) :: file character ( len =* ), intent ( in ) :: error file % error_message = error file % has_error = . true . end subroutine end module yaml","tags":"","loc":"sourcefile/yaml.f90.html"},{"title":"yaml_version.F90.in – Fortran Program","text":"Files dependent on this one sourcefile~~yaml_version.f90.in~~AfferentGraph sourcefile~yaml_version.f90.in yaml_version.F90.in sourcefile~test_yaml.f90 test_yaml.F90 sourcefile~test_yaml.f90->sourcefile~yaml_version.f90.in Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaml_version Source Code yaml_version.F90.in Source Code module yaml_version character ( len =* ), parameter :: git_commit_id = \"@GIT_COMMIT_ID@\" character ( len =* ), parameter :: git_branch_name = \"@GIT_BRANCH_NAME@\" end module","tags":"","loc":"sourcefile/yaml_version.f90.in.html"},{"title":"yaml_types.F90 – Fortran Program","text":"Files dependent on this one sourcefile~~yaml_types.f90~~AfferentGraph sourcefile~yaml_types.f90 yaml_types.F90 sourcefile~test_yaml.f90 test_yaml.F90 sourcefile~test_yaml.f90->sourcefile~yaml_types.f90 sourcefile~yaml.f90 yaml.F90 sourcefile~test_yaml.f90->sourcefile~yaml.f90 sourcefile~yaml.f90->sourcefile~yaml_types.f90 sourcefile~yaml_settings.f90 yaml_settings.F90 sourcefile~yaml_settings.f90->sourcefile~yaml_types.f90 sourcefile~yaml_settings.f90->sourcefile~yaml.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaml_types Source Code yaml_types.F90 Source Code ! ----------------------------------------------------------------------------- ! This file is part of Fortran-YAML: a lightweight YAML parser written in ! object-oriented Fortran. ! ! Official repository: https://github.com/BoldingBruggeman/fortran-yaml ! ! Copyright 2013-2016 Bolding & Bruggeman ApS. ! ! This is free software: you can redistribute it and/or modify it under ! the terms of the GNU General Public License as published by the Free Software ! Foundation (https://www.gnu.org/licenses/gpl.html). It is distributed in the ! hope that it will be useful, but WITHOUT ANY WARRANTY; without even the ! implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ! A copy of the license is provided in the COPYING file. ! ----------------------------------------------------------------------------- module yaml_types implicit none private public type_node , type_scalar , type_null , type_error , real_kind public type_dictionary , type_key_value_pair public type_list , type_list_item integer , parameter :: string_length = 1024 integer , parameter :: real_kind = kind ( 1.0d0 ) type , abstract :: type_node character ( len = string_length ) :: path = '' contains procedure ( node_dump ), deferred :: dump procedure :: set_path => node_set_path procedure :: finalize => node_finalize end type abstract interface subroutine node_dump ( self , unit , indent ) import type_node class ( type_node ), intent ( in ) :: self integer , intent ( in ) :: unit , indent end subroutine end interface type , extends ( type_node ) :: type_scalar character ( len = string_length ) :: string = '' contains procedure :: dump => value_dump procedure :: to_logical => scalar_to_logical procedure :: to_integer => scalar_to_integer procedure :: to_real => scalar_to_real end type type , extends ( type_node ) :: type_null contains procedure :: dump => null_dump end type type type_key_value_pair character ( len = string_length ) :: key = '' class ( type_node ), pointer :: value => null () logical :: accessed = . false . type ( type_key_value_pair ), pointer :: next => null () end type type , extends ( type_node ) :: type_dictionary type ( type_key_value_pair ), pointer :: first => null () contains procedure :: get => dictionary_get procedure :: get_scalar => dictionary_get_scalar procedure :: get_dictionary => dictionary_get_dictionary procedure :: get_list => dictionary_get_list procedure :: get_string => dictionary_get_string procedure :: get_logical => dictionary_get_logical procedure :: get_integer => dictionary_get_integer procedure :: get_real => dictionary_get_real procedure :: set => dictionary_set procedure :: set_string => dictionary_set_string procedure :: dump => dictionary_dump procedure :: flatten => dictionary_flatten procedure :: reset_accessed => dictionary_reset_accessed procedure :: set_path => dictionary_set_path procedure :: finalize => dictionary_finalize end type type type_list_item class ( type_node ), pointer :: node => null () type ( type_list_item ), pointer :: next => null () end type type , extends ( type_node ) :: type_list type ( type_list_item ), pointer :: first => null () contains procedure :: append => list_append procedure :: dump => list_dump procedure :: set_path => list_set_path end type type type_error character ( len = string_length ) :: message end type contains subroutine node_finalize ( self ) class ( type_node ), intent ( inout ) :: self end subroutine subroutine dictionary_reset_accessed ( self ) class ( type_dictionary ), intent ( in ) :: self type ( type_key_value_pair ), pointer :: pair pair => self % first do while ( associated ( pair )) pair % accessed = . false . pair => pair % next end do end subroutine function dictionary_get ( self , key ) result ( value ) class ( type_dictionary ), intent ( in ) :: self character ( len =* ), intent ( in ) :: key class ( type_node ), pointer :: value type ( type_key_value_pair ), pointer :: pair nullify ( value ) pair => self % first do while ( associated ( pair )) if ( pair % key == key ) exit pair => pair % next end do if ( associated ( pair )) then value => pair % value pair % accessed = . true . end if end function subroutine dictionary_set ( self , key , value ) class ( type_dictionary ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: key class ( type_node ), pointer :: value type ( type_key_value_pair ), pointer :: pair if (. not . associated ( self % first )) then ! This will be the first pair. allocate ( self % first ) pair => self % first else ! Try to find a pair with the same key, or failing that, the last pair. pair => self % first do while ( associated ( pair % next )) if ( pair % key == key ) exit pair => pair % next end do if (. not . pair % key == key ) then ! Key did not exist yet, which must mean we are operating on the last existing pair. ! Append a new pair. allocate ( pair % next ) pair => pair % next else deallocate ( pair % value ) end if end if ! Store key and value. pair % key = key pair % value => value end subroutine subroutine dictionary_set_string ( self , key , value ) class ( type_dictionary ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: key , value class ( type_scalar ), pointer :: scalar_node class ( type_node ), pointer :: node allocate ( scalar_node ) scalar_node % string = value node => scalar_node call self % set ( key , node ) end subroutine subroutine value_dump ( self , unit , indent ) class ( type_scalar ), intent ( in ) :: self integer , intent ( in ) :: unit , indent write ( unit , '(a)' ) trim ( self % string ) end subroutine subroutine null_dump ( self , unit , indent ) class ( type_null ), intent ( in ) :: self integer , intent ( in ) :: unit , indent write ( unit , '(a)' ) 'null' end subroutine recursive subroutine dictionary_dump ( self , unit , indent ) class ( type_dictionary ), intent ( in ) :: self integer , intent ( in ) :: unit , indent type ( type_key_value_pair ), pointer :: pair logical :: first first = . true . pair => self % first do while ( associated ( pair )) if ( first ) then first = . false . else write ( unit , '(a)' , advance = 'NO' ) repeat ( ' ' , indent ) end if select type ( value => pair % value ) class is ( type_dictionary ) write ( unit , '(a)' ) trim ( pair % key ) // ':' write ( unit , '(a)' , advance = 'NO' ) repeat ( ' ' , indent + 2 ) call value % dump ( unit , indent + 2 ) class is ( type_list ) write ( unit , '(a)' ) trim ( pair % key ) // ':' write ( unit , '(a)' , advance = 'NO' ) repeat ( ' ' , indent + 2 ) call value % dump ( unit , indent + 2 ) class default write ( unit , '(a)' , advance = 'NO' ) trim ( pair % key ) // ': ' call value % dump ( unit , indent + len_trim ( pair % key ) + 2 ) end select pair => pair % next end do end subroutine recursive subroutine dictionary_flatten ( self , target , prefix ) class ( type_dictionary ), intent ( in ) :: self type ( type_dictionary ), intent ( inout ) :: target character ( len =* ), intent ( in ) :: prefix type ( type_key_value_pair ), pointer :: pair pair => self % first do while ( associated ( pair )) select type ( value => pair % value ) class is ( type_scalar ) call target % set_string ( prefix // trim ( pair % key ), value % string ) class is ( type_dictionary ) call value % flatten ( target , prefix = prefix // trim ( pair % key ) // '/' ) end select pair => pair % next end do end subroutine function scalar_to_logical ( self , default , success ) result ( value ) class ( type_scalar ), intent ( in ) :: self logical , intent ( in ) :: default logical , optional , intent ( out ) :: success logical :: value integer :: ios value = default read ( self % string , * , iostat = ios ) value if ( present ( success )) success = ( ios == 0 ) end function function scalar_to_integer ( self , default , success ) result ( value ) class ( type_scalar ), intent ( in ) :: self integer , intent ( in ) :: default logical , optional , intent ( out ) :: success integer :: value integer :: ios value = default read ( self % string , * , iostat = ios ) value if ( present ( success )) success = ( ios == 0 ) end function function scalar_to_real ( self , default , success ) result ( value ) class ( type_scalar ), intent ( in ) :: self real ( real_kind ), intent ( in ) :: default logical , optional , intent ( out ) :: success real ( real_kind ) :: value integer :: ios value = default read ( self % string , * , iostat = ios ) value if ( present ( success )) success = ( ios == 0 ) end function recursive subroutine node_set_path ( self , path ) class ( type_node ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: path self % path = path end subroutine recursive subroutine dictionary_set_path ( self , path ) class ( type_dictionary ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: path type ( type_key_value_pair ), pointer :: pair self % path = path pair => self % first do while ( associated ( pair )) call pair % value % set_path ( trim ( self % path ) // '/' // trim ( pair % key )) pair => pair % next end do end subroutine function dictionary_get_scalar ( self , key , required , error ) result ( scalar ) class ( type_dictionary ), intent ( in ) :: self character ( len =* ), intent ( in ) :: key logical , intent ( in ) :: required type ( type_error ), pointer :: error class ( type_scalar ), pointer :: scalar class ( type_node ), pointer :: node nullify ( error ) nullify ( scalar ) node => self % get ( key ) if ( required . and .. not . associated ( node )) then allocate ( error ) error % message = trim ( self % path ) // ' does not contain key \"' // trim ( key ) // '\".' end if if ( associated ( node )) then select type ( node ) class is ( type_scalar ) scalar => node class is ( type_null ) allocate ( error ) error % message = trim ( node % path ) // ' must be set to a scalar value, not to null.' class is ( type_dictionary ) allocate ( error ) error % message = trim ( node % path ) // ' must be set to a scalar value, not to a dictionary.' class is ( type_list ) allocate ( error ) error % message = trim ( node % path ) // ' must be set to a scalar value, not to a list.' end select end if end function function dictionary_get_dictionary ( self , key , required , error ) result ( dictionary ) class ( type_dictionary ), intent ( in ) :: self character ( len =* ), intent ( in ) :: key logical , intent ( in ) :: required type ( type_error ), pointer :: error class ( type_dictionary ), pointer :: dictionary class ( type_node ), pointer :: node nullify ( error ) nullify ( dictionary ) node => self % get ( key ) if ( required . and .. not . associated ( node )) then allocate ( error ) error % message = trim ( self % path ) // ' does not contain key \"' // trim ( key ) // '\".' end if if ( associated ( node )) then select type ( typed_node => node ) class is ( type_null ) allocate ( dictionary ) dictionary % path = node % path class is ( type_dictionary ) dictionary => typed_node class default allocate ( error ) error % message = trim ( node % path ) // ' must be a dictionary.' end select end if end function function dictionary_get_list ( self , key , required , error ) result ( list ) class ( type_dictionary ), intent ( in ) :: self character ( len =* ), intent ( in ) :: key logical , intent ( in ) :: required type ( type_error ), pointer :: error class ( type_list ), pointer :: list class ( type_node ), pointer :: node nullify ( error ) nullify ( list ) node => self % get ( key ) if ( required . and .. not . associated ( node )) then allocate ( error ) error % message = trim ( self % path ) // ' does not contain key \"' // trim ( key ) // '\".' end if if ( associated ( node )) then select type ( typed_node => node ) class is ( type_null ) allocate ( list ) class is ( type_list ) list => typed_node class default allocate ( error ) error % message = trim ( node % path ) // ' must be a list.' end select end if end function function dictionary_get_string ( self , key , default , error ) result ( value ) class ( type_dictionary ), intent ( in ) :: self character ( len =* ), intent ( in ) :: key character ( len =* ), optional , intent ( in ) :: default type ( type_error ), pointer :: error character ( len = string_length ) :: value class ( type_scalar ), pointer :: node if ( present ( default )) value = default node => self % get_scalar ( key ,. not . present ( default ), error ) if ( associated ( node )) value = node % string end function function dictionary_get_logical ( self , key , default , error ) result ( value ) class ( type_dictionary ), intent ( in ) :: self character ( len =* ), intent ( in ) :: key logical , optional , intent ( in ) :: default type ( type_error ), pointer :: error logical :: value class ( type_scalar ), pointer :: node logical :: success if ( present ( default )) value = default node => self % get_scalar ( key ,. not . present ( default ), error ) if ( associated ( node )) then value = node % to_logical ( value , success ) if (. not . success ) then allocate ( error ) error % message = trim ( node % path ) // ' is set to \"' // trim ( node % string ) & // '\", which cannot be interpreted as a Boolean value.' end if end if end function function dictionary_get_integer ( self , key , default , error ) result ( value ) class ( type_dictionary ), intent ( in ) :: self character ( len =* ), intent ( in ) :: key integer , optional , intent ( in ) :: default type ( type_error ), pointer :: error integer :: value class ( type_scalar ), pointer :: node logical :: success if ( present ( default )) value = default node => self % get_scalar ( key ,. not . present ( default ), error ) if ( associated ( node )) then value = node % to_integer ( value , success ) if (. not . success ) then allocate ( error ) error % message = trim ( node % path ) // ' is set to \"' // trim ( node % string ) // '\", which cannot be interpreted as an integer.' end if end if end function function dictionary_get_real ( self , key , default , error ) result ( value ) class ( type_dictionary ), intent ( in ) :: self character ( len =* ), intent ( in ) :: key real ( real_kind ), optional , intent ( in ) :: default type ( type_error ), pointer :: error real ( real_kind ) :: value class ( type_scalar ), pointer :: node logical :: success if ( present ( default )) value = default node => self % get_scalar ( key ,. not . present ( default ), error ) if ( associated ( node )) then value = node % to_real ( value , success ) if (. not . success ) then allocate ( error ) error % message = trim ( node % path ) // ' is set to \"' // trim ( node % string ) // '\", which cannot be interpreted as a real number.' end if end if end function subroutine dictionary_finalize ( self ) class ( type_dictionary ), intent ( inout ) :: self type ( type_key_value_pair ), pointer :: pair , next pair => self % first do while ( associated ( pair )) next => pair % next call pair % value % finalize () deallocate ( pair % value ) deallocate ( pair ) pair => next end do nullify ( self % first ) end subroutine dictionary_finalize subroutine list_append ( self , node ) class ( type_list ), intent ( inout ) :: self class ( type_node ), target :: node type ( type_list_item ), pointer :: item if (. not . associated ( self % first )) then ! This will be the first pair. allocate ( self % first ) self % first % node => node else ! Try to find a pair with the same key, or failing that, the last pair. item => self % first do while ( associated ( item % next )) item => item % next end do allocate ( item % next ) item % next % node => node end if end subroutine list_append recursive subroutine list_dump ( self , unit , indent ) class ( type_list ), intent ( in ) :: self integer , intent ( in ) :: unit , indent type ( type_list_item ), pointer :: item logical :: first first = . true . item => self % first do while ( associated ( item )) if ( first ) then first = . false . else write ( unit , '(a)' , advance = 'NO' ) repeat ( ' ' , indent ) end if write ( unit , '(a)' , advance = 'NO' ) '- ' call item % node % dump ( unit , indent + 2 ) item => item % next end do end subroutine list_dump recursive subroutine list_set_path ( self , path ) class ( type_list ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: path type ( type_list_item ), pointer :: item integer :: inode character ( len = 6 ) :: strindex self % path = path inode = 0 item => self % first do while ( associated ( item )) write ( strindex , '(i0)' ) inode call item % node % set_path ( trim ( self % path ) // '[' // trim ( strindex ) // ']' ) inode = inode + 1 item => item % next end do end subroutine list_set_path end module yaml_types","tags":"","loc":"sourcefile/yaml_types.f90.html"},{"title":"test_yaml.F90 – Fortran Program","text":"This file depends on sourcefile~~test_yaml.f90~~EfferentGraph sourcefile~test_yaml.f90 test_yaml.F90 sourcefile~yaml_types.f90 yaml_types.F90 sourcefile~test_yaml.f90->sourcefile~yaml_types.f90 sourcefile~yaml.f90 yaml.F90 sourcefile~test_yaml.f90->sourcefile~yaml.f90 sourcefile~yaml_version.f90.in yaml_version.F90.in sourcefile~test_yaml.f90->sourcefile~yaml_version.f90.in sourcefile~yaml.f90->sourcefile~yaml_types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_yaml Source Code test_yaml.F90 Source Code ! ----------------------------------------------------------------------------- ! This file is part of Fortran-YAML: a lightweight YAML parser written in ! object-oriented Fortran. ! ! Official repository: https://github.com/BoldingBruggeman/fortran-yaml ! ! Copyright 2013-2016 Bolding & Bruggeman ApS. ! ! This is free software: you can redistribute it and/or modify it under ! the terms of the GNU General Public License as published by the Free Software ! Foundation (https://www.gnu.org/licenses/gpl.html). It is distributed in the ! hope that it will be useful, but WITHOUT ANY WARRANTY; without even the ! implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ! A copy of the license is provided in the COPYING file. ! ----------------------------------------------------------------------------- program test_yaml use yaml_version , only : yaml_commit_id => git_commit_id , & yaml_branch_name => git_branch_name use yaml_types use yaml use , intrinsic :: iso_fortran_env character ( error_length ) :: error character ( 256 ) :: path class ( type_node ), pointer :: root write ( * , * ) write ( * , * ) 'YAML version:   ' , yaml_commit_id , ' (' , yaml_branch_name , ' branch)' write ( * , * ) call get_command_argument ( 1 , path ) if ( path == '' ) then write ( * , * ) 'ERROR: path to YAML file not provided.' stop 2 end if root => parse ( path , unit = 100 , error = error ) if ( error /= '' ) then write ( * , * ) 'PARSE ERROR: ' // trim ( error ) stop 1 end if call root % dump ( unit = output_unit , indent = 0 ) end program","tags":"","loc":"sourcefile/test_yaml.f90.html"},{"title":"yaml_settings.F90 – Fortran Program","text":"This file depends on sourcefile~~yaml_settings.f90~~EfferentGraph sourcefile~yaml_settings.f90 yaml_settings.F90 sourcefile~yaml_types.f90 yaml_types.F90 sourcefile~yaml_settings.f90->sourcefile~yaml_types.f90 sourcefile~yaml.f90 yaml.F90 sourcefile~yaml_settings.f90->sourcefile~yaml.f90 sourcefile~yaml.f90->sourcefile~yaml_types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules yaml_settings Source Code yaml_settings.F90 Source Code module yaml_settings use yaml_types , only : yaml_real_kind => real_kind , type_yaml_node => type_node , type_yaml_null => type_null , & type_yaml_scalar => type_scalar , type_yaml_dictionary => type_dictionary , type_yaml_list => type_list , & type_yaml_list_item => type_list_item , type_yaml_error => type_error , type_yaml_key_value_pair => type_key_value_pair use yaml , only : yaml_parse => parse , yaml_error_length => error_length implicit none private public type_settings , type_option , report_error , type_settings_create , type_real_setting_create , type_logical_setting_create , & type_dictionary_populator , type_list_populator , type_settings_node , type_key_value_pair , type_list_item , type_real_setting , & type_logical_setting integer , parameter :: rk = yaml_real_kind real ( rk ), parameter :: default_minimum_real = - huge ( 1._rk ) real ( rk ), parameter :: default_maximum_real = huge ( 1._rk ) integer , parameter :: default_minimum_integer = - huge ( 1 ) integer , parameter :: default_maximum_integer = huge ( 1 ) type type_value character ( len = :), allocatable :: long_name character ( len = :), allocatable :: description class ( type_yaml_node ), pointer :: backing_store_node => null () character ( len = :), allocatable :: path class ( type_value ), pointer :: parent => null () contains procedure :: write_schema => value_write_schema procedure :: write_yaml => value_write_yaml procedure :: get_maximum_depth => value_get_maximum_depth procedure :: get_yaml_style => value_get_yaml_style procedure :: create_child end type type_value type type_settings_node class ( type_value ), pointer :: value => null () contains procedure :: set_value => node_set_value end type type , extends ( type_settings_node ) :: type_key_value_pair character ( len = :), allocatable :: key character ( len = :), allocatable :: name logical :: accessed = . false . type ( type_key_value_pair ), pointer :: next => null () end type type , extends ( type_settings_node ) :: type_list_item type ( type_list_item ), pointer :: next => null () end type type , abstract :: type_dictionary_populator contains procedure ( dictionary_populator_create ), deferred :: create end type type , abstract :: type_list_populator contains procedure :: set_length => list_populator_set_length procedure ( list_populator_create ), deferred :: create end type interface recursive subroutine list_populator_create ( self , index , item ) import type_list_populator , type_list_item class ( type_list_populator ), intent ( inout ) :: self integer , intent ( in ) :: index type ( type_list_item ), intent ( inout ) :: item end subroutine recursive subroutine dictionary_populator_create ( self , pair ) import type_dictionary_populator , type_key_value_pair class ( type_dictionary_populator ), intent ( inout ) :: self type ( type_key_value_pair ), intent ( inout ) :: pair end subroutine end interface type , extends ( type_value ) :: type_settings class ( type_yaml_dictionary ), pointer :: backing_store => null () class ( type_dictionary_populator ), pointer :: populator => null () type ( type_key_value_pair ), pointer :: first => null () contains procedure :: write_schema => settings_write_schema procedure :: write_yaml => settings_write_yaml procedure :: get_maximum_depth => settings_get_maximum_depth procedure :: get_yaml_style => settings_get_yaml_style procedure :: load procedure :: save procedure :: write_schema_file procedure :: get_real2 procedure :: get_integer2 procedure :: get_logical2 procedure :: get_string2 procedure :: get_integer procedure :: get_logical procedure :: get_string procedure :: get_child procedure :: get_list procedure :: get_node procedure :: check_all_used generic :: get => get_real2 , get_integer2 , get_logical2 , get_string2 procedure :: populate => settings_populate procedure :: finalize end type type_settings type , abstract , extends ( type_value ) :: type_scalar_setting character (:), allocatable :: units logical :: has_default = . false . contains procedure ( setting_as_string ), deferred :: as_string procedure :: write_yaml => setting_write_yaml procedure :: get_comment => setting_get_comment procedure :: get_maximum_depth => setting_get_maximum_depth end type type_scalar_setting abstract interface function setting_as_string ( self , use_default ) result ( string ) import type_scalar_setting class ( type_scalar_setting ), intent ( in ) :: self logical , intent ( in ) :: use_default character ( len = :), allocatable :: string end function end interface type type_option integer :: value character (:), allocatable :: long_name character (:), allocatable :: key end type type , extends ( type_value ) :: type_list type ( type_list_item ), pointer :: first => null () class ( type_list_populator ), pointer :: populator => null () contains procedure :: write_schema => list_write_schema procedure :: write_yaml => list_write_yaml procedure :: get_maximum_depth => list_get_maximum_depth procedure :: get_yaml_style => list_get_yaml_style end type type , extends ( type_scalar_setting ) :: type_integer_setting integer , pointer :: pvalue => null () integer :: value integer :: default = 0 integer :: minimum = default_minimum_integer integer :: maximum = default_maximum_integer type ( type_option ), allocatable :: options (:) contains procedure :: as_string => integer_as_string procedure :: write_schema => integer_write_schema procedure :: get_comment => integer_get_comment end type type , extends ( type_scalar_setting ) :: type_real_setting real ( rk ), pointer :: pvalue => null () real ( rk ) :: default = 0.0_rk real ( rk ) :: minimum = default_minimum_real real ( rk ) :: maximum = default_maximum_real contains procedure , nopass :: create => type_real_setting_create procedure :: as_string => real_as_string procedure :: write_schema => real_write_schema procedure :: get_comment => real_get_comment end type type , extends ( type_scalar_setting ) :: type_logical_setting logical , pointer :: pvalue => null () logical :: value logical :: default = . true . contains procedure , nopass :: create => type_logical_setting_create procedure :: as_string => logical_as_string procedure :: write_schema => logical_write_schema end type type , extends ( type_scalar_setting ) :: type_string_setting character (:), pointer :: pvalue => null () character (:), allocatable :: value character (:), allocatable :: default contains procedure :: as_string => string_as_string procedure :: write_schema => string_write_schema end type contains recursive subroutine value_write_schema ( self , unit , name , indent ) class ( type_value ), intent ( in ) :: self integer , intent ( in ) :: unit , indent character ( len =* ), intent ( in ) :: name stop 'value_write_schema not overridden' end subroutine recursive subroutine value_write_yaml ( self , unit , indent , comment_depth , header ) class ( type_value ), intent ( in ) :: self integer , intent ( in ) :: unit integer , intent ( in ) :: indent integer , intent ( in ) :: comment_depth logical , intent ( in ) :: header stop 'value_write_yaml not overridden' end subroutine recursive function value_get_maximum_depth ( self , name ) result ( maxdepth ) class ( type_value ), intent ( in ) :: self character ( len =* ), intent ( in ) :: name integer :: maxdepth stop 'value_get_maximum_depth not overridden' end function integer function value_get_yaml_style ( self ) class ( type_value ), intent ( in ) :: self value_get_yaml_style = 1 end function integer function settings_get_yaml_style ( self ) class ( type_settings ), intent ( in ) :: self settings_get_yaml_style = 2 if (. not . associated ( self % first )) settings_get_yaml_style = 0 end function integer function list_get_yaml_style ( self ) class ( type_list ), intent ( in ) :: self list_get_yaml_style = 2 if (. not . associated ( self % first )) list_get_yaml_style = 0 end function subroutine load ( self , path , unit ) class ( type_settings ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: path integer , intent ( in ) :: unit class ( type_yaml_node ), pointer :: root character ( len = yaml_error_length ) :: error root => yaml_parse ( path , unit , error ) if ( error /= '' ) then write ( * , * ) trim ( error ) stop 1 end if if (. not . allocated ( self % path )) self % path = '' self % backing_store => null () if ( associated ( root )) call settings_set_data ( self , root ) end subroutine load logical function check_all_used ( self ) class ( type_settings ), intent ( in ) :: self integer :: n n = 0 if ( associated ( self % backing_store )) call node_check ( self % backing_store , n ) check_all_used = n == 0 contains recursive subroutine node_check ( self , n ) class ( type_yaml_node ), intent ( in ) :: self integer , intent ( inout ) :: n type ( type_yaml_list_item ), pointer :: item type ( type_yaml_key_value_pair ), pointer :: pair select type ( self ) class is ( type_yaml_dictionary ) pair => self % first do while ( associated ( pair )) if (. not . pair % accessed ) then n = n + 1 if ( n == 1 ) write ( * , * ) 'ERROR: the following setting(s) were not recognized:' write ( * , * ) '- ' // trim ( pair % value % path ) else call node_check ( pair % value , n ) end if pair => pair % next end do class is ( type_yaml_list ) item => self % first do while ( associated ( item )) call node_check ( item % node , n ) item => item % next end do end select end subroutine end function check_all_used subroutine save ( self , path , unit ) class ( type_settings ), intent ( in ) :: self character ( len =* ), intent ( in ) :: path integer , intent ( in ) :: unit integer :: ios integer :: comment_depth open ( unit = unit , file = path , action = 'write' , encoding = 'UTF-8' , status = 'replace' , iostat = ios ) if ( ios /= 0 ) then write ( * , * ) 'Failed to open ' // path // ' for writing.' stop 1 end if comment_depth = self % get_maximum_depth ( '' ) + 1 call self % write_yaml ( unit , 0 , comment_depth , header = . false .) end subroutine save subroutine write_schema_file ( self , path , unit , version ) class ( type_settings ), intent ( in ) :: self character ( len =* ), intent ( in ) :: path integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: version integer :: ios type ( type_key_value_pair ), pointer :: pair open ( unit = unit , file = path , action = 'write' , status = 'replace' , iostat = ios ) if ( ios /= 0 ) then write ( * , * ) 'Failed to open ' // path // ' for writing.' stop 1 end if write ( unit , '(a)' ) '<?xml version=\"1.0\" ?>' write ( unit , '(a,a,a)' ) '<element name=\"scenario\" label=\"scenario\" version=\"' , version , '\" namelistextension=\".nml\"& & xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../../core/scenario-1.0.xsd\">' pair => self % first do while ( associated ( pair )) call pair % value % write_schema ( unit , pair % name , 2 ) pair => pair % next end do write ( unit , '(a)' ) '</element>' end subroutine write_schema_file recursive function get_node ( self , name , treat_as_path , istart ) result ( pair ) class ( type_settings ), intent ( inout ), target :: self character ( len =* ), intent ( in ) :: name logical , optional , intent ( in ) :: treat_as_path integer , optional , intent ( out ) :: istart type ( type_key_value_pair ), pointer :: pair integer :: istart_ class ( type_settings ), pointer :: settings logical :: treat_as_path_ integer :: islash istart_ = 1 settings => self treat_as_path_ = . true . if ( present ( treat_as_path )) treat_as_path_ = treat_as_path if ( treat_as_path_ ) then do islash = index ( name ( istart_ :), '/' ) if ( islash == 0 ) exit settings => get_child ( settings , name ( istart_ : istart_ + islash - 2 ), treat_as_path = . false .) istart_ = istart_ + islash end do end if if ( present ( istart )) istart = istart_ call get ( settings , name ( istart_ :)) contains subroutine get ( self , name ) class ( type_settings ), intent ( inout ), target :: self character ( len =* ), intent ( in ) :: name character ( len = len ( name )) :: key type ( type_key_value_pair ), pointer :: last_accessed key = string_lower ( name ) ! First try to find an existing pair with this key. last_accessed => null () pair => self % first do while ( associated ( pair )) if ( pair % key == key ) then if ( pair % accessed ) return exit end if if ( pair % accessed ) last_accessed => pair pair => pair % next end do if (. not . associated ( pair )) then ! Key not found - create a new key-setting pair and insert after all previously accessed settings (if any) allocate ( pair ) pair % key = key allocate ( type_value :: pair % value ) pair % value % parent => self pair % value % path = self % path // '/' // name if ( associated ( self % backing_store )) pair % value % backing_store_node => self % backing_store % get ( name ) end if pair % name = name pair % accessed = . true . if ( associated ( last_accessed )) then pair % next => last_accessed % next last_accessed % next => pair else pair % next => self % first self % first => pair end if end subroutine end function get_node subroutine get_real2 ( self , target , name , long_name , units , default , minimum , maximum , description ) class ( type_settings ), intent ( inout ) :: self real ( rk ), target :: target character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: long_name character ( len =* ), intent ( in ) :: units real ( rk ), optional , intent ( in ) :: default real ( rk ), optional , intent ( in ) :: minimum real ( rk ), optional , intent ( in ) :: maximum character ( len =* ), optional , intent ( in ) :: description class ( type_real_setting ), pointer :: setting setting => type_real_setting_create ( self % get_node ( name ), target , long_name , units , default , minimum , maximum , description ) end subroutine function type_real_setting_create ( node , target , long_name , units , default , minimum , maximum , description ) result ( setting ) class ( type_settings_node ), intent ( inout ) :: node real ( rk ), target :: target character ( len =* ), intent ( in ) :: long_name character ( len =* ), intent ( in ) :: units real ( rk ), optional , intent ( in ) :: default real ( rk ), optional , intent ( in ) :: minimum real ( rk ), optional , intent ( in ) :: maximum character ( len =* ), optional , intent ( in ) :: description class ( type_real_setting ), pointer :: setting select type ( value => node % value ) class is ( type_real_setting ) setting => value class default allocate ( setting ) call node % set_value ( setting ) end select setting % pvalue => target setting % long_name = long_name if ( units /= '' ) setting % units = units if ( present ( minimum )) setting % minimum = minimum if ( present ( maximum )) setting % maximum = maximum if ( present ( default )) then if ( default < setting % minimum ) call report_error ( 'Default value of setting ' // setting % path // & ' lies below prescribed minimum.' ) if ( default > setting % maximum ) call report_error ( 'Default value of setting ' // setting % path // & ' exceeds prescribed maximum.' ) setting % has_default = . true . setting % default = default end if if ( present ( description )) setting % description = description if ( associated ( setting % backing_store_node )) then call real_set_data ( setting , setting % backing_store_node ) elseif ( setting % has_default ) then setting % pvalue = setting % default else call report_error ( 'No value specified for setting ' // setting % path // '; cannot continue because& & this parameter does not have a default value either.' ) end if end function type_real_setting_create subroutine real_set_data ( self , backing_store_node ) class ( type_real_setting ), intent ( inout ) :: self class ( type_yaml_node ), intent ( in ) :: backing_store_node logical :: success select type ( backing_store_node ) class is ( type_yaml_scalar ) self % pvalue = backing_store_node % to_real ( self % pvalue , success ) if (. not . success ) call report_error ( self % path // ' is set to \"' // trim ( backing_store_node % string ) // & '\", which cannot be interpreted as a real number.' ) class default call report_error ( 'Setting ' // self % path // ' must be a real number.' ) end select if ( self % pvalue < self % minimum ) call report_error ( 'Value specified for parameter ' // self % path // & ' lies below prescribed minimum.' ) if ( self % pvalue > self % maximum ) call report_error ( 'Value specified for parameter ' // self % path // & ' exceeds prescribed maximum.' ) end subroutine function get_integer ( self , name , long_name , units , default , minimum , maximum , options , description ) result ( value ) class ( type_settings ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: long_name character ( len =* ), optional , intent ( in ) :: units integer , optional , intent ( in ) :: default integer , optional , intent ( in ) :: minimum integer , optional , intent ( in ) :: maximum type ( type_option ), optional , intent ( in ) :: options (:) character ( len =* ), optional , intent ( in ) :: description integer :: dummy , value call get_integer2 ( self , dummy , name , long_name , units , default , minimum , maximum , options , description , value ) end function subroutine get_integer2 ( self , target , name , long_name , units , default , minimum , maximum , options , description , value ) class ( type_settings ), intent ( inout ) :: self integer , target :: target character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: long_name character ( len =* ), optional , intent ( in ) :: units integer , optional , intent ( in ) :: default integer , optional , intent ( in ) :: minimum integer , optional , intent ( in ) :: maximum type ( type_option ), optional , intent ( in ) :: options (:) character ( len =* ), optional , intent ( in ) :: description integer , optional , intent ( out ) :: value class ( type_settings_node ), pointer :: node class ( type_integer_setting ), pointer :: setting integer :: ioption , ioption2 , ivalue logical :: found node => self % get_node ( name ) select type ( value => node % value ) class is ( type_integer_setting ) setting => value class default allocate ( setting ) call node % set_value ( setting ) end select if ( present ( value )) then setting % pvalue => setting % value else setting % pvalue => target end if setting % long_name = long_name if ( present ( units )) setting % units = units if ( present ( minimum )) setting % minimum = minimum if ( present ( maximum )) setting % maximum = maximum if ( present ( options )) then do ioption = 1 , size ( options ) do ioption2 = ioption + 1 , size ( options ) if ( options ( ioption )% value == options ( ioption2 )% value ) call report_error ( & 'Setting ' // setting % path // ' has multiple options with the same integer value.' ) end do end do if ( allocated ( setting % options )) deallocate ( setting % options ) allocate ( setting % options ( size ( options ))) ! Order options according to value ioption = 1 do ivalue = minval ( options (:)% value ), maxval ( options (:)% value ) do ioption2 = 1 , size ( options ) if ( options ( ioption2 )% value == ivalue ) then setting % options ( ioption ) = options ( ioption2 ) if ( allocated ( setting % options ( ioption )% key )) & setting % options ( ioption )% key = string_lower ( setting % options ( ioption )% key ) ioption = ioption + 1 exit end if end do end do end if if ( present ( default )) then if ( default < setting % minimum ) call report_error ( 'Default value of setting ' // setting % path // & ' lies below prescribed minimum.' ) if ( default > setting % maximum ) call report_error ( 'Default value of setting ' // setting % path // & ' exceeds prescribed maximum.' ) if ( allocated ( setting % options )) then found = . false . do ioption = 1 , size ( setting % options ) if ( default == setting % options ( ioption )% value ) found = . true . end do if (. not . found ) call report_error ( 'Default value of setting ' // setting % path // & ' does not correspond to any known option.' ) end if setting % has_default = . true . setting % default = default end if if ( present ( description )) setting % description = description if ( associated ( setting % backing_store_node )) then call integer_set_data ( setting , setting % backing_store_node ) elseif ( setting % has_default ) then setting % pvalue = setting % default else call report_error ( 'No value specified for setting ' // setting % path // '; cannot continue because& & it does not have a default value either.' ) end if if ( present ( value )) value = setting % pvalue end subroutine get_integer2 subroutine integer_set_data ( self , backing_store_node ) class ( type_integer_setting ), intent ( inout ) :: self class ( type_yaml_node ), intent ( in ) :: backing_store_node logical :: success integer :: ioption character ( len = :), allocatable :: strvalue select type ( backing_store_node ) class is ( type_yaml_scalar ) self % pvalue = backing_store_node % to_integer ( self % pvalue , success ) if (. not . success . and . allocated ( self % options )) then strvalue = string_lower ( trim ( backing_store_node % string )) do ioption = 1 , size ( self % options ) if ( strvalue == string_lower ( self % options ( ioption )% long_name )) then ! Value matches long name of option success = . true . elseif ( allocated ( self % options ( ioption )% key )) then ! Option has a key; check if value matches that if ( strvalue == self % options ( ioption )% key ) success = . true . end if if ( success ) then self % pvalue = self % options ( ioption )% value exit end if end do end if if (. not . success ) call report_error ( self % path // ' is set to \"' // trim ( backing_store_node % string ) // & '\", which cannot be interpreted as an integer number.' ) class default call report_error ( 'Setting ' // self % path // ' must be an integer number.' ) end select if ( self % pvalue < self % minimum ) call report_error ( 'Value specified for setting ' // self % path // & ' lies below prescribed minimum.' ) if ( self % pvalue > self % maximum ) call report_error ( 'Value specified for setting ' // self % path // & ' exceeds prescribed maximum.' ) if ( allocated ( self % options )) then success = . false . do ioption = 1 , size ( self % options ) if ( self % pvalue == self % options ( ioption )% value ) success = . true . end do if (. not . success ) call report_error ( 'Value specified for setting ' // self % path // & ' does not correspond to any known option.' ) end if end subroutine integer_set_data function get_logical ( self , name , long_name , default , description ) result ( value ) class ( type_settings ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: long_name logical , optional , intent ( in ) :: default character ( len =* ), optional , intent ( in ) :: description logical :: dummy , value call get_logical2 ( self , dummy , name , long_name , default , description , value ) end function get_logical subroutine get_logical2 ( self , target , name , long_name , default , description , value ) class ( type_settings ), intent ( inout ) :: self logical , target :: target character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: long_name logical , optional , intent ( in ) :: default character ( len =* ), optional , intent ( in ) :: description logical , optional , intent ( inout ) :: value class ( type_logical_setting ), pointer :: setting setting => type_logical_setting_create ( self % get_node ( name ), target , long_name , default , description , value ) end subroutine get_logical2 function type_logical_setting_create ( node , target , long_name , default , description , value ) result ( setting ) class ( type_settings_node ), intent ( inout ) :: node logical , target :: target character ( len =* ), intent ( in ) :: long_name logical , optional , intent ( in ) :: default character ( len =* ), optional , intent ( in ) :: description logical , optional , intent ( inout ) :: value class ( type_logical_setting ), pointer :: setting select type ( value => node % value ) class is ( type_logical_setting ) setting => value class default allocate ( setting ) call node % set_value ( setting ) end select if ( present ( value )) then setting % pvalue => setting % value else setting % pvalue => target end if setting % long_name = long_name if ( present ( default )) then setting % has_default = . true . setting % default = default end if if ( present ( description )) setting % description = description if ( associated ( setting % backing_store_node )) then call logical_set_data ( setting , setting % backing_store_node ) elseif ( setting % has_default ) then setting % pvalue = setting % default else call report_error ( 'No value specified for parameter ' // setting % path // '; cannot continue because& & this parameter does not have a default value either.' ) end if if ( present ( value )) value = setting % pvalue end function type_logical_setting_create subroutine logical_set_data ( self , backing_store_node ) class ( type_logical_setting ), intent ( inout ) :: self class ( type_yaml_node ), intent ( in ) :: backing_store_node logical :: success select type ( backing_store_node ) class is ( type_yaml_scalar ) self % pvalue = backing_store_node % to_logical ( self % pvalue , success ) if (. not . success ) call report_error ( self % path // ' is set to \"' // trim ( backing_store_node % string ) // & '\", which cannot be interpreted as logical value (true or false).' ) class default call report_error ( 'Setting ' // self % path // ' must be set to a logical value (true or false).' ) end select end subroutine function get_string ( self , name , long_name , units , default , description ) result ( value ) class ( type_settings ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: long_name character ( len =* ), optional , intent ( in ) :: units character ( len =* ), optional , intent ( in ) :: default character ( len =* ), optional , intent ( in ) :: description character ( len = :), allocatable :: value character ( len = 0 ) :: dummy call get_string2 ( self , dummy , name , long_name , units , default , description , value ) end function subroutine get_string2 ( self , target , name , long_name , units , default , description , value ) class ( type_settings ), intent ( inout ) :: self character ( len =* ), target :: target character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: long_name character ( len =* ), optional , intent ( in ) :: units character ( len =* ), optional , intent ( in ) :: default character ( len =* ), optional , intent ( in ) :: description character ( len = :), allocatable , optional :: value class ( type_settings_node ), pointer :: node class ( type_string_setting ), pointer :: setting node => self % get_node ( name ) select type ( value => node % value ) class is ( type_string_setting ) setting => value class default allocate ( setting ) call node % set_value ( setting ) end select if ( present ( value )) then setting % pvalue => null () else setting % pvalue => target end if setting % long_name = long_name if ( present ( units )) setting % units = units if ( present ( default )) then setting % has_default = . true . setting % default = default end if if ( present ( description )) setting % description = description if ( associated ( setting % backing_store_node )) then select type ( yaml_node => setting % backing_store_node ) class is ( type_yaml_null ) setting % value = '' class is ( type_yaml_scalar ) setting % value = trim ( yaml_node % string ) class default call report_error ( setting % path // ' must be be a string or null.' ) end select else if ( setting % has_default ) then setting % value = setting % default else call report_error ( 'No value specified for parameter ' // setting % path // '; cannot continue because& & this parameter does not have a default value either.' ) end if end if if ( associated ( setting % pvalue ) . and . . not . associated ( setting % pvalue , setting % value )) then setting % pvalue = setting % value deallocate ( setting % value ) else setting % pvalue => setting % value end if if ( present ( value )) value = setting % pvalue end subroutine get_string2 recursive function create_child ( self ) result ( child ) class ( type_value ), intent ( in ) :: self class ( type_settings ), pointer :: child if ( associated ( self % parent )) then child => self % parent % create_child () else allocate ( child ) end if end function create_child recursive function get_child ( self , name , long_name , treat_as_path , populator ) result ( child ) class ( type_settings ), target , intent ( inout ) :: self character ( len =* ), intent ( in ) :: name character ( len =* ), optional , intent ( in ) :: long_name logical , optional , intent ( in ) :: treat_as_path class ( type_dictionary_populator ), optional , target :: populator class ( type_settings ), pointer :: child class ( type_settings_node ), pointer :: node node => self % get_node ( name , treat_as_path = treat_as_path ) child => type_settings_create ( node , long_name , populator ) end function get_child subroutine node_set_value ( self , value ) class ( type_settings_node ), intent ( inout ) :: self class ( type_value ), target :: value value % parent => self % value % parent call move_alloc ( self % value % path , value % path ) value % backing_store_node => self % value % backing_store_node deallocate ( self % value ) self % value => value end subroutine function type_settings_create ( node , long_name , populator ) result ( child ) class ( type_settings_node ), optional , intent ( inout ) :: node character ( len =* ), optional , intent ( in ) :: long_name class ( type_dictionary_populator ), optional , target :: populator class ( type_settings ), pointer :: child logical :: create child => null () if ( present ( node )) then select type ( value => node % value ) class is ( type_settings ) child => value end select end if create = . not . associated ( child ) if ( create ) then child => node % value % parent % create_child () call node % set_value ( child ) end if if ( present ( long_name )) child % long_name = long_name if ( present ( populator )) child % populator => populator if (( create . or . present ( populator )) . and . associated ( child % backing_store_node )) & call settings_set_data ( child , child % backing_store_node ) end function subroutine settings_populate ( self , populator ) class ( type_settings ), target , intent ( inout ) :: self class ( type_dictionary_populator ), target :: populator self % populator => populator if ( associated ( self % backing_store_node )) call settings_set_data ( self , self % backing_store_node ) end subroutine recursive subroutine settings_set_data ( self , backing_store_node ) class ( type_settings ), target , intent ( inout ) :: self class ( type_yaml_node ), target :: backing_store_node type ( type_yaml_key_value_pair ), pointer :: yaml_pair class ( type_key_value_pair ), pointer :: pair select type ( backing_store_node ) class is ( type_yaml_dictionary ) self % backing_store => backing_store_node yaml_pair => self % backing_store % first do while ( associated ( yaml_pair )) if ( associated ( self % populator )) then pair => self % get_node ( trim ( yaml_pair % key )) call self % populator % create ( pair ) end if yaml_pair => yaml_pair % next end do class is ( type_yaml_null ) self % backing_store => null () class default call report_error ( self % path // ' should be a dictionary' ) end select end subroutine recursive subroutine get_list ( self , name , populator , long_name , treat_as_path ) class ( type_settings ), target , intent ( inout ) :: self character ( len =* ), intent ( in ) :: name character ( len =* ), optional , intent ( in ) :: long_name class ( type_list_populator ), target :: populator logical , optional , intent ( in ) :: treat_as_path class ( type_settings_node ), pointer :: node class ( type_list ), pointer :: list node => self % get_node ( name , treat_as_path = treat_as_path ) select type ( value => node % value ) class is ( type_list ) list => value class default allocate ( list ) call node % set_value ( list ) end select list % populator => populator if ( present ( long_name )) list % long_name = long_name if ( associated ( list % backing_store_node )) call list_set_data ( list , list % backing_store_node ) end subroutine get_list subroutine list_set_data ( self , backing_store_node ) class ( type_list ), target , intent ( inout ) :: self class ( type_yaml_node ), target :: backing_store_node type ( type_yaml_list_item ), pointer :: yaml_item type ( type_list_item ), pointer :: item , last_item integer :: i character ( len = 8 ) :: strindex select type ( backing_store_node ) class is ( type_yaml_list ) yaml_item => backing_store_node % first i = 0 do while ( associated ( yaml_item )) i = i + 1 yaml_item => yaml_item % next end do call self % populator % set_length ( i ) last_item => self % first yaml_item => backing_store_node % first i = 0 do while ( associated ( yaml_item )) i = i + 1 write ( strindex , '(i0)' ) i allocate ( item ) allocate ( type_value :: item % value ) item % value % path = self % path // '[' // strindex // ']' item % value % backing_store_node => yaml_item % node item % value % parent => self if (. not . associated ( last_item )) then self % first => item else last_item % next => item end if last_item => item call self % populator % create ( i , item ) yaml_item => yaml_item % next end do class is ( type_yaml_null ) class default call report_error ( self % path // ' should be a list' ) end select end subroutine subroutine finalize ( self ) class ( type_settings ), intent ( inout ) :: self type ( type_key_value_pair ), pointer :: current , next current => self % first do while ( associated ( current )) next => current % next select type ( value => current % value ) class is ( type_settings ) call value % finalize () end select deallocate ( current % value ) deallocate ( current ) current => next end do self % first => null () end subroutine finalize function string_lower ( string ) result ( lowerstring ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: lowerstring integer :: i , k lowerstring = string do i = 1 , len ( string ) k = iachar ( string ( i : i )) if ( k >= iachar ( 'A' ). and . k <= iachar ( 'Z' )) then k = k + iachar ( 'a' ) - iachar ( 'A' ) lowerstring ( i : i ) = achar ( k ) end if end do end function string_lower subroutine report_error ( message ) character ( len =* ), intent ( in ) :: message write ( * , * ) trim ( message ) stop 1 end subroutine report_error recursive subroutine settings_write_yaml ( self , unit , indent , comment_depth , header ) class ( type_settings ), intent ( in ) :: self integer , intent ( in ) :: unit integer , intent ( in ) :: indent integer , intent ( in ) :: comment_depth logical , intent ( in ) :: header type ( type_key_value_pair ), pointer :: pair integer :: style !if (header) then !   write (unit, '()') !   write (unit, '(\"# \",a,a)') repeat(' ', indent), repeat('-', 80) !   call write_header(self, name, indent) !   write (unit, '(\"# \",a,a)') repeat(' ', indent), repeat('-', 80) !end if pair => self % first do while ( associated ( pair )) if (. not . associated ( pair , self % first )) write ( unit , '(a)' , advance = 'no' ) repeat ( ' ' , indent ) write ( unit , '(a,\":\")' , advance = 'no' ) pair % name style = pair % value % get_yaml_style () if ( style == 1 ) then ! flow write ( unit , '(\" \")' , advance = 'no' ) call pair % value % write_yaml ( unit , indent + len ( pair % name ) + 2 , comment_depth - len ( pair % name ) - 2 , header = . false .) else ! block or null if ( allocated ( pair % value % long_name )) write ( unit , '(a,\"# \",a)' , advance = 'no' ) & repeat ( ' ' , comment_depth - len ( pair % name ) - 1 ), pair % value % long_name write ( unit , * ) if ( style == 2 ) then ! block write ( unit , '(a)' , advance = 'no' ) repeat ( ' ' , indent + 2 ) call pair % value % write_yaml ( unit , indent + 2 , comment_depth - 2 , header = . false .) end if end if pair => pair % next end do contains recursive subroutine write_header ( self , name , indent ) class ( type_value ), intent ( in ) :: self character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: indent type ( type_key_value_pair ), pointer :: pair integer :: ioption logical :: written write ( unit , '(\"# \",a,a,\": \")' , advance = 'no' ) repeat ( ' ' , indent ), name if ( allocated ( self % long_name )) write ( unit , '(a)' , advance = 'no' ) self % long_name write ( unit , * ) select type ( self ) class is ( type_settings ) pair => self % first do while ( associated ( pair )) call write_header ( pair % value , pair % name , indent + 2 ) pair => pair % next end do class is ( type_scalar_setting ) if ( allocated ( self % description )) write ( unit , '(\"# \",a,a)' ) repeat ( ' ' , indent + 2 ), self % description select type ( self ) class is ( type_real_setting ) !write (unit,'(\" (\",a,\")\")', advance='no') node%units written = . false . if ( self % minimum /= default_minimum_real ) then write ( unit , '(\"# \",a,a,a)' , advance = 'no' ) repeat ( ' ' , indent + 2 ), 'minimum: ' , format_real ( self % minimum ) written = . true . end if if ( self % maximum /= default_maximum_real ) then if ( written ) then write ( unit , '(\", \")' , advance = 'no' ) else write ( unit , '(\"# \",a)' , advance = 'no' ) repeat ( ' ' , indent + 2 ) end if write ( unit , '(a,a)' , advance = 'no' ) 'maximum: ' , format_real ( self % maximum ) written = . true . end if if ( self % has_default ) then if ( written ) then write ( unit , '(\", \")' , advance = 'no' ) else write ( unit , '(\"# \",a)' , advance = 'no' ) repeat ( ' ' , indent + 2 ) end if write ( unit , '(a,a)' , advance = 'no' ) 'default: ' , format_real ( self % default ) written = . true . end if if ( written ) write ( unit , * ) class is ( type_integer_setting ) !if (allocated(node%units)) write (unit,'(\" (\",a,\")\")', advance='no') node%units if ( allocated ( self % options )) then do ioption = 1 , size ( self % options ) !if (ioption > 1) write (unit,'(\", \")', advance='no') write ( unit , '(\"# \",a,i0,\": \",a)' ) repeat ( ' ' , indent + 2 ), self % options ( ioption )% value , & self % options ( ioption )% long_name end do end if end select end select end subroutine write_header end subroutine recursive subroutine list_write_yaml ( self , unit , indent , comment_depth , header ) class ( type_list ), intent ( in ) :: self integer , intent ( in ) :: unit integer , intent ( in ) :: indent integer , intent ( in ) :: comment_depth logical , intent ( in ) :: header type ( type_list_item ), pointer :: item item => self % first do while ( associated ( item )) if (. not . associated ( item , self % first )) write ( unit , '(a)' , advance = 'no' ) repeat ( ' ' , indent ) write ( unit , '(\"- \")' , advance = 'no' ) call item % value % write_yaml ( unit , indent + 2 , comment_depth - 2 , header = . false .) item => item % next end do end subroutine recursive subroutine setting_write_yaml ( self , unit , indent , comment_depth , header ) class ( type_scalar_setting ), intent ( in ) :: self integer , intent ( in ) :: unit integer , intent ( in ) :: indent integer , intent ( in ) :: comment_depth logical , intent ( in ) :: header character ( len = :), allocatable :: string , comment string = self % as_string (. false .) write ( unit , '(a,a,\"# \",a)' , advance = 'no' ) string , repeat ( ' ' , comment_depth - len ( string )), self % long_name if ( allocated ( self % units )) then if ( self % units == '-' ) then call append_string ( comment , '; ' , 'dimensionless' ) elseif ( self % units == '1' ) then call append_string ( comment , '; ' , 'fraction' ) else call append_string ( comment , '; ' , self % units ) end if end if call self % get_comment ( comment ) if ( self % has_default ) call append_string ( comment , '; ' , 'default=' // self % as_string (. true .)) if ( allocated ( comment )) write ( unit , '(\" [\",a,\"]\")' , advance = 'no' ) comment write ( unit , * ) end subroutine setting_write_yaml recursive subroutine setting_get_comment ( self , comment ) class ( type_scalar_setting ), intent ( in ) :: self character ( len = :), allocatable , intent ( inout ) :: comment end subroutine recursive function setting_get_maximum_depth ( self , name ) result ( maxdepth ) class ( type_scalar_setting ), intent ( in ) :: self character ( len =* ), intent ( in ) :: name integer :: maxdepth maxdepth = len ( name ) + 2 + len ( self % as_string (. false .)) end function recursive function settings_get_maximum_depth ( self , name ) result ( maxdepth ) class ( type_settings ), intent ( in ) :: self character ( len =* ), intent ( in ) :: name integer :: maxdepth type ( type_key_value_pair ), pointer :: pair maxdepth = len ( name ) + 1 pair => self % first do while ( associated ( pair )) maxdepth = max ( maxdepth , pair % value % get_maximum_depth ( pair % name ) + 2 ) pair => pair % next end do end function settings_get_maximum_depth recursive function list_get_maximum_depth ( self , name ) result ( maxdepth ) class ( type_list ), intent ( in ) :: self character ( len =* ), intent ( in ) :: name integer :: maxdepth type ( type_list_item ), pointer :: item maxdepth = len ( name ) + 1 item => self % first do while ( associated ( item )) maxdepth = max ( maxdepth , item % value % get_maximum_depth ( '' ) + 2 ) item => item % next end do end function list_get_maximum_depth function real_as_string ( self , use_default ) result ( string ) class ( type_real_setting ), intent ( in ) :: self logical , intent ( in ) :: use_default character ( len = :), allocatable :: string if ( use_default ) then string = format_real ( self % default ) else string = format_real ( self % pvalue ) end if end function real_as_string function format_real ( value ) result ( string ) real ( rk ), intent ( in ) :: value character (:), allocatable :: string integer :: idecimals real ( rk ) :: test character ( len = 15 ) :: tmp idecimals = - 1 if ( value < 1.e7_rk ) then do idecimals = 0 , 3 test = value * 1 0._rk ** idecimals if ( test == int ( test )) exit end do end if select case ( idecimals ) case ( 0 , 1 ) write ( tmp , '(f15.1)' ) value case ( 2 ) write ( tmp , '(f15.2)' ) value case ( 3 ) write ( tmp , '(f15.3)' ) value case default write ( tmp , '(e15.8)' ) value end select string = trim ( adjustl ( tmp )) end function recursive subroutine real_get_comment ( self , comment ) class ( type_real_setting ), intent ( in ) :: self character ( len = :), allocatable , intent ( inout ) :: comment if ( self % minimum /= default_minimum_real ) call append_string ( comment , '; ' , 'min=' // format_real ( self % minimum )) if ( self % maximum /= default_maximum_real ) call append_string ( comment , '; ' , 'max=' // format_real ( self % maximum )) end subroutine subroutine append_string ( target , infix , string ) character ( len = :), allocatable , intent ( inout ) :: target character ( len =* ), intent ( in ) :: infix , string if ( allocated ( target )) then target = target // infix // string else target = string end if end subroutine recursive subroutine integer_get_comment ( self , comment ) class ( type_integer_setting ), intent ( in ) :: self character ( len = :), allocatable , intent ( inout ) :: comment integer :: ioption if ( allocated ( self % options )) then do ioption = 1 , size ( self % options ) if ( allocated ( self % options ( ioption )% key )) then if ( self % options ( ioption )% key == string_lower ( self % options ( ioption )% long_name )) then call append_string ( comment , ', ' , self % options ( ioption )% key ) else call append_string ( comment , ', ' , self % options ( ioption )% key // '=' // self % options ( ioption )% long_name ) end if else call append_string ( comment , ', ' , format_integer ( self % options ( ioption )% value ) // '=' // & self % options ( ioption )% long_name ) end if end do else if ( self % minimum /= default_minimum_integer ) call append_string ( comment , '; ' , 'min=' // format_integer ( self % minimum )) if ( self % maximum /= default_maximum_integer ) call append_string ( comment , '; ' , 'max=' // format_integer ( self % maximum )) end if end subroutine function format_integer ( value ) result ( string ) integer , intent ( in ) :: value character ( len = :), allocatable :: string character ( len = 8 ) :: tmp write ( tmp , '(i0)' ) value string = trim ( tmp ) end function function integer_as_string ( self , use_default ) result ( string ) class ( type_integer_setting ), intent ( in ) :: self logical , intent ( in ) :: use_default character ( len = :), allocatable :: string integer :: value integer :: ioption value = self % pvalue if ( use_default ) value = self % default if ( allocated ( self % options )) then do ioption = 1 , size ( self % options ) if ( self % options ( ioption )% value == value . and . allocated ( self % options ( ioption )% key )) then string = self % options ( ioption )% key return end if end do end if string = format_integer ( value ) end function integer_as_string function logical_as_string ( self , use_default ) result ( string ) class ( type_logical_setting ), intent ( in ) :: self logical , intent ( in ) :: use_default character ( len = :), allocatable :: string logical :: value value = self % pvalue if ( use_default ) value = self % default if ( value ) then string = 'true' else string = 'false' end if end function logical_as_string function string_as_string ( self , use_default ) result ( string ) class ( type_string_setting ), intent ( in ) :: self logical , intent ( in ) :: use_default character ( len = :), allocatable :: string if ( use_default ) then string = self % default else string = trim ( self % pvalue ) end if end function string_as_string recursive subroutine settings_write_schema ( self , unit , name , indent ) class ( type_settings ), intent ( in ) :: self character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: unit , indent type ( type_key_value_pair ), pointer :: pair write ( unit , '(a,a,a,a)' , advance = 'no' ) repeat ( ' ' , indent ), '<element name=\"' , name , '\"' if ( allocated ( self % long_name )) write ( unit , '(a,a,a)' , advance = 'no' ) ' label=\"' , self % long_name , '\"' write ( unit , '(a)' ) '>' pair => self % first do while ( associated ( pair )) call pair % value % write_schema ( unit , pair % name , indent + 2 ) pair => pair % next end do write ( unit , '(a,a)' ) repeat ( ' ' , indent ), '</element>' end subroutine settings_write_schema recursive subroutine list_write_schema ( self , unit , name , indent ) class ( type_list ), intent ( in ) :: self character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: unit , indent end subroutine list_write_schema recursive subroutine integer_write_schema ( self , unit , name , indent ) class ( type_integer_setting ), intent ( in ) :: self character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: unit , indent integer :: ioption write ( unit , '(a,a,a,a)' , advance = 'no' ) repeat ( ' ' , indent ), '<element name=\"' , name , '\" type=\"integer\"' if ( allocated ( self % long_name )) write ( unit , '(a,a,a)' , advance = 'no' ) ' label=\"' , self % long_name , '\"' if ( self % minimum /= default_minimum_integer ) write ( unit , '(a,i0,a)' , advance = 'no' ) ' minInclusive=\"' , self % minimum , '\"' if ( self % maximum /= default_maximum_integer ) write ( unit , '(a,i0,a)' , advance = 'no' ) ' maxInclusive=\"' , self % maximum , '\"' if ( allocated ( self % options )) then write ( unit , '(a)' ) '>' write ( unit , '(a,a)' ) repeat ( ' ' , indent + 2 ), '<options>' do ioption = 1 , size ( self % options ) write ( unit , '(a,a,i0,a,a,a)' ) repeat ( ' ' , indent + 4 ), '<option value=\"' , self % options ( ioption )% value , '\" label=\"' , & self % options ( ioption )% long_name , '\"/>' end do write ( unit , '(a,a)' ) repeat ( ' ' , indent + 2 ), '</options>' write ( unit , '(a,a)' ) repeat ( ' ' , indent ), '</element>' else write ( unit , '(\"/>\")' ) end if end subroutine recursive subroutine real_write_schema ( self , unit , name , indent ) class ( type_real_setting ), intent ( in ) :: self character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: unit , indent write ( unit , '(a,a,a,a)' , advance = 'no' ) repeat ( ' ' , indent ), '<element name=\"' , name , '\" type=\"float\"' if ( allocated ( self % long_name )) write ( unit , '(a,a,a)' , advance = 'no' ) ' label=\"' , self % long_name , '\"' if ( self % minimum /= default_minimum_real ) & write ( unit , '(a,a,a)' , advance = 'no' ) ' minInclusive=\"' , format_real ( self % minimum ), '\"' if ( self % maximum /= default_maximum_real ) & write ( unit , '(a,a,a)' , advance = 'no' ) ' maxInclusive=\"' , format_real ( self % maximum ), '\"' write ( unit , '(\"/>\")' ) end subroutine recursive subroutine logical_write_schema ( self , unit , name , indent ) class ( type_logical_setting ), intent ( in ) :: self character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: unit , indent write ( unit , '(a,a,a,a)' , advance = 'no' ) repeat ( ' ' , indent ), '<element name=\"' , name , '\" type=\"bool\"' if ( allocated ( self % long_name )) write ( unit , '(a,a,a)' , advance = 'no' ) ' label=\"' , self % long_name , '\"' write ( unit , '(\"/>\")' ) end subroutine recursive subroutine string_write_schema ( self , unit , name , indent ) class ( type_string_setting ), intent ( in ) :: self character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: unit , indent write ( unit , '(a,a,a,a)' , advance = 'no' ) repeat ( ' ' , indent ), '<element name=\"' , name , '\" type=\"string\"' if ( allocated ( self % long_name )) write ( unit , '(a,a,a)' , advance = 'no' ) ' label=\"' , self % long_name , '\"' write ( unit , '(\"/>\")' ) end subroutine subroutine list_populator_set_length ( self , n ) class ( type_list_populator ), intent ( inout ) :: self integer , intent ( in ) :: n end subroutine end module yaml_settings","tags":"","loc":"sourcefile/yaml_settings.f90.html"},{"title":"type_file – Fortran Program ","text":"type, private :: type_file Contents Variables unit line indent eof iline error_message has_error Type-Bound Procedures next_line set_error Components Type Visibility Attributes Name Initial integer, public :: unit = -1 character(len=line_length), public :: line = '' integer, public :: indent = 0 logical, public :: eof = .false. integer, public :: iline = 0 character(len=error_length), public :: error_message = '' logical, public :: has_error = .false. Type-Bound Procedures procedure, public :: next_line private subroutine next_line (file) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: file procedure, public :: set_error private subroutine set_error (file, error) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: file character(len=*), intent(in) :: error","tags":"","loc":"type/type_file.html"},{"title":"type_node – Fortran Program ","text":"type, public, abstract :: type_node Inherited by type~~type_node~~InheritedByGraph type~type_node type_node type~type_null type_null type~type_null->type~type_node type~type_list type_list type~type_list->type~type_node type~type_list_item type_list_item type~type_list->type~type_list_item first type~type_scalar type_scalar type~type_scalar->type~type_node type~type_key_value_pair type_key_value_pair type~type_key_value_pair->type~type_node value type~type_key_value_pair->type~type_key_value_pair next type~type_list_item->type~type_node node type~type_list_item->type~type_list_item next type~type_dictionary type_dictionary type~type_dictionary->type~type_node type~type_dictionary->type~type_key_value_pair first Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables path Type-Bound Procedures dump set_path finalize Components Type Visibility Attributes Name Initial character(len=string_length), public :: path = '' Type-Bound Procedures procedure( node_dump ), public, deferred :: dump subroutine node_dump(self, unit, indent) Prototype Arguments Type Intent Optional Attributes Name class( type_node ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent procedure, public :: set_path => node_set_path private recursive subroutine node_set_path (self, path) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self character(len=*), intent(in) :: path procedure, public :: finalize => node_finalize private subroutine node_finalize (self) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self","tags":"","loc":"type/type_node.html"},{"title":"type_scalar – Fortran Program ","text":"type, public, extends( type_node ) :: type_scalar Inherits type~~type_scalar~~InheritsGraph type~type_scalar type_scalar type~type_node type_node type~type_scalar->type~type_node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables path string Type-Bound Procedures set_path finalize dump to_logical to_integer to_real Components Type Visibility Attributes Name Initial character(len=string_length), public :: path = '' character(len=string_length), public :: string = '' Type-Bound Procedures procedure, public :: set_path => node_set_path private recursive subroutine node_set_path (self, path) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self character(len=*), intent(in) :: path procedure, public :: finalize => node_finalize private subroutine node_finalize (self) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self procedure, public :: dump => value_dump private subroutine value_dump (self, unit, indent) Arguments Type Intent Optional Attributes Name class( type_scalar ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent procedure, public :: to_logical => scalar_to_logical private function scalar_to_logical (self, default, success) result(value) Arguments Type Intent Optional Attributes Name class( type_scalar ), intent(in) :: self logical, intent(in) :: default logical, intent(out), optional :: success Return Value logical procedure, public :: to_integer => scalar_to_integer private function scalar_to_integer (self, default, success) result(value) Arguments Type Intent Optional Attributes Name class( type_scalar ), intent(in) :: self integer, intent(in) :: default logical, intent(out), optional :: success Return Value integer procedure, public :: to_real => scalar_to_real private function scalar_to_real (self, default, success) result(value) Arguments Type Intent Optional Attributes Name class( type_scalar ), intent(in) :: self real(kind=real_kind), intent(in) :: default logical, intent(out), optional :: success Return Value real(kind=real_kind)","tags":"","loc":"type/type_scalar.html"},{"title":"type_null – Fortran Program ","text":"type, public, extends( type_node ) :: type_null Inherits type~~type_null~~InheritsGraph type~type_null type_null type~type_node type_node type~type_null->type~type_node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables path Type-Bound Procedures set_path finalize dump Components Type Visibility Attributes Name Initial character(len=string_length), public :: path = '' Type-Bound Procedures procedure, public :: set_path => node_set_path private recursive subroutine node_set_path (self, path) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self character(len=*), intent(in) :: path procedure, public :: finalize => node_finalize private subroutine node_finalize (self) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self procedure, public :: dump => null_dump private subroutine null_dump (self, unit, indent) Arguments Type Intent Optional Attributes Name class( type_null ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent","tags":"","loc":"type/type_null.html"},{"title":"type_key_value_pair – Fortran Program ","text":"type, public :: type_key_value_pair Inherits type~~type_key_value_pair~~InheritsGraph type~type_key_value_pair type_key_value_pair type~type_key_value_pair->type~type_key_value_pair next type~type_node type_node type~type_key_value_pair->type~type_node value Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_key_value_pair~~InheritedByGraph type~type_key_value_pair type_key_value_pair type~type_key_value_pair->type~type_key_value_pair next type~type_dictionary type_dictionary type~type_dictionary->type~type_key_value_pair first Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables key value accessed next Components Type Visibility Attributes Name Initial character(len=string_length), public :: key = '' class( type_node ), public, pointer :: value => null() logical, public :: accessed = .false. type( type_key_value_pair ), public, pointer :: next => null()","tags":"","loc":"type/type_key_value_pair.html"},{"title":"type_dictionary – Fortran Program ","text":"type, public, extends( type_node ) :: type_dictionary Inherits type~~type_dictionary~~InheritsGraph type~type_dictionary type_dictionary type~type_node type_node type~type_dictionary->type~type_node type~type_key_value_pair type_key_value_pair type~type_dictionary->type~type_key_value_pair first type~type_key_value_pair->type~type_node value type~type_key_value_pair->type~type_key_value_pair next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables path first Type-Bound Procedures get get_scalar get_dictionary get_list get_string get_logical get_integer get_real set set_string dump flatten reset_accessed set_path finalize Components Type Visibility Attributes Name Initial character(len=string_length), public :: path = '' type( type_key_value_pair ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: get => dictionary_get private function dictionary_get (self, key) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key Return Value class( type_node ),\n  pointer procedure, public :: get_scalar => dictionary_get_scalar private function dictionary_get_scalar (self, key, required, error) result(scalar) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key logical, intent(in) :: required type( type_error ), pointer :: error Return Value class( type_scalar ),\n  pointer procedure, public :: get_dictionary => dictionary_get_dictionary private function dictionary_get_dictionary (self, key, required, error) result(dictionary) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key logical, intent(in) :: required type( type_error ), pointer :: error Return Value class( type_dictionary ),\n  pointer procedure, public :: get_list => dictionary_get_list private function dictionary_get_list (self, key, required, error) result(list) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key logical, intent(in) :: required type( type_error ), pointer :: error Return Value class( type_list ),\n  pointer procedure, public :: get_string => dictionary_get_string private function dictionary_get_string (self, key, default, error) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key character(len=*), intent(in), optional :: default type( type_error ), pointer :: error Return Value character(len=string_length) procedure, public :: get_logical => dictionary_get_logical private function dictionary_get_logical (self, key, default, error) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key logical, intent(in), optional :: default type( type_error ), pointer :: error Return Value logical procedure, public :: get_integer => dictionary_get_integer private function dictionary_get_integer (self, key, default, error) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key integer, intent(in), optional :: default type( type_error ), pointer :: error Return Value integer procedure, public :: get_real => dictionary_get_real private function dictionary_get_real (self, key, default, error) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key real(kind=real_kind), intent(in), optional :: default type( type_error ), pointer :: error Return Value real(kind=real_kind) procedure, public :: set => dictionary_set private subroutine dictionary_set (self, key, value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(inout) :: self character(len=*), intent(in) :: key class( type_node ), pointer :: value procedure, public :: set_string => dictionary_set_string private subroutine dictionary_set_string (self, key, value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(inout) :: self character(len=*), intent(in) :: key character(len=*), intent(in) :: value procedure, public :: dump => dictionary_dump private recursive subroutine dictionary_dump (self, unit, indent) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent procedure, public :: flatten => dictionary_flatten private recursive subroutine dictionary_flatten (self, target, prefix) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self type( type_dictionary ), intent(inout) :: target character(len=*), intent(in) :: prefix procedure, public :: reset_accessed => dictionary_reset_accessed private subroutine dictionary_reset_accessed (self) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self procedure, public :: set_path => dictionary_set_path private recursive subroutine dictionary_set_path (self, path) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(inout) :: self character(len=*), intent(in) :: path procedure, public :: finalize => dictionary_finalize private subroutine dictionary_finalize (self) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(inout) :: self","tags":"","loc":"type/type_dictionary.html"},{"title":"type_list_item – Fortran Program ","text":"type, public :: type_list_item Inherits type~~type_list_item~~InheritsGraph type~type_list_item type_list_item type~type_list_item->type~type_list_item next type~type_node type_node type~type_list_item->type~type_node node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_list_item~~InheritedByGraph type~type_list_item type_list_item type~type_list_item->type~type_list_item next type~type_list type_list type~type_list->type~type_list_item first Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables node next Components Type Visibility Attributes Name Initial class( type_node ), public, pointer :: node => null() type( type_list_item ), public, pointer :: next => null()","tags":"","loc":"type/type_list_item.html"},{"title":"type_list – Fortran Program ","text":"type, public, extends( type_node ) :: type_list Inherits type~~type_list~~InheritsGraph type~type_list type_list type~type_list_item type_list_item type~type_list->type~type_list_item first type~type_node type_node type~type_list->type~type_node type~type_list_item->type~type_list_item next type~type_list_item->type~type_node node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables path first Type-Bound Procedures finalize append dump set_path Components Type Visibility Attributes Name Initial character(len=string_length), public :: path = '' type( type_list_item ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: finalize => node_finalize private subroutine node_finalize (self) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self procedure, public :: append => list_append private subroutine list_append (self, node) Arguments Type Intent Optional Attributes Name class( type_list ), intent(inout) :: self class( type_node ), target :: node procedure, public :: dump => list_dump private recursive subroutine list_dump (self, unit, indent) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent procedure, public :: set_path => list_set_path private recursive subroutine list_set_path (self, path) Arguments Type Intent Optional Attributes Name class( type_list ), intent(inout) :: self character(len=*), intent(in) :: path","tags":"","loc":"type/type_list.html"},{"title":"type_error – Fortran Program ","text":"type, public :: type_error Contents Variables message Components Type Visibility Attributes Name Initial character(len=string_length), public :: message","tags":"","loc":"type/type_error.html"},{"title":"type_value – Fortran Program ","text":"type, private :: type_value Inherits type~~type_value~~InheritsGraph type~type_value type_value type~type_value->type~type_value parent type_yaml_node type_yaml_node type~type_value->type_yaml_node backing_store_node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_value~~InheritedByGraph type~type_value type_value type~type_value->type~type_value parent type~type_settings type_settings type~type_settings->type~type_value type~type_key_value_pair~2 type_key_value_pair type~type_settings->type~type_key_value_pair~2 first type~type_settings_node type_settings_node type~type_settings_node->type~type_value value type~type_scalar_setting type_scalar_setting type~type_scalar_setting->type~type_value type~type_list~2 type_list type~type_list~2->type~type_value type~type_list_item~2 type_list_item type~type_list~2->type~type_list_item~2 first type~type_list_item~2->type~type_settings_node type~type_list_item~2->type~type_list_item~2 next type~type_string_setting type_string_setting type~type_string_setting->type~type_scalar_setting type~type_real_setting type_real_setting type~type_real_setting->type~type_scalar_setting type~type_integer_setting type_integer_setting type~type_integer_setting->type~type_scalar_setting type~type_logical_setting type_logical_setting type~type_logical_setting->type~type_scalar_setting type~type_key_value_pair~2->type~type_settings_node type~type_key_value_pair~2->type~type_key_value_pair~2 next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables long_name description backing_store_node path parent Type-Bound Procedures write_schema write_yaml get_maximum_depth get_yaml_style create_child Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() Type-Bound Procedures procedure, public :: write_schema => value_write_schema private recursive subroutine value_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent procedure, public :: write_yaml => value_write_yaml private recursive subroutine value_write_yaml (self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header procedure, public :: get_maximum_depth => value_get_maximum_depth private recursive function value_get_maximum_depth (self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer procedure, public :: get_yaml_style => value_get_yaml_style private function value_get_yaml_style (self) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value integer procedure, public :: create_child private recursive function create_child (self) result(child) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value class( type_settings ),\n  pointer","tags":"","loc":"type/type_value.html"},{"title":"type_settings_node – Fortran Program ","text":"type, public :: type_settings_node Inherits type~~type_settings_node~~InheritsGraph type~type_settings_node type_settings_node type~type_value type_value type~type_settings_node->type~type_value value type~type_value->type~type_value parent type_yaml_node type_yaml_node type~type_value->type_yaml_node backing_store_node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_settings_node~~InheritedByGraph type~type_settings_node type_settings_node type~type_list_item~2 type_list_item type~type_list_item~2->type~type_settings_node type~type_list_item~2->type~type_list_item~2 next type~type_key_value_pair~2 type_key_value_pair type~type_key_value_pair~2->type~type_settings_node type~type_key_value_pair~2->type~type_key_value_pair~2 next type~type_list~2 type_list type~type_list~2->type~type_list_item~2 first type~type_settings type_settings type~type_settings->type~type_key_value_pair~2 first Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables value Type-Bound Procedures set_value Components Type Visibility Attributes Name Initial class( type_value ), public, pointer :: value => null() Type-Bound Procedures procedure, public :: set_value => node_set_value private subroutine node_set_value (self, value) Arguments Type Intent Optional Attributes Name class( type_settings_node ), intent(inout) :: self class( type_value ), target :: value","tags":"","loc":"type/type_settings_node.html"},{"title":"type_key_value_pair – Fortran Program ","text":"type, public, extends( type_settings_node ) :: type_key_value_pair Inherits type~~type_key_value_pair~2~~InheritsGraph type~type_key_value_pair~2 type_key_value_pair type~type_key_value_pair~2->type~type_key_value_pair~2 next type~type_settings_node type_settings_node type~type_key_value_pair~2->type~type_settings_node type~type_value type_value type~type_settings_node->type~type_value value type~type_value->type~type_value parent type_yaml_node type_yaml_node type~type_value->type_yaml_node backing_store_node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_key_value_pair~2~~InheritedByGraph type~type_key_value_pair~2 type_key_value_pair type~type_key_value_pair~2->type~type_key_value_pair~2 next type~type_settings type_settings type~type_settings->type~type_key_value_pair~2 first Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables value key name accessed next Type-Bound Procedures set_value Components Type Visibility Attributes Name Initial class( type_value ), public, pointer :: value => null() character(len=:), public, allocatable :: key character(len=:), public, allocatable :: name logical, public :: accessed = .false. type( type_key_value_pair ), public, pointer :: next => null() Type-Bound Procedures procedure, public :: set_value => node_set_value private subroutine node_set_value (self, value) Arguments Type Intent Optional Attributes Name class( type_settings_node ), intent(inout) :: self class( type_value ), target :: value","tags":"","loc":"type/type_key_value_pair~2.html"},{"title":"type_list_item – Fortran Program ","text":"type, public, extends( type_settings_node ) :: type_list_item Inherits type~~type_list_item~2~~InheritsGraph type~type_list_item~2 type_list_item type~type_list_item~2->type~type_list_item~2 next type~type_settings_node type_settings_node type~type_list_item~2->type~type_settings_node type~type_value type_value type~type_settings_node->type~type_value value type~type_value->type~type_value parent type_yaml_node type_yaml_node type~type_value->type_yaml_node backing_store_node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_list_item~2~~InheritedByGraph type~type_list_item~2 type_list_item type~type_list_item~2->type~type_list_item~2 next type~type_list~2 type_list type~type_list~2->type~type_list_item~2 first Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables value next Type-Bound Procedures set_value Components Type Visibility Attributes Name Initial class( type_value ), public, pointer :: value => null() type( type_list_item ), public, pointer :: next => null() Type-Bound Procedures procedure, public :: set_value => node_set_value private subroutine node_set_value (self, value) Arguments Type Intent Optional Attributes Name class( type_settings_node ), intent(inout) :: self class( type_value ), target :: value","tags":"","loc":"type/type_list_item~2.html"},{"title":"type_dictionary_populator – Fortran Program ","text":"type, public, abstract :: type_dictionary_populator Inherited by type~~type_dictionary_populator~~InheritedByGraph type~type_dictionary_populator type_dictionary_populator type~type_settings type_settings type~type_settings->type~type_dictionary_populator populator Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures create Type-Bound Procedures procedure( dictionary_populator_create ), public, deferred :: create recursive subroutine dictionary_populator_create(self, pair) Prototype Arguments Type Intent Optional Attributes Name class( type_dictionary_populator ), intent(inout) :: self type( type_key_value_pair ), intent(inout) :: pair","tags":"","loc":"type/type_dictionary_populator.html"},{"title":"type_list_populator – Fortran Program ","text":"type, public, abstract :: type_list_populator Inherited by type~~type_list_populator~~InheritedByGraph type~type_list_populator type_list_populator type~type_list~2 type_list type~type_list~2->type~type_list_populator populator Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures set_length create Type-Bound Procedures procedure, public :: set_length => list_populator_set_length private subroutine list_populator_set_length (self, n) Arguments Type Intent Optional Attributes Name class( type_list_populator ), intent(inout) :: self integer, intent(in) :: n procedure( list_populator_create ), public, deferred :: create recursive subroutine list_populator_create(self, index, item) Prototype Arguments Type Intent Optional Attributes Name class( type_list_populator ), intent(inout) :: self integer, intent(in) :: index type( type_list_item ), intent(inout) :: item","tags":"","loc":"type/type_list_populator.html"},{"title":"type_settings – Fortran Program ","text":"type, public, extends( type_value ) :: type_settings Inherits type~~type_settings~~InheritsGraph type~type_settings type_settings type_yaml_dictionary type_yaml_dictionary type~type_settings->type_yaml_dictionary backing_store type~type_dictionary_populator type_dictionary_populator type~type_settings->type~type_dictionary_populator populator type~type_key_value_pair~2 type_key_value_pair type~type_settings->type~type_key_value_pair~2 first type~type_value type_value type~type_settings->type~type_value type~type_key_value_pair~2->type~type_key_value_pair~2 next type~type_settings_node type_settings_node type~type_key_value_pair~2->type~type_settings_node type~type_value->type~type_value parent type_yaml_node type_yaml_node type~type_value->type_yaml_node backing_store_node type~type_settings_node->type~type_value value var pantypetype_settingsInheritsGraph = svgPanZoom('#typetype_settingsInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables long_name description backing_store_node path parent backing_store populator first Type-Bound Procedures create_child write_schema write_yaml get_maximum_depth get_yaml_style load save write_schema_file get_real2 get_integer2 get_logical2 get_string2 get_integer get_logical get_string get_child get_list get_node check_all_used get populate finalize Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() class(type_yaml_dictionary), public, pointer :: backing_store => null() class( type_dictionary_populator ), public, pointer :: populator => null() type( type_key_value_pair ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: create_child private recursive function create_child (self) result(child) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value class( type_settings ),\n  pointer procedure, public :: write_schema => settings_write_schema private recursive subroutine settings_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent procedure, public :: write_yaml => settings_write_yaml private recursive subroutine settings_write_yaml (self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header procedure, public :: get_maximum_depth => settings_get_maximum_depth private recursive function settings_get_maximum_depth (self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer procedure, public :: get_yaml_style => settings_get_yaml_style private function settings_get_yaml_style (self) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self Return Value integer procedure, public :: load private subroutine load (self, path, unit) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), intent(in) :: path integer, intent(in) :: unit procedure, public :: save private subroutine save (self, path, unit) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self character(len=*), intent(in) :: path integer, intent(in) :: unit procedure, public :: write_schema_file private subroutine write_schema_file (self, path, unit, version) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self character(len=*), intent(in) :: path integer, intent(in) :: unit character(len=*), intent(in) :: version procedure, public :: get_real2 private subroutine get_real2 (self, target, name, long_name, units, default, minimum, maximum, description) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self real(kind=rk), target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in) :: units real(kind=rk), intent(in), optional :: default real(kind=rk), intent(in), optional :: minimum real(kind=rk), intent(in), optional :: maximum character(len=*), intent(in), optional :: description procedure, public :: get_integer2 private subroutine get_integer2 (self, target, name, long_name, units, default, minimum, maximum, options, description, value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self integer, target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: units integer, intent(in), optional :: default integer, intent(in), optional :: minimum integer, intent(in), optional :: maximum type( type_option ), intent(in), optional :: options (:) character(len=*), intent(in), optional :: description integer, intent(out), optional :: value procedure, public :: get_logical2 private subroutine get_logical2 (self, target, name, long_name, default, description, value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self logical, target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name logical, intent(in), optional :: default character(len=*), intent(in), optional :: description logical, intent(inout), optional :: value procedure, public :: get_string2 private subroutine get_string2 (self, target, name, long_name, units, default, description, value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: units character(len=*), intent(in), optional :: default character(len=*), intent(in), optional :: description character(len=:), optional allocatable :: value procedure, public :: get_integer private function get_integer (self, name, long_name, units, default, minimum, maximum, options, description) result(value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: units integer, intent(in), optional :: default integer, intent(in), optional :: minimum integer, intent(in), optional :: maximum type( type_option ), intent(in), optional :: options (:) character(len=*), intent(in), optional :: description Return Value integer procedure, public :: get_logical private function get_logical (self, name, long_name, default, description) result(value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name logical, intent(in), optional :: default character(len=*), intent(in), optional :: description Return Value logical procedure, public :: get_string private function get_string (self, name, long_name, units, default, description) result(value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: units character(len=*), intent(in), optional :: default character(len=*), intent(in), optional :: description Return Value character(len=:),\n  allocatable procedure, public :: get_child private recursive function get_child (self, name, long_name, treat_as_path, populator) result(child) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout), target :: self character(len=*), intent(in) :: name character(len=*), intent(in), optional :: long_name logical, intent(in), optional :: treat_as_path class( type_dictionary_populator ), optional target :: populator Return Value class( type_settings ),\n  pointer procedure, public :: get_list private recursive subroutine get_list (self, name, populator, long_name, treat_as_path) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout), target :: self character(len=*), intent(in) :: name class( type_list_populator ), target :: populator character(len=*), intent(in), optional :: long_name logical, intent(in), optional :: treat_as_path procedure, public :: get_node private recursive function get_node (self, name, treat_as_path, istart) result(pair) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout), target :: self character(len=*), intent(in) :: name logical, intent(in), optional :: treat_as_path integer, intent(out), optional :: istart Return Value type( type_key_value_pair ),\n  pointer procedure, public :: check_all_used private function check_all_used (self) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self Return Value logical generic, public :: get => get_real2 , get_integer2 , get_logical2 , get_string2 private subroutine get_real2 (self, target, name, long_name, units, default, minimum, maximum, description) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self real(kind=rk), target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in) :: units real(kind=rk), intent(in), optional :: default real(kind=rk), intent(in), optional :: minimum real(kind=rk), intent(in), optional :: maximum character(len=*), intent(in), optional :: description private subroutine get_integer2 (self, target, name, long_name, units, default, minimum, maximum, options, description, value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self integer, target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: units integer, intent(in), optional :: default integer, intent(in), optional :: minimum integer, intent(in), optional :: maximum type( type_option ), intent(in), optional :: options (:) character(len=*), intent(in), optional :: description integer, intent(out), optional :: value private subroutine get_logical2 (self, target, name, long_name, default, description, value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self logical, target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name logical, intent(in), optional :: default character(len=*), intent(in), optional :: description logical, intent(inout), optional :: value private subroutine get_string2 (self, target, name, long_name, units, default, description, value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: units character(len=*), intent(in), optional :: default character(len=*), intent(in), optional :: description character(len=:), optional allocatable :: value procedure, public :: populate => settings_populate private subroutine settings_populate (self, populator) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout), target :: self class( type_dictionary_populator ), target :: populator procedure, public :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self","tags":"","loc":"type/type_settings.html"},{"title":"type_scalar_setting – Fortran Program ","text":"type, private, abstract, extends( type_value ) :: type_scalar_setting Inherits type~~type_scalar_setting~~InheritsGraph type~type_scalar_setting type_scalar_setting type~type_value type_value type~type_scalar_setting->type~type_value type~type_value->type~type_value parent type_yaml_node type_yaml_node type~type_value->type_yaml_node backing_store_node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_scalar_setting~~InheritedByGraph type~type_scalar_setting type_scalar_setting type~type_string_setting type_string_setting type~type_string_setting->type~type_scalar_setting type~type_real_setting type_real_setting type~type_real_setting->type~type_scalar_setting type~type_integer_setting type_integer_setting type~type_integer_setting->type~type_scalar_setting type~type_logical_setting type_logical_setting type~type_logical_setting->type~type_scalar_setting Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables long_name description backing_store_node path parent units has_default Type-Bound Procedures write_schema get_yaml_style create_child as_string write_yaml get_comment get_maximum_depth Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() character(len=:), public, allocatable :: units logical, public :: has_default = .false. Type-Bound Procedures procedure, public :: write_schema => value_write_schema private recursive subroutine value_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent procedure, public :: get_yaml_style => value_get_yaml_style private function value_get_yaml_style (self) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value integer procedure, public :: create_child private recursive function create_child (self) result(child) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value class( type_settings ),\n  pointer procedure( setting_as_string ), public, deferred :: as_string function setting_as_string(self, use_default) result(string) Prototype Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable procedure, public :: write_yaml => setting_write_yaml private recursive subroutine setting_write_yaml (self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header procedure, public :: get_comment => setting_get_comment private recursive subroutine setting_get_comment (self, comment) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self character(len=:), intent(inout), allocatable :: comment procedure, public :: get_maximum_depth => setting_get_maximum_depth private recursive function setting_get_maximum_depth (self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer","tags":"","loc":"type/type_scalar_setting.html"},{"title":"type_option – Fortran Program ","text":"type, public :: type_option Inherited by type~~type_option~~InheritedByGraph type~type_option type_option type~type_integer_setting type_integer_setting type~type_integer_setting->type~type_option options Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables value long_name key Components Type Visibility Attributes Name Initial integer, public :: value character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: key","tags":"","loc":"type/type_option.html"},{"title":"type_list – Fortran Program ","text":"type, private, extends( type_value ) :: type_list Inherits type~~type_list~2~~InheritsGraph type~type_list~2 type_list type~type_list_populator type_list_populator type~type_list~2->type~type_list_populator populator type~type_list_item~2 type_list_item type~type_list~2->type~type_list_item~2 first type~type_value type_value type~type_list~2->type~type_value type~type_list_item~2->type~type_list_item~2 next type~type_settings_node type_settings_node type~type_list_item~2->type~type_settings_node type~type_value->type~type_value parent type_yaml_node type_yaml_node type~type_value->type_yaml_node backing_store_node type~type_settings_node->type~type_value value var pantypetype_list2InheritsGraph = svgPanZoom('#typetype_list2InheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables long_name description backing_store_node path parent first populator Type-Bound Procedures create_child write_schema write_yaml get_maximum_depth get_yaml_style Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() type( type_list_item ), public, pointer :: first => null() class( type_list_populator ), public, pointer :: populator => null() Type-Bound Procedures procedure, public :: create_child private recursive function create_child (self) result(child) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value class( type_settings ),\n  pointer procedure, public :: write_schema => list_write_schema private recursive subroutine list_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent procedure, public :: write_yaml => list_write_yaml private recursive subroutine list_write_yaml (self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header procedure, public :: get_maximum_depth => list_get_maximum_depth private recursive function list_get_maximum_depth (self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer procedure, public :: get_yaml_style => list_get_yaml_style private function list_get_yaml_style (self) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self Return Value integer","tags":"","loc":"type/type_list~2.html"},{"title":"type_integer_setting – Fortran Program ","text":"type, private, extends( type_scalar_setting ) :: type_integer_setting Inherits type~~type_integer_setting~~InheritsGraph type~type_integer_setting type_integer_setting type~type_option type_option type~type_integer_setting->type~type_option options type~type_scalar_setting type_scalar_setting type~type_integer_setting->type~type_scalar_setting type~type_value type_value type~type_scalar_setting->type~type_value type~type_value->type~type_value parent type_yaml_node type_yaml_node type~type_value->type_yaml_node backing_store_node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables long_name description backing_store_node path parent units has_default pvalue value default minimum maximum options Type-Bound Procedures get_yaml_style create_child write_yaml get_maximum_depth as_string write_schema get_comment Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() character(len=:), public, allocatable :: units logical, public :: has_default = .false. integer, public, pointer :: pvalue => null() integer, public :: value integer, public :: default = 0 integer, public :: minimum = default_minimum_integer integer, public :: maximum = default_maximum_integer type( type_option ), public, allocatable :: options (:) Type-Bound Procedures procedure, public :: get_yaml_style => value_get_yaml_style private function value_get_yaml_style (self) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value integer procedure, public :: create_child private recursive function create_child (self) result(child) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value class( type_settings ),\n  pointer procedure, public :: write_yaml => setting_write_yaml private recursive subroutine setting_write_yaml (self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header procedure, public :: get_maximum_depth => setting_get_maximum_depth private recursive function setting_get_maximum_depth (self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer procedure, public :: as_string => integer_as_string private function integer_as_string (self, use_default) result(string) Arguments Type Intent Optional Attributes Name class( type_integer_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable procedure, public :: write_schema => integer_write_schema private recursive subroutine integer_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_integer_setting ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent procedure, public :: get_comment => integer_get_comment private recursive subroutine integer_get_comment (self, comment) Arguments Type Intent Optional Attributes Name class( type_integer_setting ), intent(in) :: self character(len=:), intent(inout), allocatable :: comment","tags":"","loc":"type/type_integer_setting.html"},{"title":"type_real_setting – Fortran Program ","text":"type, public, extends( type_scalar_setting ) :: type_real_setting Inherits type~~type_real_setting~~InheritsGraph type~type_real_setting type_real_setting type~type_scalar_setting type_scalar_setting type~type_real_setting->type~type_scalar_setting type~type_value type_value type~type_scalar_setting->type~type_value type~type_value->type~type_value parent type_yaml_node type_yaml_node type~type_value->type_yaml_node backing_store_node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables long_name description backing_store_node path parent units has_default pvalue default minimum maximum Type-Bound Procedures get_yaml_style create_child write_yaml get_maximum_depth create as_string write_schema get_comment Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() character(len=:), public, allocatable :: units logical, public :: has_default = .false. real(kind=rk), public, pointer :: pvalue => null() real(kind=rk), public :: default = 0.0_rk real(kind=rk), public :: minimum = default_minimum_real real(kind=rk), public :: maximum = default_maximum_real Type-Bound Procedures procedure, public :: get_yaml_style => value_get_yaml_style private function value_get_yaml_style (self) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value integer procedure, public :: create_child private recursive function create_child (self) result(child) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value class( type_settings ),\n  pointer procedure, public :: write_yaml => setting_write_yaml private recursive subroutine setting_write_yaml (self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header procedure, public :: get_maximum_depth => setting_get_maximum_depth private recursive function setting_get_maximum_depth (self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer procedure, public, nopass :: create => type_real_setting_create public function type_real_setting_create (node, target, long_name, units, default, minimum, maximum, description) result(setting) Arguments Type Intent Optional Attributes Name class( type_settings_node ), intent(inout) :: node real(kind=rk), target :: target character(len=*), intent(in) :: long_name character(len=*), intent(in) :: units real(kind=rk), intent(in), optional :: default real(kind=rk), intent(in), optional :: minimum real(kind=rk), intent(in), optional :: maximum character(len=*), intent(in), optional :: description Return Value class( type_real_setting ),\n  pointer procedure, public :: as_string => real_as_string private function real_as_string (self, use_default) result(string) Arguments Type Intent Optional Attributes Name class( type_real_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable procedure, public :: write_schema => real_write_schema private recursive subroutine real_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_real_setting ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent procedure, public :: get_comment => real_get_comment private recursive subroutine real_get_comment (self, comment) Arguments Type Intent Optional Attributes Name class( type_real_setting ), intent(in) :: self character(len=:), intent(inout), allocatable :: comment","tags":"","loc":"type/type_real_setting.html"},{"title":"type_logical_setting – Fortran Program ","text":"type, public, extends( type_scalar_setting ) :: type_logical_setting Inherits type~~type_logical_setting~~InheritsGraph type~type_logical_setting type_logical_setting type~type_scalar_setting type_scalar_setting type~type_logical_setting->type~type_scalar_setting type~type_value type_value type~type_scalar_setting->type~type_value type~type_value->type~type_value parent type_yaml_node type_yaml_node type~type_value->type_yaml_node backing_store_node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables long_name description backing_store_node path parent units has_default pvalue value default Type-Bound Procedures get_yaml_style create_child write_yaml get_comment get_maximum_depth create as_string write_schema Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() character(len=:), public, allocatable :: units logical, public :: has_default = .false. logical, public, pointer :: pvalue => null() logical, public :: value logical, public :: default = .true. Type-Bound Procedures procedure, public :: get_yaml_style => value_get_yaml_style private function value_get_yaml_style (self) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value integer procedure, public :: create_child private recursive function create_child (self) result(child) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value class( type_settings ),\n  pointer procedure, public :: write_yaml => setting_write_yaml private recursive subroutine setting_write_yaml (self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header procedure, public :: get_comment => setting_get_comment private recursive subroutine setting_get_comment (self, comment) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self character(len=:), intent(inout), allocatable :: comment procedure, public :: get_maximum_depth => setting_get_maximum_depth private recursive function setting_get_maximum_depth (self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer procedure, public, nopass :: create => type_logical_setting_create public function type_logical_setting_create (node, target, long_name, default, description, value) result(setting) Arguments Type Intent Optional Attributes Name class( type_settings_node ), intent(inout) :: node logical, target :: target character(len=*), intent(in) :: long_name logical, intent(in), optional :: default character(len=*), intent(in), optional :: description logical, intent(inout), optional :: value Return Value class( type_logical_setting ),\n  pointer procedure, public :: as_string => logical_as_string private function logical_as_string (self, use_default) result(string) Arguments Type Intent Optional Attributes Name class( type_logical_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable procedure, public :: write_schema => logical_write_schema private recursive subroutine logical_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_logical_setting ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent","tags":"","loc":"type/type_logical_setting.html"},{"title":"type_string_setting – Fortran Program ","text":"type, private, extends( type_scalar_setting ) :: type_string_setting Inherits type~~type_string_setting~~InheritsGraph type~type_string_setting type_string_setting type~type_scalar_setting type_scalar_setting type~type_string_setting->type~type_scalar_setting type~type_value type_value type~type_scalar_setting->type~type_value type~type_value->type~type_value parent type_yaml_node type_yaml_node type~type_value->type_yaml_node backing_store_node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables long_name description backing_store_node path parent units has_default pvalue value default Type-Bound Procedures get_yaml_style create_child write_yaml get_comment get_maximum_depth as_string write_schema Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() character(len=:), public, allocatable :: units logical, public :: has_default = .false. character(len=:), public, pointer :: pvalue => null() character(len=:), public, allocatable :: value character(len=:), public, allocatable :: default Type-Bound Procedures procedure, public :: get_yaml_style => value_get_yaml_style private function value_get_yaml_style (self) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value integer procedure, public :: create_child private recursive function create_child (self) result(child) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value class( type_settings ),\n  pointer procedure, public :: write_yaml => setting_write_yaml private recursive subroutine setting_write_yaml (self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header procedure, public :: get_comment => setting_get_comment private recursive subroutine setting_get_comment (self, comment) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self character(len=:), intent(inout), allocatable :: comment procedure, public :: get_maximum_depth => setting_get_maximum_depth private recursive function setting_get_maximum_depth (self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer procedure, public :: as_string => string_as_string private function string_as_string (self, use_default) result(string) Arguments Type Intent Optional Attributes Name class( type_string_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable procedure, public :: write_schema => string_write_schema private recursive subroutine string_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_string_setting ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent","tags":"","loc":"type/type_string_setting.html"},{"title":"node_dump – Fortran Program","text":"abstract interface private subroutine node_dump(self, unit, indent) Arguments Type Intent Optional Attributes Name class( type_node ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent","tags":"","loc":"interface/node_dump.html"},{"title":"setting_as_string – Fortran Program","text":"abstract interface private function setting_as_string(self, use_default) result(string) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/setting_as_string.html"},{"title":"parse – Fortran Program","text":"public function parse(path, unit, error) result(root) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path integer, intent(in) :: unit character(len=error_length), intent(out) :: error Return Value class( type_node ),\n  pointer Calls proc~~parse~~CallsGraph proc~parse parse proc~read_value read_value proc~parse->proc~read_value proc~read_value->proc~read_value proc~read_key_value_pair read_key_value_pair proc~read_value->proc~read_key_value_pair proc~find_mapping_character find_mapping_character proc~read_value->proc~find_mapping_character proc~read_key_value_pair->proc~read_value proc~is_whitespace is_whitespace proc~find_mapping_character->proc~is_whitespace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~parse~~CalledByGraph proc~parse parse program~test_yaml test_yaml program~test_yaml->proc~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/parse.html"},{"title":"read_value – Fortran Program","text":"private recursive function read_value(file) result(node) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: file Return Value class( type_node ),\n  pointer Calls proc~~read_value~~CallsGraph proc~read_value read_value proc~read_value->proc~read_value proc~read_key_value_pair read_key_value_pair proc~read_value->proc~read_key_value_pair proc~find_mapping_character find_mapping_character proc~read_value->proc~find_mapping_character proc~read_key_value_pair->proc~read_value proc~is_whitespace is_whitespace proc~find_mapping_character->proc~is_whitespace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_value~~CalledByGraph proc~read_value read_value proc~read_value->proc~read_value proc~read_key_value_pair read_key_value_pair proc~read_value->proc~read_key_value_pair proc~read_key_value_pair->proc~read_value proc~parse parse proc~parse->proc~read_value program~test_yaml test_yaml program~test_yaml->proc~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_value.html"},{"title":"read_key_value_pair – Fortran Program","text":"private recursive function read_key_value_pair(file, icolon, icolon_stop) result(pair) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: file integer, intent(in) :: icolon integer, intent(in) :: icolon_stop Return Value type( type_key_value_pair ) Calls proc~~read_key_value_pair~~CallsGraph proc~read_key_value_pair read_key_value_pair proc~read_value read_value proc~read_key_value_pair->proc~read_value proc~read_value->proc~read_key_value_pair proc~read_value->proc~read_value proc~find_mapping_character find_mapping_character proc~read_value->proc~find_mapping_character proc~is_whitespace is_whitespace proc~find_mapping_character->proc~is_whitespace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_key_value_pair~~CalledByGraph proc~read_key_value_pair read_key_value_pair proc~read_value read_value proc~read_key_value_pair->proc~read_value proc~read_value->proc~read_key_value_pair proc~read_value->proc~read_value proc~parse parse proc~parse->proc~read_value program~test_yaml test_yaml program~test_yaml->proc~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_key_value_pair.html"},{"title":"is_whitespace – Fortran Program","text":"private function is_whitespace(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value logical Called by proc~~is_whitespace~~CalledByGraph proc~is_whitespace is_whitespace proc~next_line next_line proc~next_line->proc~is_whitespace proc~find_mapping_character find_mapping_character proc~find_mapping_character->proc~is_whitespace proc~read_value read_value proc~read_value->proc~find_mapping_character proc~read_value->proc~read_value proc~read_key_value_pair read_key_value_pair proc~read_value->proc~read_key_value_pair proc~read_key_value_pair->proc~read_value proc~parse parse proc~parse->proc~read_value program~test_yaml test_yaml program~test_yaml->proc~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/is_whitespace.html"},{"title":"next_line – Fortran Program","text":"private subroutine next_line(file) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: file Calls proc~~next_line~~CallsGraph proc~next_line next_line proc~is_whitespace is_whitespace proc~next_line->proc~is_whitespace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/next_line.html"},{"title":"find_mapping_character – Fortran Program","text":"private subroutine find_mapping_character(string, istart, istop) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(out) :: istart integer, intent(out) :: istop Calls proc~~find_mapping_character~~CallsGraph proc~find_mapping_character find_mapping_character proc~is_whitespace is_whitespace proc~find_mapping_character->proc~is_whitespace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~find_mapping_character~~CalledByGraph proc~find_mapping_character find_mapping_character proc~read_value read_value proc~read_value->proc~find_mapping_character proc~read_value->proc~read_value proc~read_key_value_pair read_key_value_pair proc~read_value->proc~read_key_value_pair proc~read_key_value_pair->proc~read_value proc~parse parse proc~parse->proc~read_value program~test_yaml test_yaml program~test_yaml->proc~parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_mapping_character.html"},{"title":"set_error – Fortran Program","text":"private subroutine set_error(file, error) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: file character(len=*), intent(in) :: error Contents None","tags":"","loc":"proc/set_error.html"},{"title":"dictionary_get – Fortran Program","text":"private function dictionary_get(self, key) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key Return Value class( type_node ),\n  pointer Contents None","tags":"","loc":"proc/dictionary_get.html"},{"title":"scalar_to_logical – Fortran Program","text":"private function scalar_to_logical(self, default, success) result(value) Arguments Type Intent Optional Attributes Name class( type_scalar ), intent(in) :: self logical, intent(in) :: default logical, intent(out), optional :: success Return Value logical Contents None","tags":"","loc":"proc/scalar_to_logical.html"},{"title":"scalar_to_integer – Fortran Program","text":"private function scalar_to_integer(self, default, success) result(value) Arguments Type Intent Optional Attributes Name class( type_scalar ), intent(in) :: self integer, intent(in) :: default logical, intent(out), optional :: success Return Value integer Contents None","tags":"","loc":"proc/scalar_to_integer.html"},{"title":"scalar_to_real – Fortran Program","text":"private function scalar_to_real(self, default, success) result(value) Arguments Type Intent Optional Attributes Name class( type_scalar ), intent(in) :: self real(kind=real_kind), intent(in) :: default logical, intent(out), optional :: success Return Value real(kind=real_kind) Contents None","tags":"","loc":"proc/scalar_to_real.html"},{"title":"dictionary_get_scalar – Fortran Program","text":"private function dictionary_get_scalar(self, key, required, error) result(scalar) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key logical, intent(in) :: required type( type_error ), pointer :: error Return Value class( type_scalar ),\n  pointer Contents None","tags":"","loc":"proc/dictionary_get_scalar.html"},{"title":"dictionary_get_dictionary – Fortran Program","text":"private function dictionary_get_dictionary(self, key, required, error) result(dictionary) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key logical, intent(in) :: required type( type_error ), pointer :: error Return Value class( type_dictionary ),\n  pointer Contents None","tags":"","loc":"proc/dictionary_get_dictionary.html"},{"title":"dictionary_get_list – Fortran Program","text":"private function dictionary_get_list(self, key, required, error) result(list) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key logical, intent(in) :: required type( type_error ), pointer :: error Return Value class( type_list ),\n  pointer Contents None","tags":"","loc":"proc/dictionary_get_list.html"},{"title":"dictionary_get_string – Fortran Program","text":"private function dictionary_get_string(self, key, default, error) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key character(len=*), intent(in), optional :: default type( type_error ), pointer :: error Return Value character(len=string_length) Contents None","tags":"","loc":"proc/dictionary_get_string.html"},{"title":"dictionary_get_logical – Fortran Program","text":"private function dictionary_get_logical(self, key, default, error) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key logical, intent(in), optional :: default type( type_error ), pointer :: error Return Value logical Contents None","tags":"","loc":"proc/dictionary_get_logical.html"},{"title":"dictionary_get_integer – Fortran Program","text":"private function dictionary_get_integer(self, key, default, error) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key integer, intent(in), optional :: default type( type_error ), pointer :: error Return Value integer Contents None","tags":"","loc":"proc/dictionary_get_integer.html"},{"title":"dictionary_get_real – Fortran Program","text":"private function dictionary_get_real(self, key, default, error) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key real(kind=real_kind), intent(in), optional :: default type( type_error ), pointer :: error Return Value real(kind=real_kind) Contents None","tags":"","loc":"proc/dictionary_get_real.html"},{"title":"node_finalize – Fortran Program","text":"private subroutine node_finalize(self) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self Contents None","tags":"","loc":"proc/node_finalize.html"},{"title":"dictionary_reset_accessed – Fortran Program","text":"private subroutine dictionary_reset_accessed(self) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self Contents None","tags":"","loc":"proc/dictionary_reset_accessed.html"},{"title":"dictionary_set – Fortran Program","text":"private subroutine dictionary_set(self, key, value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(inout) :: self character(len=*), intent(in) :: key class( type_node ), pointer :: value Contents None","tags":"","loc":"proc/dictionary_set.html"},{"title":"dictionary_set_string – Fortran Program","text":"private subroutine dictionary_set_string(self, key, value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(inout) :: self character(len=*), intent(in) :: key character(len=*), intent(in) :: value Contents None","tags":"","loc":"proc/dictionary_set_string.html"},{"title":"value_dump – Fortran Program","text":"private subroutine value_dump(self, unit, indent) Arguments Type Intent Optional Attributes Name class( type_scalar ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent Contents None","tags":"","loc":"proc/value_dump.html"},{"title":"null_dump – Fortran Program","text":"private subroutine null_dump(self, unit, indent) Arguments Type Intent Optional Attributes Name class( type_null ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent Contents None","tags":"","loc":"proc/null_dump.html"},{"title":"dictionary_dump – Fortran Program","text":"private recursive subroutine dictionary_dump(self, unit, indent) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent Contents None","tags":"","loc":"proc/dictionary_dump.html"},{"title":"dictionary_flatten – Fortran Program","text":"private recursive subroutine dictionary_flatten(self, target, prefix) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self type( type_dictionary ), intent(inout) :: target character(len=*), intent(in) :: prefix Contents None","tags":"","loc":"proc/dictionary_flatten.html"},{"title":"node_set_path – Fortran Program","text":"private recursive subroutine node_set_path(self, path) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self character(len=*), intent(in) :: path Contents None","tags":"","loc":"proc/node_set_path.html"},{"title":"dictionary_set_path – Fortran Program","text":"private recursive subroutine dictionary_set_path(self, path) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(inout) :: self character(len=*), intent(in) :: path Contents None","tags":"","loc":"proc/dictionary_set_path.html"},{"title":"dictionary_finalize – Fortran Program","text":"private subroutine dictionary_finalize(self) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(inout) :: self Contents None","tags":"","loc":"proc/dictionary_finalize.html"},{"title":"list_append – Fortran Program","text":"private subroutine list_append(self, node) Arguments Type Intent Optional Attributes Name class( type_list ), intent(inout) :: self class( type_node ), target :: node Contents None","tags":"","loc":"proc/list_append.html"},{"title":"list_dump – Fortran Program","text":"private recursive subroutine list_dump(self, unit, indent) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent Contents None","tags":"","loc":"proc/list_dump.html"},{"title":"list_set_path – Fortran Program","text":"private recursive subroutine list_set_path(self, path) Arguments Type Intent Optional Attributes Name class( type_list ), intent(inout) :: self character(len=*), intent(in) :: path Contents None","tags":"","loc":"proc/list_set_path.html"},{"title":"value_get_maximum_depth – Fortran Program","text":"private recursive function value_get_maximum_depth(self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer Contents None","tags":"","loc":"proc/value_get_maximum_depth.html"},{"title":"value_get_yaml_style – Fortran Program","text":"private function value_get_yaml_style(self) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/value_get_yaml_style.html"},{"title":"settings_get_yaml_style – Fortran Program","text":"private function settings_get_yaml_style(self) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/settings_get_yaml_style.html"},{"title":"list_get_yaml_style – Fortran Program","text":"private function list_get_yaml_style(self) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/list_get_yaml_style.html"},{"title":"check_all_used – Fortran Program","text":"private function check_all_used(self) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self Return Value logical Contents None","tags":"","loc":"proc/check_all_used.html"},{"title":"get_node – Fortran Program","text":"private recursive function get_node(self, name, treat_as_path, istart) result(pair) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout), target :: self character(len=*), intent(in) :: name logical, intent(in), optional :: treat_as_path integer, intent(out), optional :: istart Return Value type( type_key_value_pair ),\n  pointer Calls proc~~get_node~~CallsGraph proc~get_node get_node proc~get_child get_child proc~get_node->proc~get_child proc~type_settings_create type_settings_create proc~get_child->proc~type_settings_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_node.html"},{"title":"type_real_setting_create – Fortran Program","text":"public function type_real_setting_create(node, target, long_name, units, default, minimum, maximum, description) result(setting) Arguments Type Intent Optional Attributes Name class( type_settings_node ), intent(inout) :: node real(kind=rk), target :: target character(len=*), intent(in) :: long_name character(len=*), intent(in) :: units real(kind=rk), intent(in), optional :: default real(kind=rk), intent(in), optional :: minimum real(kind=rk), intent(in), optional :: maximum character(len=*), intent(in), optional :: description Return Value class( type_real_setting ),\n  pointer Calls proc~~type_real_setting_create~~CallsGraph proc~type_real_setting_create type_real_setting_create proc~report_error report_error proc~type_real_setting_create->proc~report_error proc~real_set_data real_set_data proc~type_real_setting_create->proc~real_set_data proc~real_set_data->proc~report_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~type_real_setting_create~~CalledByGraph proc~type_real_setting_create type_real_setting_create proc~get_real2 get_real2 proc~get_real2->proc~type_real_setting_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/type_real_setting_create.html"},{"title":"get_integer – Fortran Program","text":"private function get_integer(self, name, long_name, units, default, minimum, maximum, options, description) result(value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: units integer, intent(in), optional :: default integer, intent(in), optional :: minimum integer, intent(in), optional :: maximum type( type_option ), intent(in), optional :: options (:) character(len=*), intent(in), optional :: description Return Value integer Calls proc~~get_integer~~CallsGraph proc~get_integer get_integer proc~get_integer2 get_integer2 proc~get_integer->proc~get_integer2 proc~integer_set_data integer_set_data proc~get_integer2->proc~integer_set_data proc~report_error report_error proc~get_integer2->proc~report_error proc~string_lower string_lower proc~get_integer2->proc~string_lower proc~integer_set_data->proc~report_error proc~integer_set_data->proc~string_lower Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_integer.html"},{"title":"get_logical – Fortran Program","text":"private function get_logical(self, name, long_name, default, description) result(value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name logical, intent(in), optional :: default character(len=*), intent(in), optional :: description Return Value logical Calls proc~~get_logical~~CallsGraph proc~get_logical get_logical proc~get_logical2 get_logical2 proc~get_logical->proc~get_logical2 proc~type_logical_setting_create type_logical_setting_create proc~get_logical2->proc~type_logical_setting_create proc~report_error report_error proc~type_logical_setting_create->proc~report_error proc~logical_set_data logical_set_data proc~type_logical_setting_create->proc~logical_set_data proc~logical_set_data->proc~report_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_logical.html"},{"title":"type_logical_setting_create – Fortran Program","text":"public function type_logical_setting_create(node, target, long_name, default, description, value) result(setting) Arguments Type Intent Optional Attributes Name class( type_settings_node ), intent(inout) :: node logical, target :: target character(len=*), intent(in) :: long_name logical, intent(in), optional :: default character(len=*), intent(in), optional :: description logical, intent(inout), optional :: value Return Value class( type_logical_setting ),\n  pointer Calls proc~~type_logical_setting_create~~CallsGraph proc~type_logical_setting_create type_logical_setting_create proc~report_error report_error proc~type_logical_setting_create->proc~report_error proc~logical_set_data logical_set_data proc~type_logical_setting_create->proc~logical_set_data proc~logical_set_data->proc~report_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~type_logical_setting_create~~CalledByGraph proc~type_logical_setting_create type_logical_setting_create proc~get_logical2 get_logical2 proc~get_logical2->proc~type_logical_setting_create proc~get_logical get_logical proc~get_logical->proc~get_logical2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/type_logical_setting_create.html"},{"title":"get_string – Fortran Program","text":"private function get_string(self, name, long_name, units, default, description) result(value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: units character(len=*), intent(in), optional :: default character(len=*), intent(in), optional :: description Return Value character(len=:),\n  allocatable Calls proc~~get_string~~CallsGraph proc~get_string get_string proc~get_string2 get_string2 proc~get_string->proc~get_string2 proc~report_error report_error proc~get_string2->proc~report_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_string.html"},{"title":"create_child – Fortran Program","text":"private recursive function create_child(self) result(child) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value class( type_settings ),\n  pointer Contents None","tags":"","loc":"proc/create_child.html"},{"title":"get_child – Fortran Program","text":"private recursive function get_child(self, name, long_name, treat_as_path, populator) result(child) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout), target :: self character(len=*), intent(in) :: name character(len=*), intent(in), optional :: long_name logical, intent(in), optional :: treat_as_path class( type_dictionary_populator ), optional target :: populator Return Value class( type_settings ),\n  pointer Calls proc~~get_child~~CallsGraph proc~get_child get_child proc~type_settings_create type_settings_create proc~get_child->proc~type_settings_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_child~~CalledByGraph proc~get_child get_child proc~get_node get_node proc~get_node->proc~get_child Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_child.html"},{"title":"type_settings_create – Fortran Program","text":"public function type_settings_create(node, long_name, populator) result(child) Arguments Type Intent Optional Attributes Name class( type_settings_node ), intent(inout), optional :: node character(len=*), intent(in), optional :: long_name class( type_dictionary_populator ), optional target :: populator Return Value class( type_settings ),\n  pointer Called by proc~~type_settings_create~~CalledByGraph proc~type_settings_create type_settings_create proc~get_child get_child proc~get_child->proc~type_settings_create proc~get_node get_node proc~get_node->proc~get_child Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/type_settings_create.html"},{"title":"string_lower – Fortran Program","text":"private function string_lower(string) result(lowerstring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len(string)) Called by proc~~string_lower~~CalledByGraph proc~string_lower string_lower proc~integer_get_comment integer_get_comment proc~integer_get_comment->proc~string_lower proc~integer_set_data integer_set_data proc~integer_set_data->proc~string_lower proc~get_integer2 get_integer2 proc~get_integer2->proc~string_lower proc~get_integer2->proc~integer_set_data proc~get_integer get_integer proc~get_integer->proc~get_integer2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/string_lower.html"},{"title":"setting_get_maximum_depth – Fortran Program","text":"private recursive function setting_get_maximum_depth(self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer Contents None","tags":"","loc":"proc/setting_get_maximum_depth.html"},{"title":"settings_get_maximum_depth – Fortran Program","text":"private recursive function settings_get_maximum_depth(self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer Contents None","tags":"","loc":"proc/settings_get_maximum_depth.html"},{"title":"list_get_maximum_depth – Fortran Program","text":"private recursive function list_get_maximum_depth(self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer Contents None","tags":"","loc":"proc/list_get_maximum_depth.html"},{"title":"real_as_string – Fortran Program","text":"private function real_as_string(self, use_default) result(string) Arguments Type Intent Optional Attributes Name class( type_real_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable Calls proc~~real_as_string~~CallsGraph proc~real_as_string real_as_string proc~format_real format_real proc~real_as_string->proc~format_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/real_as_string.html"},{"title":"format_real – Fortran Program","text":"private function format_real(value) result(string) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: value Return Value character(len=:),\n  allocatable Called by proc~~format_real~~CalledByGraph proc~format_real format_real proc~real_get_comment real_get_comment proc~real_get_comment->proc~format_real proc~real_as_string real_as_string proc~real_as_string->proc~format_real proc~real_write_schema real_write_schema proc~real_write_schema->proc~format_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/format_real.html"},{"title":"format_integer – Fortran Program","text":"private function format_integer(value) result(string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: value Return Value character(len=:),\n  allocatable Called by proc~~format_integer~~CalledByGraph proc~format_integer format_integer proc~integer_as_string integer_as_string proc~integer_as_string->proc~format_integer proc~integer_get_comment integer_get_comment proc~integer_get_comment->proc~format_integer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/format_integer.html"},{"title":"integer_as_string – Fortran Program","text":"private function integer_as_string(self, use_default) result(string) Arguments Type Intent Optional Attributes Name class( type_integer_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable Calls proc~~integer_as_string~~CallsGraph proc~integer_as_string integer_as_string proc~format_integer format_integer proc~integer_as_string->proc~format_integer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/integer_as_string.html"},{"title":"logical_as_string – Fortran Program","text":"private function logical_as_string(self, use_default) result(string) Arguments Type Intent Optional Attributes Name class( type_logical_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/logical_as_string.html"},{"title":"string_as_string – Fortran Program","text":"private function string_as_string(self, use_default) result(string) Arguments Type Intent Optional Attributes Name class( type_string_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/string_as_string.html"},{"title":"value_write_schema – Fortran Program","text":"private recursive subroutine value_write_schema(self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent Contents None","tags":"","loc":"proc/value_write_schema.html"},{"title":"value_write_yaml – Fortran Program","text":"private recursive subroutine value_write_yaml(self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header Contents None","tags":"","loc":"proc/value_write_yaml.html"},{"title":"load – Fortran Program","text":"private subroutine load(self, path, unit) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), intent(in) :: path integer, intent(in) :: unit Calls proc~~load~~CallsGraph proc~load load yaml_parse yaml_parse proc~load->yaml_parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load.html"},{"title":"save – Fortran Program","text":"private subroutine save(self, path, unit) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self character(len=*), intent(in) :: path integer, intent(in) :: unit Contents None","tags":"","loc":"proc/save.html"},{"title":"write_schema_file – Fortran Program","text":"private subroutine write_schema_file(self, path, unit, version) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self character(len=*), intent(in) :: path integer, intent(in) :: unit character(len=*), intent(in) :: version Contents None","tags":"","loc":"proc/write_schema_file.html"},{"title":"get_real2 – Fortran Program","text":"private subroutine get_real2(self, target, name, long_name, units, default, minimum, maximum, description) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self real(kind=rk), target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in) :: units real(kind=rk), intent(in), optional :: default real(kind=rk), intent(in), optional :: minimum real(kind=rk), intent(in), optional :: maximum character(len=*), intent(in), optional :: description Calls proc~~get_real2~~CallsGraph proc~get_real2 get_real2 proc~type_real_setting_create type_real_setting_create proc~get_real2->proc~type_real_setting_create proc~report_error report_error proc~type_real_setting_create->proc~report_error proc~real_set_data real_set_data proc~type_real_setting_create->proc~real_set_data proc~real_set_data->proc~report_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_real2.html"},{"title":"real_set_data – Fortran Program","text":"private subroutine real_set_data(self, backing_store_node) Arguments Type Intent Optional Attributes Name class( type_real_setting ), intent(inout) :: self class(type_yaml_node), intent(in) :: backing_store_node Calls proc~~real_set_data~~CallsGraph proc~real_set_data real_set_data proc~report_error report_error proc~real_set_data->proc~report_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~real_set_data~~CalledByGraph proc~real_set_data real_set_data proc~type_real_setting_create type_real_setting_create proc~type_real_setting_create->proc~real_set_data proc~get_real2 get_real2 proc~get_real2->proc~type_real_setting_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/real_set_data.html"},{"title":"get_integer2 – Fortran Program","text":"private subroutine get_integer2(self, target, name, long_name, units, default, minimum, maximum, options, description, value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self integer, target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: units integer, intent(in), optional :: default integer, intent(in), optional :: minimum integer, intent(in), optional :: maximum type( type_option ), intent(in), optional :: options (:) character(len=*), intent(in), optional :: description integer, intent(out), optional :: value Calls proc~~get_integer2~~CallsGraph proc~get_integer2 get_integer2 proc~integer_set_data integer_set_data proc~get_integer2->proc~integer_set_data proc~report_error report_error proc~get_integer2->proc~report_error proc~string_lower string_lower proc~get_integer2->proc~string_lower proc~integer_set_data->proc~report_error proc~integer_set_data->proc~string_lower Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_integer2~~CalledByGraph proc~get_integer2 get_integer2 proc~get_integer get_integer proc~get_integer->proc~get_integer2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_integer2.html"},{"title":"integer_set_data – Fortran Program","text":"private subroutine integer_set_data(self, backing_store_node) Arguments Type Intent Optional Attributes Name class( type_integer_setting ), intent(inout) :: self class(type_yaml_node), intent(in) :: backing_store_node Calls proc~~integer_set_data~~CallsGraph proc~integer_set_data integer_set_data proc~report_error report_error proc~integer_set_data->proc~report_error proc~string_lower string_lower proc~integer_set_data->proc~string_lower Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~integer_set_data~~CalledByGraph proc~integer_set_data integer_set_data proc~get_integer2 get_integer2 proc~get_integer2->proc~integer_set_data proc~get_integer get_integer proc~get_integer->proc~get_integer2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/integer_set_data.html"},{"title":"get_logical2 – Fortran Program","text":"private subroutine get_logical2(self, target, name, long_name, default, description, value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self logical, target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name logical, intent(in), optional :: default character(len=*), intent(in), optional :: description logical, intent(inout), optional :: value Calls proc~~get_logical2~~CallsGraph proc~get_logical2 get_logical2 proc~type_logical_setting_create type_logical_setting_create proc~get_logical2->proc~type_logical_setting_create proc~report_error report_error proc~type_logical_setting_create->proc~report_error proc~logical_set_data logical_set_data proc~type_logical_setting_create->proc~logical_set_data proc~logical_set_data->proc~report_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_logical2~~CalledByGraph proc~get_logical2 get_logical2 proc~get_logical get_logical proc~get_logical->proc~get_logical2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_logical2.html"},{"title":"logical_set_data – Fortran Program","text":"private subroutine logical_set_data(self, backing_store_node) Arguments Type Intent Optional Attributes Name class( type_logical_setting ), intent(inout) :: self class(type_yaml_node), intent(in) :: backing_store_node Calls proc~~logical_set_data~~CallsGraph proc~logical_set_data logical_set_data proc~report_error report_error proc~logical_set_data->proc~report_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~logical_set_data~~CalledByGraph proc~logical_set_data logical_set_data proc~type_logical_setting_create type_logical_setting_create proc~type_logical_setting_create->proc~logical_set_data proc~get_logical2 get_logical2 proc~get_logical2->proc~type_logical_setting_create proc~get_logical get_logical proc~get_logical->proc~get_logical2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/logical_set_data.html"},{"title":"get_string2 – Fortran Program","text":"private subroutine get_string2(self, target, name, long_name, units, default, description, value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: units character(len=*), intent(in), optional :: default character(len=*), intent(in), optional :: description character(len=:), optional allocatable :: value Calls proc~~get_string2~~CallsGraph proc~get_string2 get_string2 proc~report_error report_error proc~get_string2->proc~report_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_string2~~CalledByGraph proc~get_string2 get_string2 proc~get_string get_string proc~get_string->proc~get_string2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_string2.html"},{"title":"node_set_value – Fortran Program","text":"private subroutine node_set_value(self, value) Arguments Type Intent Optional Attributes Name class( type_settings_node ), intent(inout) :: self class( type_value ), target :: value Contents None","tags":"","loc":"proc/node_set_value.html"},{"title":"settings_populate – Fortran Program","text":"private subroutine settings_populate(self, populator) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout), target :: self class( type_dictionary_populator ), target :: populator Contents None","tags":"","loc":"proc/settings_populate.html"},{"title":"settings_set_data – Fortran Program","text":"private recursive subroutine settings_set_data(self, backing_store_node) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout), target :: self class(type_yaml_node), target :: backing_store_node Calls proc~~settings_set_data~~CallsGraph proc~settings_set_data settings_set_data proc~report_error report_error proc~settings_set_data->proc~report_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/settings_set_data.html"},{"title":"get_list – Fortran Program","text":"private recursive subroutine get_list(self, name, populator, long_name, treat_as_path) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout), target :: self character(len=*), intent(in) :: name class( type_list_populator ), target :: populator character(len=*), intent(in), optional :: long_name logical, intent(in), optional :: treat_as_path Contents None","tags":"","loc":"proc/get_list.html"},{"title":"list_set_data – Fortran Program","text":"private subroutine list_set_data(self, backing_store_node) Arguments Type Intent Optional Attributes Name class( type_list ), intent(inout), target :: self class(type_yaml_node), target :: backing_store_node Calls proc~~list_set_data~~CallsGraph proc~list_set_data list_set_data proc~report_error report_error proc~list_set_data->proc~report_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/list_set_data.html"},{"title":"finalize – Fortran Program","text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self Contents None","tags":"","loc":"proc/finalize.html"},{"title":"report_error – Fortran Program","text":"public subroutine report_error(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Called by proc~~report_error~~CalledByGraph proc~report_error report_error proc~list_set_data list_set_data proc~list_set_data->proc~report_error proc~real_set_data real_set_data proc~real_set_data->proc~report_error proc~type_logical_setting_create type_logical_setting_create proc~type_logical_setting_create->proc~report_error proc~logical_set_data logical_set_data proc~type_logical_setting_create->proc~logical_set_data proc~integer_set_data integer_set_data proc~integer_set_data->proc~report_error proc~get_string2 get_string2 proc~get_string2->proc~report_error proc~type_real_setting_create type_real_setting_create proc~type_real_setting_create->proc~report_error proc~type_real_setting_create->proc~real_set_data proc~get_integer2 get_integer2 proc~get_integer2->proc~report_error proc~get_integer2->proc~integer_set_data proc~settings_set_data settings_set_data proc~settings_set_data->proc~report_error proc~logical_set_data->proc~report_error proc~get_logical2 get_logical2 proc~get_logical2->proc~type_logical_setting_create proc~get_string get_string proc~get_string->proc~get_string2 proc~get_integer get_integer proc~get_integer->proc~get_integer2 proc~get_real2 get_real2 proc~get_real2->proc~type_real_setting_create proc~get_logical get_logical proc~get_logical->proc~get_logical2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/report_error.html"},{"title":"settings_write_yaml – Fortran Program","text":"private recursive subroutine settings_write_yaml(self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header Contents None","tags":"","loc":"proc/settings_write_yaml.html"},{"title":"list_write_yaml – Fortran Program","text":"private recursive subroutine list_write_yaml(self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header Contents None","tags":"","loc":"proc/list_write_yaml.html"},{"title":"setting_write_yaml – Fortran Program","text":"private recursive subroutine setting_write_yaml(self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header Calls proc~~setting_write_yaml~~CallsGraph proc~setting_write_yaml setting_write_yaml proc~append_string append_string proc~setting_write_yaml->proc~append_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setting_write_yaml.html"},{"title":"setting_get_comment – Fortran Program","text":"private recursive subroutine setting_get_comment(self, comment) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self character(len=:), intent(inout), allocatable :: comment Contents None","tags":"","loc":"proc/setting_get_comment.html"},{"title":"real_get_comment – Fortran Program","text":"private recursive subroutine real_get_comment(self, comment) Arguments Type Intent Optional Attributes Name class( type_real_setting ), intent(in) :: self character(len=:), intent(inout), allocatable :: comment Calls proc~~real_get_comment~~CallsGraph proc~real_get_comment real_get_comment proc~format_real format_real proc~real_get_comment->proc~format_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/real_get_comment.html"},{"title":"append_string – Fortran Program","text":"private subroutine append_string(target, infix, string) Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: target character(len=*), intent(in) :: infix character(len=*), intent(in) :: string Called by proc~~append_string~~CalledByGraph proc~append_string append_string proc~integer_get_comment integer_get_comment proc~integer_get_comment->proc~append_string proc~setting_write_yaml setting_write_yaml proc~setting_write_yaml->proc~append_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/append_string.html"},{"title":"integer_get_comment – Fortran Program","text":"private recursive subroutine integer_get_comment(self, comment) Arguments Type Intent Optional Attributes Name class( type_integer_setting ), intent(in) :: self character(len=:), intent(inout), allocatable :: comment Calls proc~~integer_get_comment~~CallsGraph proc~integer_get_comment integer_get_comment proc~format_integer format_integer proc~integer_get_comment->proc~format_integer proc~string_lower string_lower proc~integer_get_comment->proc~string_lower proc~append_string append_string proc~integer_get_comment->proc~append_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/integer_get_comment.html"},{"title":"settings_write_schema – Fortran Program","text":"private recursive subroutine settings_write_schema(self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent Contents None","tags":"","loc":"proc/settings_write_schema.html"},{"title":"list_write_schema – Fortran Program","text":"private recursive subroutine list_write_schema(self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent Contents None","tags":"","loc":"proc/list_write_schema.html"},{"title":"integer_write_schema – Fortran Program","text":"private recursive subroutine integer_write_schema(self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_integer_setting ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent Contents None","tags":"","loc":"proc/integer_write_schema.html"},{"title":"real_write_schema – Fortran Program","text":"private recursive subroutine real_write_schema(self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_real_setting ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent Calls proc~~real_write_schema~~CallsGraph proc~real_write_schema real_write_schema proc~format_real format_real proc~real_write_schema->proc~format_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/real_write_schema.html"},{"title":"logical_write_schema – Fortran Program","text":"private recursive subroutine logical_write_schema(self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_logical_setting ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent Contents None","tags":"","loc":"proc/logical_write_schema.html"},{"title":"string_write_schema – Fortran Program","text":"private recursive subroutine string_write_schema(self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_string_setting ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent Contents None","tags":"","loc":"proc/string_write_schema.html"},{"title":"list_populator_set_length – Fortran Program","text":"private subroutine list_populator_set_length(self, n) Arguments Type Intent Optional Attributes Name class( type_list_populator ), intent(inout) :: self integer, intent(in) :: n Contents None","tags":"","loc":"proc/list_populator_set_length.html"},{"title":"list_populator_create – Fortran Program","text":"interface private recursive subroutine list_populator_create(self, index, item) Arguments Type Intent Optional Attributes Name class( type_list_populator ), intent(inout) :: self integer, intent(in) :: index type( type_list_item ), intent(inout) :: item","tags":"","loc":"interface/list_populator_create.html"},{"title":"dictionary_populator_create – Fortran Program","text":"interface private recursive subroutine dictionary_populator_create(self, pair) Arguments Type Intent Optional Attributes Name class( type_dictionary_populator ), intent(inout) :: self type( type_key_value_pair ), intent(inout) :: pair","tags":"","loc":"interface/dictionary_populator_create.html"},{"title":"yaml – Fortran Program","text":"Uses yaml_types module~~yaml~~UsesGraph module~yaml yaml module~yaml_types yaml_types module~yaml->module~yaml_types Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~yaml~~UsedByGraph module~yaml yaml module~yaml_settings yaml_settings module~yaml_settings->module~yaml program~test_yaml test_yaml program~test_yaml->module~yaml Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables line_length error_length Derived Types type_file Functions parse read_value read_key_value_pair is_whitespace Subroutines next_line find_mapping_character set_error Variables Type Visibility Attributes Name Initial integer, private, parameter :: line_length = 2048 integer, public, parameter :: error_length = 2048 Derived Types type, private :: type_file Components Type Visibility Attributes Name Initial integer, public :: unit = -1 character(len=line_length), public :: line = '' integer, public :: indent = 0 logical, public :: eof = .false. integer, public :: iline = 0 character(len=error_length), public :: error_message = '' logical, public :: has_error = .false. Type-Bound Procedures procedure, public :: next_line procedure, public :: set_error Functions public function parse (path, unit, error) result(root) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path integer, intent(in) :: unit character(len=error_length), intent(out) :: error Return Value class( type_node ),\n  pointer private recursive function read_value (file) result(node) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: file Return Value class( type_node ),\n  pointer private recursive function read_key_value_pair (file, icolon, icolon_stop) result(pair) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: file integer, intent(in) :: icolon integer, intent(in) :: icolon_stop Return Value type( type_key_value_pair ) private function is_whitespace (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value logical Subroutines private subroutine next_line (file) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: file private subroutine find_mapping_character (string, istart, istop) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(out) :: istart integer, intent(out) :: istop private subroutine set_error (file, error) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: file character(len=*), intent(in) :: error","tags":"","loc":"module/yaml.html"},{"title":"yaml_version – Fortran Program","text":"Used by module~~yaml_version~~UsedByGraph module~yaml_version yaml_version program~test_yaml test_yaml program~test_yaml->module~yaml_version Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables git_commit_id git_branch_name Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: git_commit_id = \"@GIT_COMMIT_ID@\" character(len=*), public, parameter :: git_branch_name = \"@GIT_BRANCH_NAME@\"","tags":"","loc":"module/yaml_version.html"},{"title":"yaml_types – Fortran Program","text":"Used by module~~yaml_types~~UsedByGraph module~yaml_types yaml_types module~yaml yaml module~yaml->module~yaml_types module~yaml_settings yaml_settings module~yaml_settings->module~yaml_types module~yaml_settings->module~yaml program~test_yaml test_yaml program~test_yaml->module~yaml_types program~test_yaml->module~yaml Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables string_length real_kind Abstract Interfaces node_dump Derived Types type_node type_scalar type_null type_key_value_pair type_dictionary type_list_item type_list type_error Functions dictionary_get scalar_to_logical scalar_to_integer scalar_to_real dictionary_get_scalar dictionary_get_dictionary dictionary_get_list dictionary_get_string dictionary_get_logical dictionary_get_integer dictionary_get_real Subroutines node_finalize dictionary_reset_accessed dictionary_set dictionary_set_string value_dump null_dump dictionary_dump dictionary_flatten node_set_path dictionary_set_path dictionary_finalize list_append list_dump list_set_path Variables Type Visibility Attributes Name Initial integer, private, parameter :: string_length = 1024 integer, public, parameter :: real_kind = kind(1.0d0) Abstract Interfaces abstract interface private subroutine node_dump(self, unit, indent) Arguments Type Intent Optional Attributes Name class( type_node ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent Derived Types type, public, abstract :: type_node Components Type Visibility Attributes Name Initial character(len=string_length), public :: path = '' Type-Bound Procedures procedure(node_dump), public :: dump procedure, public :: set_path => node_set_path procedure, public :: finalize => node_finalize type, public, extends( type_node ) :: type_scalar Components Type Visibility Attributes Name Initial character(len=string_length), public :: path = '' character(len=string_length), public :: string = '' Type-Bound Procedures procedure, public :: set_path => node_set_path procedure, public :: finalize => node_finalize procedure, public :: dump => value_dump procedure, public :: to_logical => scalar_to_logical procedure, public :: to_integer => scalar_to_integer procedure, public :: to_real => scalar_to_real type, public, extends( type_node ) :: type_null Components Type Visibility Attributes Name Initial character(len=string_length), public :: path = '' Type-Bound Procedures procedure, public :: set_path => node_set_path procedure, public :: finalize => node_finalize procedure, public :: dump => null_dump type, public :: type_key_value_pair Components Type Visibility Attributes Name Initial character(len=string_length), public :: key = '' class( type_node ), public, pointer :: value => null() logical, public :: accessed = .false. type( type_key_value_pair ), public, pointer :: next => null() type, public, extends( type_node ) :: type_dictionary Components Type Visibility Attributes Name Initial character(len=string_length), public :: path = '' type( type_key_value_pair ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: get => dictionary_get procedure, public :: get_scalar => dictionary_get_scalar procedure, public :: get_dictionary => dictionary_get_dictionary procedure, public :: get_list => dictionary_get_list procedure, public :: get_string => dictionary_get_string procedure, public :: get_logical => dictionary_get_logical procedure, public :: get_integer => dictionary_get_integer procedure, public :: get_real => dictionary_get_real procedure, public :: set => dictionary_set procedure, public :: set_string => dictionary_set_string procedure, public :: dump => dictionary_dump procedure, public :: flatten => dictionary_flatten procedure, public :: reset_accessed => dictionary_reset_accessed procedure, public :: set_path => dictionary_set_path procedure, public :: finalize => dictionary_finalize type, public :: type_list_item Components Type Visibility Attributes Name Initial class( type_node ), public, pointer :: node => null() type( type_list_item ), public, pointer :: next => null() type, public, extends( type_node ) :: type_list Components Type Visibility Attributes Name Initial character(len=string_length), public :: path = '' type( type_list_item ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: finalize => node_finalize procedure, public :: append => list_append procedure, public :: dump => list_dump procedure, public :: set_path => list_set_path type, public :: type_error Components Type Visibility Attributes Name Initial character(len=string_length), public :: message Functions private function dictionary_get (self, key) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key Return Value class( type_node ),\n  pointer private function scalar_to_logical (self, default, success) result(value) Arguments Type Intent Optional Attributes Name class( type_scalar ), intent(in) :: self logical, intent(in) :: default logical, intent(out), optional :: success Return Value logical private function scalar_to_integer (self, default, success) result(value) Arguments Type Intent Optional Attributes Name class( type_scalar ), intent(in) :: self integer, intent(in) :: default logical, intent(out), optional :: success Return Value integer private function scalar_to_real (self, default, success) result(value) Arguments Type Intent Optional Attributes Name class( type_scalar ), intent(in) :: self real(kind=real_kind), intent(in) :: default logical, intent(out), optional :: success Return Value real(kind=real_kind) private function dictionary_get_scalar (self, key, required, error) result(scalar) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key logical, intent(in) :: required type( type_error ), pointer :: error Return Value class( type_scalar ),\n  pointer private function dictionary_get_dictionary (self, key, required, error) result(dictionary) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key logical, intent(in) :: required type( type_error ), pointer :: error Return Value class( type_dictionary ),\n  pointer private function dictionary_get_list (self, key, required, error) result(list) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key logical, intent(in) :: required type( type_error ), pointer :: error Return Value class( type_list ),\n  pointer private function dictionary_get_string (self, key, default, error) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key character(len=*), intent(in), optional :: default type( type_error ), pointer :: error Return Value character(len=string_length) private function dictionary_get_logical (self, key, default, error) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key logical, intent(in), optional :: default type( type_error ), pointer :: error Return Value logical private function dictionary_get_integer (self, key, default, error) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key integer, intent(in), optional :: default type( type_error ), pointer :: error Return Value integer private function dictionary_get_real (self, key, default, error) result(value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self character(len=*), intent(in) :: key real(kind=real_kind), intent(in), optional :: default type( type_error ), pointer :: error Return Value real(kind=real_kind) Subroutines private subroutine node_finalize (self) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self private subroutine dictionary_reset_accessed (self) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self private subroutine dictionary_set (self, key, value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(inout) :: self character(len=*), intent(in) :: key class( type_node ), pointer :: value private subroutine dictionary_set_string (self, key, value) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(inout) :: self character(len=*), intent(in) :: key character(len=*), intent(in) :: value private subroutine value_dump (self, unit, indent) Arguments Type Intent Optional Attributes Name class( type_scalar ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent private subroutine null_dump (self, unit, indent) Arguments Type Intent Optional Attributes Name class( type_null ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent private recursive subroutine dictionary_dump (self, unit, indent) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent private recursive subroutine dictionary_flatten (self, target, prefix) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(in) :: self type( type_dictionary ), intent(inout) :: target character(len=*), intent(in) :: prefix private recursive subroutine node_set_path (self, path) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self character(len=*), intent(in) :: path private recursive subroutine dictionary_set_path (self, path) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(inout) :: self character(len=*), intent(in) :: path private subroutine dictionary_finalize (self) Arguments Type Intent Optional Attributes Name class( type_dictionary ), intent(inout) :: self private subroutine list_append (self, node) Arguments Type Intent Optional Attributes Name class( type_list ), intent(inout) :: self class( type_node ), target :: node private recursive subroutine list_dump (self, unit, indent) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent private recursive subroutine list_set_path (self, path) Arguments Type Intent Optional Attributes Name class( type_list ), intent(inout) :: self character(len=*), intent(in) :: path","tags":"","loc":"module/yaml_types.html"},{"title":"yaml_settings – Fortran Program","text":"Uses yaml_types yaml module~~yaml_settings~~UsesGraph module~yaml_settings yaml_settings module~yaml yaml module~yaml_settings->module~yaml module~yaml_types yaml_types module~yaml_settings->module~yaml_types module~yaml->module~yaml_types Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables rk default_minimum_real default_maximum_real default_minimum_integer default_maximum_integer Interfaces list_populator_create dictionary_populator_create Abstract Interfaces setting_as_string Derived Types type_value type_settings_node type_key_value_pair type_list_item type_dictionary_populator type_list_populator type_settings type_scalar_setting type_option type_list type_integer_setting type_real_setting type_logical_setting type_string_setting Functions value_get_maximum_depth value_get_yaml_style settings_get_yaml_style list_get_yaml_style check_all_used get_node type_real_setting_create get_integer get_logical type_logical_setting_create get_string create_child get_child type_settings_create string_lower setting_get_maximum_depth settings_get_maximum_depth list_get_maximum_depth real_as_string format_real format_integer integer_as_string logical_as_string string_as_string Subroutines value_write_schema value_write_yaml load save write_schema_file get_real2 real_set_data get_integer2 integer_set_data get_logical2 logical_set_data get_string2 node_set_value settings_populate settings_set_data get_list list_set_data finalize report_error settings_write_yaml list_write_yaml setting_write_yaml setting_get_comment real_get_comment append_string integer_get_comment settings_write_schema list_write_schema integer_write_schema real_write_schema logical_write_schema string_write_schema list_populator_set_length Variables Type Visibility Attributes Name Initial integer, private, parameter :: rk = yaml_real_kind real(kind=rk), private, parameter :: default_minimum_real = -huge(1._rk) real(kind=rk), private, parameter :: default_maximum_real = huge(1._rk) integer, private, parameter :: default_minimum_integer = -huge(1) integer, private, parameter :: default_maximum_integer = huge(1) Interfaces interface private recursive subroutine list_populator_create(self, index, item) Arguments Type Intent Optional Attributes Name class( type_list_populator ), intent(inout) :: self integer, intent(in) :: index type( type_list_item ), intent(inout) :: item interface private recursive subroutine dictionary_populator_create(self, pair) Arguments Type Intent Optional Attributes Name class( type_dictionary_populator ), intent(inout) :: self type( type_key_value_pair ), intent(inout) :: pair Abstract Interfaces abstract interface private function setting_as_string(self, use_default) result(string) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable Derived Types type, private :: type_value Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() Type-Bound Procedures procedure, public :: write_schema => value_write_schema procedure, public :: write_yaml => value_write_yaml procedure, public :: get_maximum_depth => value_get_maximum_depth procedure, public :: get_yaml_style => value_get_yaml_style procedure, public :: create_child type, public :: type_settings_node Components Type Visibility Attributes Name Initial class( type_value ), public, pointer :: value => null() Type-Bound Procedures procedure, public :: set_value => node_set_value type, public, extends( type_settings_node ) :: type_key_value_pair Components Type Visibility Attributes Name Initial class( type_value ), public, pointer :: value => null() character(len=:), public, allocatable :: key character(len=:), public, allocatable :: name logical, public :: accessed = .false. type( type_key_value_pair ), public, pointer :: next => null() Type-Bound Procedures procedure, public :: set_value => node_set_value type, public, extends( type_settings_node ) :: type_list_item Components Type Visibility Attributes Name Initial class( type_value ), public, pointer :: value => null() type( type_list_item ), public, pointer :: next => null() Type-Bound Procedures procedure, public :: set_value => node_set_value type, public, abstract :: type_dictionary_populator Type-Bound Procedures procedure(dictionary_populator_create), public :: create type, public, abstract :: type_list_populator Type-Bound Procedures procedure, public :: set_length => list_populator_set_length procedure(list_populator_create), public :: create type, public, extends( type_value ) :: type_settings Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() class(type_yaml_dictionary), public, pointer :: backing_store => null() class( type_dictionary_populator ), public, pointer :: populator => null() type( type_key_value_pair ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: create_child procedure, public :: write_schema => settings_write_schema procedure, public :: write_yaml => settings_write_yaml procedure, public :: get_maximum_depth => settings_get_maximum_depth procedure, public :: get_yaml_style => settings_get_yaml_style procedure, public :: load procedure, public :: save procedure, public :: write_schema_file procedure, public :: get_real2 procedure, public :: get_integer2 procedure, public :: get_logical2 procedure, public :: get_string2 procedure, public :: get_integer procedure, public :: get_logical procedure, public :: get_string procedure, public :: get_child procedure, public :: get_list procedure, public :: get_node procedure, public :: check_all_used generic, public :: get => get_real2, get_integer2, get_logical2, get_string2 procedure, public :: populate => settings_populate procedure, public :: finalize type, private, abstract, extends( type_value ) :: type_scalar_setting Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() character(len=:), public, allocatable :: units logical, public :: has_default = .false. Type-Bound Procedures procedure, public :: write_schema => value_write_schema procedure, public :: get_yaml_style => value_get_yaml_style procedure, public :: create_child procedure(setting_as_string), public :: as_string procedure, public :: write_yaml => setting_write_yaml procedure, public :: get_comment => setting_get_comment procedure, public :: get_maximum_depth => setting_get_maximum_depth type, public :: type_option Components Type Visibility Attributes Name Initial integer, public :: value character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: key type, private, extends( type_value ) :: type_list Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() type( type_list_item ), public, pointer :: first => null() class( type_list_populator ), public, pointer :: populator => null() Type-Bound Procedures procedure, public :: create_child procedure, public :: write_schema => list_write_schema procedure, public :: write_yaml => list_write_yaml procedure, public :: get_maximum_depth => list_get_maximum_depth procedure, public :: get_yaml_style => list_get_yaml_style type, private, extends( type_scalar_setting ) :: type_integer_setting Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() character(len=:), public, allocatable :: units logical, public :: has_default = .false. integer, public, pointer :: pvalue => null() integer, public :: value integer, public :: default = 0 integer, public :: minimum = default_minimum_integer integer, public :: maximum = default_maximum_integer type( type_option ), public, allocatable :: options (:) Type-Bound Procedures procedure, public :: get_yaml_style => value_get_yaml_style procedure, public :: create_child procedure, public :: write_yaml => setting_write_yaml procedure, public :: get_maximum_depth => setting_get_maximum_depth procedure, public :: as_string => integer_as_string procedure, public :: write_schema => integer_write_schema procedure, public :: get_comment => integer_get_comment type, public, extends( type_scalar_setting ) :: type_real_setting Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() character(len=:), public, allocatable :: units logical, public :: has_default = .false. real(kind=rk), public, pointer :: pvalue => null() real(kind=rk), public :: default = 0.0_rk real(kind=rk), public :: minimum = default_minimum_real real(kind=rk), public :: maximum = default_maximum_real Type-Bound Procedures procedure, public :: get_yaml_style => value_get_yaml_style procedure, public :: create_child procedure, public :: write_yaml => setting_write_yaml procedure, public :: get_maximum_depth => setting_get_maximum_depth procedure, public, nopass :: create => type_real_setting_create procedure, public :: as_string => real_as_string procedure, public :: write_schema => real_write_schema procedure, public :: get_comment => real_get_comment type, public, extends( type_scalar_setting ) :: type_logical_setting Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() character(len=:), public, allocatable :: units logical, public :: has_default = .false. logical, public, pointer :: pvalue => null() logical, public :: value logical, public :: default = .true. Type-Bound Procedures procedure, public :: get_yaml_style => value_get_yaml_style procedure, public :: create_child procedure, public :: write_yaml => setting_write_yaml procedure, public :: get_comment => setting_get_comment procedure, public :: get_maximum_depth => setting_get_maximum_depth procedure, public, nopass :: create => type_logical_setting_create procedure, public :: as_string => logical_as_string procedure, public :: write_schema => logical_write_schema type, private, extends( type_scalar_setting ) :: type_string_setting Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_name character(len=:), public, allocatable :: description class(type_yaml_node), public, pointer :: backing_store_node => null() character(len=:), public, allocatable :: path class( type_value ), public, pointer :: parent => null() character(len=:), public, allocatable :: units logical, public :: has_default = .false. character(len=:), public, pointer :: pvalue => null() character(len=:), public, allocatable :: value character(len=:), public, allocatable :: default Type-Bound Procedures procedure, public :: get_yaml_style => value_get_yaml_style procedure, public :: create_child procedure, public :: write_yaml => setting_write_yaml procedure, public :: get_comment => setting_get_comment procedure, public :: get_maximum_depth => setting_get_maximum_depth procedure, public :: as_string => string_as_string procedure, public :: write_schema => string_write_schema Functions private recursive function value_get_maximum_depth (self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer private function value_get_yaml_style (self) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value integer private function settings_get_yaml_style (self) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self Return Value integer private function list_get_yaml_style (self) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self Return Value integer private function check_all_used (self) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self Return Value logical private recursive function get_node (self, name, treat_as_path, istart) result(pair) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout), target :: self character(len=*), intent(in) :: name logical, intent(in), optional :: treat_as_path integer, intent(out), optional :: istart Return Value type( type_key_value_pair ),\n  pointer public function type_real_setting_create (node, target, long_name, units, default, minimum, maximum, description) result(setting) Arguments Type Intent Optional Attributes Name class( type_settings_node ), intent(inout) :: node real(kind=rk), target :: target character(len=*), intent(in) :: long_name character(len=*), intent(in) :: units real(kind=rk), intent(in), optional :: default real(kind=rk), intent(in), optional :: minimum real(kind=rk), intent(in), optional :: maximum character(len=*), intent(in), optional :: description Return Value class( type_real_setting ),\n  pointer private function get_integer (self, name, long_name, units, default, minimum, maximum, options, description) result(value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: units integer, intent(in), optional :: default integer, intent(in), optional :: minimum integer, intent(in), optional :: maximum type( type_option ), intent(in), optional :: options (:) character(len=*), intent(in), optional :: description Return Value integer private function get_logical (self, name, long_name, default, description) result(value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name logical, intent(in), optional :: default character(len=*), intent(in), optional :: description Return Value logical public function type_logical_setting_create (node, target, long_name, default, description, value) result(setting) Arguments Type Intent Optional Attributes Name class( type_settings_node ), intent(inout) :: node logical, target :: target character(len=*), intent(in) :: long_name logical, intent(in), optional :: default character(len=*), intent(in), optional :: description logical, intent(inout), optional :: value Return Value class( type_logical_setting ),\n  pointer private function get_string (self, name, long_name, units, default, description) result(value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: units character(len=*), intent(in), optional :: default character(len=*), intent(in), optional :: description Return Value character(len=:),\n  allocatable private recursive function create_child (self) result(child) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self Return Value class( type_settings ),\n  pointer private recursive function get_child (self, name, long_name, treat_as_path, populator) result(child) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout), target :: self character(len=*), intent(in) :: name character(len=*), intent(in), optional :: long_name logical, intent(in), optional :: treat_as_path class( type_dictionary_populator ), optional target :: populator Return Value class( type_settings ),\n  pointer public function type_settings_create (node, long_name, populator) result(child) Arguments Type Intent Optional Attributes Name class( type_settings_node ), intent(inout), optional :: node character(len=*), intent(in), optional :: long_name class( type_dictionary_populator ), optional target :: populator Return Value class( type_settings ),\n  pointer private function string_lower (string) result(lowerstring) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len(string)) private recursive function setting_get_maximum_depth (self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer private recursive function settings_get_maximum_depth (self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer private recursive function list_get_maximum_depth (self, name) result(maxdepth) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self character(len=*), intent(in) :: name Return Value integer private function real_as_string (self, use_default) result(string) Arguments Type Intent Optional Attributes Name class( type_real_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable private function format_real (value) result(string) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: value Return Value character(len=:),\n  allocatable private function format_integer (value) result(string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: value Return Value character(len=:),\n  allocatable private function integer_as_string (self, use_default) result(string) Arguments Type Intent Optional Attributes Name class( type_integer_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable private function logical_as_string (self, use_default) result(string) Arguments Type Intent Optional Attributes Name class( type_logical_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable private function string_as_string (self, use_default) result(string) Arguments Type Intent Optional Attributes Name class( type_string_setting ), intent(in) :: self logical, intent(in) :: use_default Return Value character(len=:),\n  allocatable Subroutines private recursive subroutine value_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent private recursive subroutine value_write_yaml (self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_value ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header private subroutine load (self, path, unit) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), intent(in) :: path integer, intent(in) :: unit private subroutine save (self, path, unit) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self character(len=*), intent(in) :: path integer, intent(in) :: unit private subroutine write_schema_file (self, path, unit, version) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self character(len=*), intent(in) :: path integer, intent(in) :: unit character(len=*), intent(in) :: version private subroutine get_real2 (self, target, name, long_name, units, default, minimum, maximum, description) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self real(kind=rk), target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in) :: units real(kind=rk), intent(in), optional :: default real(kind=rk), intent(in), optional :: minimum real(kind=rk), intent(in), optional :: maximum character(len=*), intent(in), optional :: description private subroutine real_set_data (self, backing_store_node) Arguments Type Intent Optional Attributes Name class( type_real_setting ), intent(inout) :: self class(type_yaml_node), intent(in) :: backing_store_node private subroutine get_integer2 (self, target, name, long_name, units, default, minimum, maximum, options, description, value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self integer, target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: units integer, intent(in), optional :: default integer, intent(in), optional :: minimum integer, intent(in), optional :: maximum type( type_option ), intent(in), optional :: options (:) character(len=*), intent(in), optional :: description integer, intent(out), optional :: value private subroutine integer_set_data (self, backing_store_node) Arguments Type Intent Optional Attributes Name class( type_integer_setting ), intent(inout) :: self class(type_yaml_node), intent(in) :: backing_store_node private subroutine get_logical2 (self, target, name, long_name, default, description, value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self logical, target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name logical, intent(in), optional :: default character(len=*), intent(in), optional :: description logical, intent(inout), optional :: value private subroutine logical_set_data (self, backing_store_node) Arguments Type Intent Optional Attributes Name class( type_logical_setting ), intent(inout) :: self class(type_yaml_node), intent(in) :: backing_store_node private subroutine get_string2 (self, target, name, long_name, units, default, description, value) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self character(len=*), target :: target character(len=*), intent(in) :: name character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: units character(len=*), intent(in), optional :: default character(len=*), intent(in), optional :: description character(len=:), optional allocatable :: value private subroutine node_set_value (self, value) Arguments Type Intent Optional Attributes Name class( type_settings_node ), intent(inout) :: self class( type_value ), target :: value private subroutine settings_populate (self, populator) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout), target :: self class( type_dictionary_populator ), target :: populator private recursive subroutine settings_set_data (self, backing_store_node) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout), target :: self class(type_yaml_node), target :: backing_store_node private recursive subroutine get_list (self, name, populator, long_name, treat_as_path) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout), target :: self character(len=*), intent(in) :: name class( type_list_populator ), target :: populator character(len=*), intent(in), optional :: long_name logical, intent(in), optional :: treat_as_path private subroutine list_set_data (self, backing_store_node) Arguments Type Intent Optional Attributes Name class( type_list ), intent(inout), target :: self class(type_yaml_node), target :: backing_store_node private subroutine finalize (self) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(inout) :: self public subroutine report_error (message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message private recursive subroutine settings_write_yaml (self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header private recursive subroutine list_write_yaml (self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header private recursive subroutine setting_write_yaml (self, unit, indent, comment_depth, header) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self integer, intent(in) :: unit integer, intent(in) :: indent integer, intent(in) :: comment_depth logical, intent(in) :: header private recursive subroutine setting_get_comment (self, comment) Arguments Type Intent Optional Attributes Name class( type_scalar_setting ), intent(in) :: self character(len=:), intent(inout), allocatable :: comment private recursive subroutine real_get_comment (self, comment) Arguments Type Intent Optional Attributes Name class( type_real_setting ), intent(in) :: self character(len=:), intent(inout), allocatable :: comment private subroutine append_string (target, infix, string) Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: target character(len=*), intent(in) :: infix character(len=*), intent(in) :: string private recursive subroutine integer_get_comment (self, comment) Arguments Type Intent Optional Attributes Name class( type_integer_setting ), intent(in) :: self character(len=:), intent(inout), allocatable :: comment private recursive subroutine settings_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_settings ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent private recursive subroutine list_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_list ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent private recursive subroutine integer_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_integer_setting ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent private recursive subroutine real_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_real_setting ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent private recursive subroutine logical_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_logical_setting ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent private recursive subroutine string_write_schema (self, unit, name, indent) Arguments Type Intent Optional Attributes Name class( type_string_setting ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: name integer, intent(in) :: indent private subroutine list_populator_set_length (self, n) Arguments Type Intent Optional Attributes Name class( type_list_populator ), intent(inout) :: self integer, intent(in) :: n","tags":"","loc":"module/yaml_settings.html"},{"title":"test_yaml – Fortran Program","text":"Uses yaml_version yaml_types yaml iso_fortran_env program~~test_yaml~~UsesGraph program~test_yaml test_yaml module~yaml yaml program~test_yaml->module~yaml module~yaml_types yaml_types program~test_yaml->module~yaml_types module~yaml_version yaml_version program~test_yaml->module~yaml_version iso_fortran_env iso_fortran_env program~test_yaml->iso_fortran_env module~yaml->module~yaml_types Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~test_yaml~~CallsGraph program~test_yaml test_yaml proc~parse parse program~test_yaml->proc~parse proc~read_value read_value proc~parse->proc~read_value proc~read_value->proc~read_value proc~read_key_value_pair read_key_value_pair proc~read_value->proc~read_key_value_pair proc~find_mapping_character find_mapping_character proc~read_value->proc~find_mapping_character proc~read_key_value_pair->proc~read_value proc~is_whitespace is_whitespace proc~find_mapping_character->proc~is_whitespace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables error path root Variables Type Attributes Name Initial character(len=error_length) :: error character(len=256) :: path class( type_node ), pointer :: root","tags":"","loc":"program/test_yaml.html"}]}