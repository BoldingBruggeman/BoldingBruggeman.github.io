var tipuesearch = {"pages":[{"title":" STIM ","text":"STIM Developer Info Karsten Bolding","tags":"home","loc":"index.html"},{"title":"gotm_stim.F90 – STIM","text":"This file depends on sourcefile~~gotm_stim.f90~~EfferentGraph sourcefile~gotm_stim.f90 gotm_stim.F90 sourcefile~stim_models.f90 stim_models.F90 sourcefile~gotm_stim.f90->sourcefile~stim_models.f90 sourcefile~stim_variables.f90 stim_variables.F90 sourcefile~stim_models.f90->sourcefile~stim_variables.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ice Source Code gotm_stim.F90 Source Code #include\"cppdefs.h\" MODULE ice !! This module provides the GOTM interface to STIM !! !! author: Karsten Bolding use stim_models IMPLICIT NONE private public init_ice , post_init_ice , do_ice , clean_ice integer , public :: ice_cover = 0 interface init_ice module procedure init_stim_yaml end interface interface post_init_ice module procedure post_init_stim end interface interface do_ice module procedure do_stim end interface interface clean_ice module procedure clean_stim end interface integer , public :: ice_model !! select ice model to apply ! ! !PRIVATE DATA MEMBERS: ENUM , BIND ( C ) ENUMERATOR :: SIMPLE = 0 ENUMERATOR :: BASAL_MELT = 1 ENUMERATOR :: LEBEDEV = 2 ENUMERATOR :: MYLAKE = 3 ENUMERATOR :: WINTON = 4 END ENUM !----------------------------------------------------------------------- contains !----------------------------------------------------------------------- SUBROUTINE init_stim_yaml () !! Initialize configuration via entries in a YAML-file !! Using the GOTM settings module use settings IMPLICIT NONE class ( type_gotm_settings ), pointer :: branch !! GOTM settings variable !----------------------------------------------------------------------- LEVEL1 'init_stim_yaml' ice_model = 0 branch => settings_store % get_typed_child ( 'surface/ice' ) call branch % get ( ice_model , 'model' , 'model' , default = 0 , & options = & ( / option ( 0 , 'none' ), & option ( 1 , 'Lebedev (1938)' ), & option ( 2 , 'MyLake' ), & option ( 3 , 'Winton' ), & option ( 4 , 'Basal_Melt' ) / )) call branch % get ( Hice , 'H' , 'initial ice thickness' , 'm' , default = 0._rk ) call branch % get ( ocean_ice_flux , 'ocean_ice_flux' , & 'ocean->ice heat flux' , 'W/m&#94;2' , default = 0._rk , display = display_hidden ) LEVEL2 'done.' allocate ( Tice ( 2 )) END SUBROUTINE init_stim_yaml !----------------------------------------------------------------------- SUBROUTINE post_init_stim ( Ta , S ) IMPLICIT NONE REALTYPE , intent ( in ) :: Ta !! Air temperature [C] REALTYPE , intent ( in ) :: S !! Salinity [g/kg] !----------------------------------------------------------------------- LEVEL1 'post_init_stim()' if ( Hice . gt . _ ZERO_ . and . ice_model /= 0 ) then ice_cover = 2 end if Tf = - 0.0575_rk * S select case ( ice_model ) case ( 0 ) LEVEL1 'no ice' #ifdef STIM_LEBEDEV case ( 1 ) call init_stim_lebedev ( ice_cover ) #endif #ifdef STIM_MYLAKE case ( 2 ) call init_stim_mylake () #endif #ifdef STIM_WINTON case ( 3 ) #if 1 !KB         allocate(Tice(2)) call init_stim_winton ( Ta ) #else LEVEL0 \"Winton model is compiled - but execution is disabled\" LEVEL0 \"change line 138 in gotm_stim.F90 - then recompile - \" LEVEL0 \"then do some work to make the Winton ice model work ....\" LEVEL0 \".... in STIM\" stop 'post_init_stim(): init_stim_winton()' #endif #endif #ifdef STIM_BASAL_MELT case ( 4 ) !KB         call init_stim_basal_melt() #endif case default stop 'invalid ice model' end select call init_stim_variables ( ice_model ) LEVEL2 'done.' END SUBROUTINE post_init_stim !----------------------------------------------------------------------- SUBROUTINE do_stim ( dz , dt , ustar , Tw , S , Ta , precip , Qsw , Qfluxes ) IMPLICIT NONE ! !! Arguments REALTYPE , intent ( inout ) :: dz !! layer thickness [m] REALTYPE , intent ( inout ) :: dt !! time step [s] REALTYPE , intent ( inout ) :: ustar !! surface friction velocity [m/s] REALTYPE , intent ( inout ) :: Tw !! water temperature [C] REALTYPE , intent ( inout ) :: Ta !! air temperature [C] REALTYPE , intent ( inout ) :: S !! salinity [g/kg] REALTYPE , intent ( inout ) :: precip !! precipitation [mm?] REALTYPE , intent ( inout ) :: Qsw !! short wave radiation [W/m&#94;2] REALTYPE , intent ( inout ) :: Tw ! interface SUBROUTINE Qfluxes ( T , qh , qe , qb ) REALTYPE , intent ( in ) :: T !! temperature [C] REALTYPE , intent ( out ) :: qh !! latent heat [W/m&#94;2] REALTYPE , intent ( out ) :: qe !! sensible heat [W/m&#94;2] REALTYPE , intent ( out ) :: qb !! net longwave radiation [W/m&#94;2] END SUBROUTINE END interface REALTYPE :: Tf !----------------------------------------------------------------------- select case ( ice_model ) case ( 0 ) Tf = - 0.0575 * S if ( Tw . lt . Tf ) then Tw = Tf Hice = 0.1 else Hice = _ ZERO_ end if #ifdef STIM_LEBEDEV case ( 1 ) call do_stim_lebedev ( ice_cover , dt , Tw , S , Ta , precip ) #endif #ifdef STIM_MYLAKE case ( 2 ) call do_stim_mylake ( ice_cover , dz , dt , Tw , S , Ta , precip , Qsw , Qfluxes ) #endif #ifdef STIM_WINTON case ( 3 ) if ( S . lt . 0.01 ) then LEVEL0 'The Winton ice model is developed for oceanic conditions.' LEVEL0 'Very low salinity is not supported - and the principle' LEVEL0 'advantage of the model (brine contribution to latent' LEVEL0 'heat calculation) is not met.' LEVEL0 'Please select another ice model.' stop 'do_stim()' else call do_stim_winton ( ice_cover , dz , dt , Tw , S , Ta , precip , Qsw , Qfluxes ) end if #endif #ifdef STIM_BASAL_MELT case ( 4 ) call do_stim_basal_melt ( dz , ustar , Tw , S ) #endif case default stop 'invalid ice model' end select END SUBROUTINE do_stim !----------------------------------------------------------------------- SUBROUTINE clean_stim () !!  De-allocates all memory allocated via init\\_ice() IMPLICIT NONE !----------------------------------------------------------------------- LEVEL1 'clean_ice' LEVEL2 'de-allocation ice memory ...' LEVEL2 'done.' END SUBROUTINE clean_stim !EOC !----------------------------------------------------------------------- END MODULE ice !----------------------------------------------------------------------- ! Copyright by the STIM-team under the GNU Public License - www.gnu.org !-----------------------------------------------------------------------","tags":"","loc":"sourcefile/gotm_stim.f90.html"},{"title":"stim_variables.F90 – STIM","text":"Files dependent on this one sourcefile~~stim_variables.f90~~AfferentGraph sourcefile~stim_variables.f90 stim_variables.F90 sourcefile~stim_mylake.f90 stim_mylake.F90 sourcefile~stim_mylake.f90->sourcefile~stim_variables.f90 sourcefile~stim_obsice.f90 stim_obsice.F90 sourcefile~stim_obsice.f90->sourcefile~stim_variables.f90 sourcefile~stim_models.f90 stim_models.F90 sourcefile~stim_models.f90->sourcefile~stim_variables.f90 sourcefile~stim_lebedev.f90 stim_lebedev.F90 sourcefile~stim_lebedev.f90->sourcefile~stim_variables.f90 sourcefile~stim_winton.f90 stim_winton.F90 sourcefile~stim_winton.f90->sourcefile~stim_variables.f90 sourcefile~stim_basal_melt.f90 stim_basal_melt.F90 sourcefile~stim_basal_melt.f90->sourcefile~stim_variables.f90 sourcefile~gotm_stim.f90 gotm_stim.F90 sourcefile~gotm_stim.f90->sourcefile~stim_models.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules stim_variables Source Code stim_variables.F90 Source Code !----------------------------------------------------------------------- !BOP ! ! !MODULE: stim_variables - global variables for the ice models ! ! !INTERFACE: module stim_variables ! ! !DESCRIPTION: ! ! !USES: IMPLICIT NONE ! ! !PUBLIC DATA MEMBERS: integer , parameter , public :: rk = kind ( 1.d0 ) real ( rk ), public :: ice_cord = 1._rk real ( rk ), public :: Cw = 4.18e+6_rk !! volumetric heat capacity of water (J K-1 m-3) real ( rk ), public :: L_ice = 33350 0._rk !! latent heat of freezing (J kg-1) real ( rk ), public :: K_ice = 2.1_rk !! ice heat conduction coefficient (W m-1 K-1) real ( rk ), public :: lambda_ice = 5._rk ! real ( rk ), public :: rho_ice = 91 0._rk !! kg m-3 real ( rk ), public :: init_ice_energy = 0._rk ! real ( rk ), target , public :: surface_ice_energy = 0._rk ! real ( rk ), target , public :: bottom_ice_energy = 0._rk ! real ( rk ), target , public :: Tf = 0._rk !! freezing temperature real ( rk ), target , public :: Tice_surface = 0._rk real ( rk ), allocatable , target , public :: Tice (:) real ( rk ), target , public :: Hfrazil = 0._rk !! Total frazil ice thickness real ( rk ), target , public :: Hsnow = 0._rk !! Total snow thickness real ( rk ), target , public :: Hice = 0._rk !! Total ice thickness real ( rk ), target , public :: dHis = 0._rk !! surface ice growth real ( rk ), target , public :: dHib = 0._rk !! bottom ice growth real ( rk ), target , public :: albedo_ice = 0._rk real ( rk ), target , public :: attenuation_ice = 0._rk real ( rk ), target , public :: melt_rate = 0._rk !! ice melt rate [m/y] !KB why????? real ( rk ), target , public :: T_melt = 0._rk !! melt layer temperature real ( rk ), target , public :: S_melt = 0._rk !! melt layer salinity real ( rk ), target , public :: ocean_ice_flux = 0._rk real ( rk ), target , public :: ocean_ice_heat_flux = 0._rk !! upward heat flux [W/m2] real ( rk ), target , public :: ocean_ice_salt_flux = 0._rk !! upward salinity flux [(m/s)*(g/kg)] real ( rk ), target , public :: transmissivity = 1._rk real ( rk ), target , public :: z0i = 0.01_rk ! Lebedev real ( rk ), target , public :: fdd ! ! !REVISION HISTORY: !  Original author(s): Karsten Bolding ! !EOP !----------------------------------------------------------------------- contains !----------------------------------------------------------------------- !BOP ! ! !IROUTINE: init_stim_variables - initialise 2D related stuff. ! ! !INTERFACE: subroutine init_stim_variables ( ice_model ) IMPLICIT NONE ! ! !DESCRIPTION: ! ! !INPUT PARAMETERS: integer , intent ( in ) :: ice_model ! !EOP !------------------------------------------------------------------------- !BOC #ifdef DEBUG integer , save :: Ncall = 0 Ncall = Ncall + 1 write ( debug , * ) 'init_stim_variables() # ' , Ncall #endif !LEVEL2 'init_stim_variables' !LEVEL3 'using ice model ',ice_model #ifdef DEBUG write ( debug , * ) 'Leaving init_stim_variables()' write ( debug , * ) #endif return end subroutine init_stim_variables !EOC !----------------------------------------------------------------------- !BOP ! ! !IROUTINE: clean_stim_variables - cleanup after ! ! !INTERFACE: subroutine clean_stim_variables () IMPLICIT NONE ! ! !DESCRIPTION: !  This routine is currently empty. ! ! !LOCAL VARIABLES: ! !EOP !----------------------------------------------------------------------- !BOC return end subroutine clean_stim_variables !EOC !----------------------------------------------------------------------- end module stim_variables !----------------------------------------------------------------------- ! Copyright (C) 2019 - Karsten Bolding (BB)                            ! !-----------------------------------------------------------------------","tags":"","loc":"sourcefile/stim_variables.f90.html"},{"title":"stim_models.F90 – STIM","text":"This file depends on sourcefile~~stim_models.f90~~EfferentGraph sourcefile~stim_models.f90 stim_models.F90 sourcefile~stim_variables.f90 stim_variables.F90 sourcefile~stim_models.f90->sourcefile~stim_variables.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~stim_models.f90~~AfferentGraph sourcefile~stim_models.f90 stim_models.F90 sourcefile~gotm_stim.f90 gotm_stim.F90 sourcefile~gotm_stim.f90->sourcefile~stim_models.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules stim_models Source Code stim_models.F90 Source Code module stim_models !! Collection of the various ice models in STIM !! !! Author: Karsten Bolding use stim_variables #if 0 #ifdef STIM_OBSICE use stim_obsice , only : init_stim_obsice , do_stim_obsice #endif #endif #ifdef STIM_BASAL_MELT use stim_basal_melt , only : init_stim_basal_melt , do_stim_basal_melt , clean_stim_basal_melt #endif #ifdef STIM_LEBEDEV use stim_lebedev , only : init_stim_lebedev , do_stim_lebedev , clean_stim_lebedev #endif #ifdef STIM_MYLAKE use stim_mylake , only : init_stim_mylake , do_stim_mylake , clean_stim_mylake #endif #ifdef STIM_WINTON use stim_winton , only : init_stim_winton , do_stim_winton #endif IMPLICIT NONE public !----------------------------------------------------------------------- end module stim_models !----------------------------------------------------------------------- ! Copyright by the STIM-team under the GNU Public License - www.gnu.org !-----------------------------------------------------------------------","tags":"","loc":"sourcefile/stim_models.f90.html"},{"title":"ice_flato.F90 – STIM","text":"Contents Source Code ice_flato.F90 Source Code","tags":"","loc":"sourcefile/ice_flato.f90.html"},{"title":"stim_mylake.F90 – STIM","text":"This file depends on sourcefile~~stim_mylake.f90~~EfferentGraph sourcefile~stim_mylake.f90 stim_mylake.F90 sourcefile~stim_variables.f90 stim_variables.F90 sourcefile~stim_mylake.f90->sourcefile~stim_variables.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules stim_mylake Source Code stim_mylake.F90 Source Code !> The MyLAKE ice model !> !> authors: Karsten Bolding (after ?? and ??) MODULE stim_mylake use stim_variables , only : rk use stim_variables , only : albedo_ice , attenuation_ice use stim_variables , only : Cw , K_ice , L_ice , rho_ice use stim_variables , only : Tf , Tice_surface use stim_variables , only : Hice , Hfrazil , dHis , dHib use stim_variables , only : transmissivity use stim_variables , only : surface_ice_energy , bottom_ice_energy use stim_variables , only : ocean_ice_flux IMPLICIT NONE private public init_stim_mylake , do_stim_mylake , clean_stim_mylake real ( rk ), pointer :: Tice real ( rk ), pointer :: ice_energy !----------------------------------------------------------------------- contains !----------------------------------------------------------------------- SUBROUTINE init_stim_mylake () !----------------------------------------------------------------------- Tice => Tice_surface ice_energy => bottom_ice_energy !KB   albedo => albedo_ice !KB   attenuation => attenuation_ice ! https://github.com/biogeochemistry/MyLake_public/blob/master/v12/v12_1/VAN_para_v12_1b.xls ! Phys_par(13) = lambda_i=5 attenuation_ice = 0.7_rk attenuation_ice = 5.0_rk transmissivity = exp ( - Hice * attenuation_ice ) END SUBROUTINE init_stim_mylake !----------------------------------------------------------------------- SUBROUTINE do_stim_mylake ( ice_cover , dz , dt , Tw , S , Ta , precip , Qsw , Qfluxes ) real ( rk ), intent ( in ) :: dz , dt , Ta , S , precip , Qsw integer , intent ( inout ) :: ice_cover real ( rk ), intent ( inout ) :: Tw interface SUBROUTINE Qfluxes ( T , qh , qe , qb ) integer , parameter :: rk = kind ( 1.d0 ) real ( rk ), intent ( in ) :: T real ( rk ), intent ( out ) :: qh , qe , qb END SUBROUTINE end interface real ( rk ) :: max_frazil = 0.03_rk real ( rk ) :: alpha real ( rk ) :: qh , qe , qb , Qflux !----------------------------------------------------------------------- Tf = - 0.0575 * S ice_energy = ( Tw - Tf ) * dz * Cw + ocean_ice_flux * dt !   dHib = (-ice_energy+sensible_ice_water)/(rho_ice*L_ice) dHis = 0._rk dHib = ( - ice_energy ) / ( rho_ice * L_ice ) if ( ice_cover . eq . 0 ) then ! No ice if ( dHib . gt . 0._rk ) then Hfrazil = Hfrazil + dHib + dt * precip end if if ( Hfrazil . ge . max_frazil ) then !initial freezing when frazil ice is above threshold value ice_cover = 2 Hice = Hfrazil Hfrazil = 0._rk end if if ( Hfrazil . lt . 0. ) then ! excess of melting energy returned to water temp Tw = - Hfrazil * rho_ice * L_ice / ( dz * Cw ) + Tf Hfrazil = 0._rk end if else ! Ice-cover - frazil or solid Tw = Tf ! surface of ice if ( Ta . lt . Tf ) then ! top ice growth when air temperature is below freezing pt dHis = Hice alpha = 1._rk / ( 1 0. * Hice ) Tice = ( alpha * Tf + Ta ) / ( 1._rk + alpha ) ! mylake - but why? Hice = sqrt ( Hice ** 2 + 2._rk * K_ice / ( rho_ice * L_ice ) * dt * ( Tf - Tice )) !Stefan's law dHis = Hice - dHis else Tice = Tf ! top ice melting due to solar radiation and heat fluxes Tice = 0._rk ! top ice melting due to solar radiation and heat fluxes call Qfluxes ( Tice , qh , qe , qb ) Qflux = qh + qe + qb dHis = - dt * ( Qsw + Qflux ) / ( rho_ice * L_ice ) Hice = Hice + min ( 0._rk , dHis ) end if Hice = Hice + dt * precip ! bottom of ice - melting or freezing depending in flux direction Hice = Hice + dHib if ( Hice . le . 0. ) then ! excess of melting energy returned to water temp Tw = - Hice * rho_ice * L_ice / ( dz * Cw ) + Tf ice_cover = 0 ! no ice Hice = 0._rk attenuation_ice = 0._rk transmissivity = 1._rk else albedo_ice = 0.3 transmissivity = exp ( - Hice * attenuation_ice ) end if end if END SUBROUTINE do_stim_mylake !----------------------------------------------------------------------- ! !INTERFACE: SUBROUTINE clean_stim_mylake () !----------------------------------------------------------------------- !BOC LEVEL2 'clean_stim_mylake' END SUBROUTINE clean_stim_mylake !----------------------------------------------------------------------- END MODULE stim_mylake !----------------------------------------------------------------------- ! Copyright by the STIM-team under the GNU Public License - www.gnu.org !-----------------------------------------------------------------------","tags":"","loc":"sourcefile/stim_mylake.f90.html"},{"title":"ice_thm.F90 – STIM","text":"Files dependent on this one sourcefile~~ice_thm.f90~~AfferentGraph sourcefile~ice_thm.f90 ice_thm.F90 sourcefile~stim_winton.f90 stim_winton.F90 sourcefile~stim_winton.f90->sourcefile~ice_thm.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ice_thm_mod Source Code ice_thm.F90 Source Code !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! !                                                                              ! !                       THREE-LAYER VERTICAL THERMODYNAMICS                    ! !                                                                              ! ! Reference:  M. Winton, 2000: \"A reformulated three-layer sea ice model\",     ! !            Journal of Atmospheric and Oceanic Technology, 17, 525-531.       ! !                                                                              ! !                                                                              ! !        -> +---------+ <- ts - diagnostic surface temperature ( <= 0C )       ! !       /   |         |                                                        ! !     hs    |  snow   | <- 0-heat capacity snow layer                          ! !       \\   |         |                                                        ! !        => +---------+                                                        ! !       /   |         |                                                        ! !      /    |         | <- t1 - upper 1/2 ice temperature; this layer has      ! !     /     |         |         a variable (T/S dependent) heat capacity       ! !   hi      |...ice...|                                                        ! !     \\     |         |                                                        ! !      \\    |         | <- t2 - lower 1/2 ice temp. (fixed heat capacity)      ! !       \\   |         |                                                        ! !        -> +---------+ <- base of ice fixed at seawater freezing temp.        ! !                                                                              ! !                                         Mike Winton (Michael.Winton)! !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! ! TK mod:  SLAB_ICE treatment modified to follow supersource !          (after Bryan 1969).  The conductive heat !           flux from ice to atmosphere is computed based on !           an effective ice thickness which ensures a minimum !           thickness of 1.7cm for the calculation. module ice_thm_mod #if 0 use constants_mod , only : LI => hlf ! latent heat of fusion - 334e3 J/(kg-ice) #endif implicit none integer , parameter , private :: rk = kind ( 1.d0 ) #if 1 real ( rk ) :: LI = 33 4.e3 #endif private public :: DS , DI , DW , MU_TS , TFI , ice_optics , ice3lay_temp , ice3lay_resize , & thm_pack , thm_unpack , ice_thm_param , e_to_melt ! ! properties of ice, snow, and seawater (NCAR CSM values) ! real ( rk ) :: KS = 0.31 ! conductivity of snow - 0.31 W/(mK) real ( rk ), parameter :: DS = 33 0.0 ! density of snow - 330 kg/(m&#94;3) real ( rk ), parameter :: KI = 2.03 ! conductivity of ice  - 2.03 W/(mK) real ( rk ), parameter :: DI = 90 5.0 ! density of ice  - 905 kg/(m&#94;3) real ( rk ), parameter :: CI = 2 1e2 ! heat cap. of fresh ice - 2100 J/(kg K) real ( rk ), parameter :: SI = 1.0 ! salinity of sea ice real ( rk ), parameter :: MU_TS = 0.054 ! relates freezing temp. to salinity real ( rk ), parameter :: TFI = - MU_TS * SI ! sea ice freezing temp. = -mu*salinity real ( rk ), parameter :: CW = 4.2e3 ! heat capacity of seawater real ( rk ), parameter :: DW = 103 0.0 ! density of water for waterline - kg/(m&#94;3) ! albedos are from CSIM4 assumming 0.53 visible and 0.47 near-ir insolation real ( rk ) :: ALB_SNO = 0.85 ! albedo of snow (not melting) real ( rk ) :: ALB_ICE = 0.5826 ! albedo of ice (not melting) real ( rk ) :: PEN_ICE = 0.3 ! ice surface penetrating solar fraction real ( rk ) :: OPT_DEP_ICE = 0.67 ! ice optical depth (m) real ( rk ) :: T_RANGE_MELT = 1.0 ! melt albedos scaled in below melting T real ( rk ) :: H_LO_LIM = 0.0 ! hi/hs lower limit for temp. calc. logical :: SLAB_ICE = . false . ! should we do old style GFDL slab ice? ! ! slab ice specific parameters ! real ( rk ), parameter :: CRIT_THICKNESS = 1.00 real ( rk ), parameter :: T_RANGE = 1 0.0 real ( rk ), parameter :: MIN_ICE_ALB = 0.55 ! coupled model uses 0.55 real ( rk ), parameter :: MAX_ICE_ALB = 0.80 real ( rk ), parameter :: ALB_OCEAN = 0.10 ! logical :: CM2_BUGS = . false . ! keep cm2 bugs for reproducibility contains !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! ! ice_thm_param - set ice thermodynamic parameters                             ! !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! subroutine ice_thm_param ( alb_sno_in , alb_ice_in , pen_ice_in , opt_dep_ice_in , & slab_ice_in , t_range_melt_in , cm2_bugs_in , ks_in , & h_lo_lim_in ) real ( rk ), intent ( in ) :: alb_sno_in , alb_ice_in , pen_ice_in real ( rk ), intent ( in ) :: opt_dep_ice_in , t_range_melt_in logical , intent ( in ) :: slab_ice_in logical , intent ( in ) :: cm2_bugs_in real ( rk ), intent ( in ) :: ks_in real ( rk ), intent ( in ) :: h_lo_lim_in ALB_SNO = alb_sno_in ALB_ICE = alb_ice_in PEN_ICE = pen_ice_in OPT_DEP_ICE = opt_dep_ice_in SLAB_ICE = slab_ice_in T_RANGE_MELT = t_range_melt_in CM2_BUGS = cm2_bugs_in KS = ks_in H_LO_LIM = h_lo_lim_in end subroutine ice_thm_param !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! ! ice_optics - set albedo, penetrating solar, and ice/snow transmissivity      ! !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! subroutine ice_optics ( alb , pen , trn , hs , hi , ts , tfw ) real ( rk ), intent ( out ) :: alb ! ice surface albedo (0-1) real ( rk ), intent ( out ) :: pen ! fraction of down solar penetrating the ice real ( rk ), intent ( out ) :: trn ! ratio of down solar at bottom to top of ice real ( rk ), intent ( in ) :: hs ! snow thickness (m-snow) real ( rk ), intent ( in ) :: hi ! ice thickness (m-ice) real ( rk ), intent ( in ) :: ts ! surface temperature real ( rk ), intent ( in ) :: tfw ! seawater freezing temperature real ( rk ) :: as , ai , cs real ( rk ) :: thick_ice_alb , tcrit , fh if ( SLAB_ICE ) then tcrit = tfw - T_RANGE if ( ts <= tcrit ) then thick_ice_alb = MAX_ICE_ALB else if ( ts >= tfw ) then thick_ice_alb = MIN_ICE_ALB else thick_ice_alb = MAX_ICE_ALB + ( MIN_ICE_ALB - MAX_ICE_ALB ) * ( ts - tcrit ) / T_RANGE endif if ( hi >= crit_thickness ) then alb = THICK_ICE_ALB else alb = ALB_OCEAN + ( thick_ice_alb - ALB_OCEAN ) * sqrt ( hi / CRIT_THICKNESS ) endif pen = 0.0 trn = 0.0 !! check for ice albdeos out of range (0 to 1) !      if (alb.lt.0.0 .or.alb.gt.1.0) then !         print *,'ice_optics: albedo out of range, alb_in=',alb_in, 'alb=',alb !         print *,'ts=',ts,  'tfw=',tfw, 'tcrit=',tcrit !         print *,'hi=',hi,  'thick_ice_alb=',thick_ice_alb !         print *,'ALB_OCEAN=',ALB_OCEAN !         print *,'MIN_ICE_ALB=',MIN_ICE_ALB, 'MAX_ICE_ALB=',MAX_ICE_ALB !         print *,'T_RANGE,=',T_RANGE, 'CRIT_THICKNESS=',CRIT_THICKNESS !         stop !      end if return endif !! 2007/04/11 Fix for thin ice negative ice albedos from Mike Winton !!            Move ai calculation after if test as = ALB_SNO ; ai = ALB_ICE cs = hs / ( hs + 0.02 ) ! thin snow partially covers ice fh = min ( atan ( 5.0 * hi ) / atan ( 5.0 * 0.5 ), 1.0 ) ! use this form from CSIM4 to ! reduce albedo for thin ice if ( CM2_BUGS ) then ai = fh * ai + ( 1 - fh ) * 0.06 ! reduce albedo for thin ice if ( ts + T_RANGE_MELT > TFI ) then ! reduce albedo for melting as in ! CSIM4 assuming 0.53/0.47 vis/ir as = as - 0.1235 * min (( ts + T_RANGE_MELT - TFI ) / T_RANGE_MELT , 1.0 ) ai = ai - 0.075 * min (( ts + T_RANGE_MELT - TFI ) / T_RANGE_MELT , 1.0 ) endif else if ( ts + T_RANGE_MELT > TFI ) then ! reduce albedo for melting as in ! CSIM4 assuming 0.53/0.47 vis/ir as = as - 0.1235 * min (( ts + T_RANGE_MELT - TFI ) / T_RANGE_MELT , 1.0 ) ai = ai - 0.075 * min (( ts + T_RANGE_MELT - TFI ) / T_RANGE_MELT , 1.0 ) endif ai = fh * ai + ( 1 - fh ) * 0.06 ! reduce albedo for thin ice end if alb = cs * as + ( 1 - cs ) * ai pen = ( 1 - cs ) * PEN_ICE trn = exp ( - hi / OPT_DEP_ICE ); !! check for ice albdeos out of range (0 to 1) ! if (alb.lt.0.0 .or. alb.gt.1.0) then !    print *,'ice_optics: albedo out of range, alb=',alb !    print *,'cs=',cs,  'as=',as, 'ai=',ai !    print *,'ts=',ts,  'fh=',fh, 'hs=',hs, 'hi=',hi, 'tfw=',tfw !    print *,'ALB_SNO=',ALB_SNO,  'ALB_ICE=',ALB_ICE, 'T_RANGE_MELT,=',T_RANGE_MELT, 'TFI=',TFI !    stop ! end if return end subroutine ice_optics !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! ! ice3lay_temp - ice & snow temp. change [Winton (2000) section 2.a]           ! !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! subroutine ice3lay_temp ( hs , hi , t1 , t2 , ts , A , B , I , tfw , fb , dt , tmelt , bmelt ) implicit none real ( rk ), intent ( in ) :: hs ! snow thickness (m) real ( rk ), intent ( in ) :: hi ! ice thickness (m) real ( rk ), intent ( out ) :: ts ! surface temperature (deg-C) real ( rk ), intent ( inout ) :: t1 ! upper ice temperature (deg-C) real ( rk ), intent ( inout ) :: t2 ! lower ice temperature (deg-C) real ( rk ), intent ( in ) :: A ! net surface heat flux (+ up) at ts=0 (W/m&#94;2) real ( rk ), intent ( in ) :: B ! d(sfc heat flux)/d(ts) [W/(m&#94;2 deg-C)] real ( rk ), intent ( in ) :: I ! solar absorbed by upper ice (W/m&#94;2) real ( rk ), intent ( in ) :: tfw ! seawater freezing temperature (deg-C) real ( rk ), intent ( in ) :: fb ! heat flux from ocean to ice bottom (W/m&#94;2) real ( rk ), intent ( in ) :: dt ! timestep (sec) real ( rk ), intent ( inout ) :: tmelt ! accumulated top melting energy  (J/m&#94;2) real ( rk ), intent ( inout ) :: bmelt ! accumulated bottom melting energy (J/m&#94;2) ! ! variables for temperature calculation [see Winton (1999) section II.A.] ! note:  here equations are multiplied by hi to improve thin ice accuracy ! real ( rk ) :: tsf , k12 , hi2 , a10 , b10 , a1 , b1 , c1 ! TK Mods: real ( rk ) :: hi_effective , hie real ( rk ) :: KI_over_eps = 1.7065e-2 ! 5/2.93 from Bryan (1969); !                                 Value used in SS tsc.F (1.7065 cm) !                                  converted to meters... if ( SLAB_ICE ) then hi_effective = hi + KI_over_eps ! TK added ts = ( KI * tfw - A * hi_effective ) / ( KI + B * hi_effective ) ! TK mod if ( ts > 0.0 ) then ! surface melting conditions ts = 0.0 if ( hi > 0.0 ) tmelt = tmelt + ( KI * tfw / hi_effective - A ) * dt ! TK mod endif if ( hi > 0.0 ) then bmelt = bmelt + ( fb - KI * ( tfw - ts ) / hi_effective ) * dt ! TK mod else bmelt = bmelt + ( fb - A - B * tfw ) * dt endif return endif if ( hs > 0.0 ) then TSF = 0.0 else TSF = TFI endif hie = max ( hi , H_LO_LIM ); ! prevent thin ice inaccuracy (mw) ! ! Compute upper ice and surface temperatures ! K12 = 4 * KI * KS / ( KS + 4 * KI * hs / hie ) hi2 = hie * hie A10 = DI * hi2 * CI / ( 2 * dt ) + 2 * KI * ( 4 * dt * 2 * KI + DI * hi2 * CI ) / ( 6 * dt * 2 * KI + DI * hi2 * CI ) B10 = - DI * hi2 * ( CI * t1 + LI * TFI / t1 ) / ( 2 * dt ) - I * hie & - 2 * KI * ( 4 * dt * 2 * KI * tfw + DI * hi2 * CI * t2 ) / ( 6 * dt * 2 * KI + DI * hi2 * CI ) A1 = A10 + K12 * B * hie / ( K12 + B * hie ) B1 = B10 + A * K12 * hie / ( K12 + B * hie ) C1 = DI * hi2 * LI * TFI / ( 2 * dt ) t1 = - ( sqrt ( B1 * B1 - 4 * A1 * C1 ) + B1 ) / ( 2 * A1 ) ts = ( K12 * t1 - A * hie ) / ( K12 + B * hie ) !  if (ts > tsf) then       ! slightly different equation for melting conditions if ( ts > - 0.054 ) then ! slightly different equation for melting conditions A1 = A10 + K12 B1 = B10 - K12 * tsf t1 = - ( sqrt ( B1 * B1 - 4 * A1 * C1 ) + B1 ) / ( 2 * A1 ) ts = tsf tmelt = tmelt + ( K12 * ( t1 - ts ) / hie - ( A + B * ts )) * dt endif ! ! set lower ice temp. -- use tfw as reference for thin ice precision ! t1 = t1 - tfw ; t2 = t2 - tfw ; t2 = ( 2 * dt * 2 * KI * t1 + DI * hi2 * CI * t2 ) / ( 6 * dt * 2 * KI + DI * hi2 * CI ) t1 = t1 + tfw ; t2 = t2 + tfw ; bmelt = bmelt + ( fb + 4 * KI * ( t2 - tfw ) / hie ) * dt if ( t2 > TFI ) then ! put excess lower ice energy into bmelt bmelt = bmelt + e_to_melt ( h2 = hie / 2 , t2 = TFI ) - e_to_melt ( h2 = hie / 2 , t2 = t2 ) t2 = TFI endif if ( t1 > TFI ) then ! put excess upper ice energy into tmelt tmelt = tmelt + e_to_melt ( h1 = hie / 2 , t1 = TFI ) - e_to_melt ( h1 = hie / 2 , t1 = t1 ) t1 = TFI endif ! if (tmelt<0) then !    print *,'neg. tmelt=',tmelt,ts,t1,hs,hi,K12*(t1-ts)/hi,-(A+B*ts) !    print *,'K12=',K12 !    print *,'A/B/I=',A,B,I !    print *,'A/B/C=',A1,B1,C1,A1*t1*t1+B1*t1+C1,A1*t1*t1,B1*t1,C1 !    stop ! end if !KB call thm_checkout ( ts , hs , hi , t1 , t2 , bmelt , tmelt ) return end subroutine ice3lay_temp subroutine thm_checkout ( ts , hs , hi , t1 , t2 , bmelt , tmelt ) real ( rk ), intent ( in ) :: ts , hs , hi , t1 , t2 , bmelt , tmelt if ( ts > 0 . or . t1 > TFI . or . t2 > 0 . or . hs < 0 . or . hs > 100 . or . hi < 0 . or . hi > 100 & . or . abs ( bmelt ) > 100 * DI * LI . or . tmelt < 0 . or . tmelt > 100 * DI * LI ) then print * , 'UNREASONABLE ICE: hs=' , hs , 'hi=' , hi , 't1=' , t1 , 't2=' , t2 , 'ts=' , & ts , 'tmelt=' , tmelt , 'bmelt=' , bmelt end if end subroutine thm_checkout !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! ! e_to_melt - energy needed to melt a given snow/ice configuration             ! !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! function e_to_melt ( hs , h1 , t1 , h2 , t2 ) real ( rk ), intent ( in ), optional :: hs , h1 , t1 , h2 , t2 real ( rk ) :: e_to_melt e_to_melt = 0.0 if ( present ( hs )) e_to_melt = e_to_melt + DS * LI * hs if ( present ( h1 ). and . present ( t1 )) then e_to_melt = e_to_melt + DI * h1 * ( CI - LI / t1 ) * ( TFI - t1 ) endif if ( present ( h2 ). and . present ( t2 )) then e_to_melt = e_to_melt + DI * h2 * ( LI + CI * ( TFI - t2 )) endif end function e_to_melt !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! ! add_to_top - add some ice to the top ice layer                               ! !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! subroutine add_to_top ( h , t , h1 , t1 ) real ( rk ), intent ( in ) :: h , t real ( rk ), intent ( inout ) :: h1 , t1 real ( rk ) :: f1 f1 = h1 / ( h1 + h ) t1 = f1 * ( t1 + LI * TFI / ( CI * t1 )) + ( 1 - f1 ) * t t1 = ( t1 - sqrt ( t1 * t1 - 4 * TFI * LI / CI )) / 2 h1 = h1 + h return end subroutine add_to_top !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! ! add_to_bot - add some ice to the bottom ice layer                            ! !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! subroutine add_to_bot ( h , t , h2 , t2 ) real ( rk ), intent ( in ) :: h , t real ( rk ), intent ( inout ) :: h2 , t2 t2 = ( h2 * t2 + h * t ) / ( h2 + h ) h2 = h2 + h return end subroutine add_to_bot !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! ! even_up - transfer mass/energy between ice layers to maintain equal thickness! !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! subroutine even_up ( h1 , t1 , h2 , t2 ) real ( rk ), intent ( inout ) :: h1 , t1 , h2 , t2 real ( rk ) :: dh if ( h1 > ( h1 + h2 ) / 2 ) then call add_to_bot ( h1 - ( h1 + h2 ) / 2 , t1 + LI * TFI / ( CI * t1 ), h2 , t2 ) h1 = h2 else if ( h2 > ( h1 + h2 ) / 2 ) then call add_to_top ( h2 - ( h1 + h2 ) / 2 , t2 , h1 , t1 ) h2 = h1 endif if ( t2 > TFI ) then ! use extra energy to melt both layers evenly dh = h2 * CI * ( t2 - TFI ) * t1 / ( LI * t1 + ( CI * t1 - LI ) * ( TFI - t1 )) t2 = TFI h1 = h1 - dh h2 = h2 - dh endif return end subroutine even_up !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! ! ice3lay_resize - ice & snow thickness change [Winton (1998) section II.B.]   ! !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! subroutine ice3lay_resize ( hs , hi , t1 , t2 , snow , frazil , evap , tmelt , bmelt , & tfw , heat_to_ocn , h2o_to_ocn , h2o_from_ocn , & snow_to_ice , bablt ) real ( rk ), intent ( inout ) :: hs ! snow thickness (m-snow) real ( rk ), intent ( inout ) :: hi ! ice thickness (m-ice) real ( rk ), intent ( inout ) :: t1 ! temperature of upper ice (deg-C) real ( rk ), intent ( inout ) :: t2 ! temperature of lower ice (deg-C) real ( rk ), intent ( in ) :: snow ! new snow (kg/m&#94;2-snow) real ( rk ), intent ( in ) :: frazil ! frazil in energy units real ( rk ), intent ( in ) :: evap ! ice evaporation (kg/m&#94;2) real ( rk ), intent ( in ) :: tmelt ! top melting energy (J/m&#94;2) real ( rk ), intent ( in ) :: bmelt ! bottom melting energy (J/m&#94;2) real ( rk ), intent ( in ) :: tfw ! seawater freezing temperature (deg-C) real ( rk ), intent ( out ) :: heat_to_ocn ! energy left after ice all melted (J/m&#94;2) real ( rk ), intent ( out ) :: h2o_to_ocn ! liquid water flux to ocean (kg/m&#94;2) real ( rk ), intent ( out ) :: h2o_from_ocn ! evaporation flux from ocean (kg/m&#94;2) real ( rk ), intent ( out ) :: snow_to_ice ! snow below waterline becomes ice real ( rk ), intent ( out ), optional :: bablt ! bottom ablation (kg/m&#94;2) real ( rk ) h1 , h2 , dh , hw real ( rk ) h1o , h2o heat_to_ocn = 0.0 h2o_to_ocn = DS * hs + DI * hi + snow - evap ! - from ice at end gives ocean h2o flux h2o_from_ocn = 0.0 snow_to_ice = 0.0 if ( SLAB_ICE ) then ! ! add snow and frazil ! hi = hi + snow / DI + frazil / ( DI * LI ) t1 = tfw ; t2 = tfw ; ! ! atmospheric evaporation ! if ( evap <= hi * DI ) then hi = hi - evap / DI else h2o_from_ocn = evap - hi * DI hi = 0.0 end if ! ! ... melting ! hi = hi - ( tmelt + bmelt ) / ( DI * LI ) if ( hi < 0.0 ) then heat_to_ocn = - hi * DI * LI hi = 0.0 else heat_to_ocn = 0.0 endif h2o_to_ocn = h2o_to_ocn + h2o_from_ocn ! reset mark for leftover evap thru ice h2o_to_ocn = h2o_to_ocn - DI * hi - DS * hs ! hs should be zero if ( present ( bablt )) bablt = bmelt / LI return endif h1 = hi / 2 h2 = hi / 2 ! ! add snow ... ! hs = hs + snow / DS ! ! ... and frazil ! call add_to_bot ( frazil / e_to_melt ( h2 = 1._rk , t2 = tfw ), tfw , h2 , t2 ) ! ! atmospheric evaporation ! #if 0 if ( evap <= hs * DS ) then hs = hs - evap / DS else if ( evap - hs * DS <= h1 * DI ) then hs = 0.0 h1 = h1 - ( evap - DS * hs ) / DI else if ( evap - hs * DS - h1 * DI <= h2 * DI ) then hs = 0.0 h1 = 0.0 h2 = h2 - ( evap - hs * DS - h1 * DI ) / DI else h2o_from_ocn = evap - hs * DS - ( h1 + h2 ) * DI hs = 0.0 h1 = 0.0 h2 = 0.0 end if #endif if ( bmelt < 0.0 ) then h2o = h2 call add_to_bot ( - bmelt / e_to_melt ( h2 = 1._rk , t2 = tfw ), tfw , h2 , t2 ) end if if ( h1 == 0.0 ) t1 = tfw ! need this, below we divide by t1 even when h1 == 0 ! ! apply energy fluxes ... top ... ! h1o = h1 if ( tmelt <= e_to_melt ( hs )) then !KB    hs = hs - tmelt/e_to_melt(hs=1._rk) else if ( tmelt <= e_to_melt ( hs , h1 , t1 )) then h1 = h1 - ( tmelt - e_to_melt ( hs )) / e_to_melt ( h1 = 1._rk , t1 = t1 ) hs = 0.0 else if ( tmelt <= e_to_melt ( hs , h1 , t1 , h2 , t2 )) then h2 = h2 - ( tmelt - e_to_melt ( hs , h1 , t1 )) / e_to_melt ( h2 = 1._rk , t2 = t2 ) hs = 0.0 h1 = 0.0 else heat_to_ocn = heat_to_ocn + tmelt - e_to_melt ( hs , h1 , t1 , h2 , t2 ) hs = 0.0 h1 = 0.0 h2 = 0.0 endif ! ! ... and bottom ! if ( present ( bablt )) bablt = DS * hs + DI * ( h1 + h2 ) if ( bmelt > 0.0 ) then h2o = h2 if ( bmelt < e_to_melt ( h2 = h2 , t2 = t2 )) then h2 = h2 - bmelt / e_to_melt ( h2 = 1._rk , t2 = t2 ) else if ( bmelt < e_to_melt ( h1 = h1 , t1 = t1 , h2 = h2 , t2 = t2 )) then h1 = h1 - ( bmelt - e_to_melt ( h2 = h2 , t2 = t2 )) / e_to_melt ( h1 = 1._rk , t1 = t1 ) h2 = 0.0 else if ( bmelt < e_to_melt ( hs , h1 , t1 , h2 , t2 )) then !KB      hs = hs - (bmelt-e_to_melt(h1=h1,t1=t1,h2=h2,t2=t2))/e_to_melt(hs=1._rk) h1 = 0.0 h2 = 0.0 else heat_to_ocn = heat_to_ocn + bmelt - e_to_melt ( hs , h1 , t1 , h2 , t2 ) hs = 0.0 h1 = 0.0 h2 = 0.0 endif endif if ( present ( bablt )) bablt = bablt - DS * hs - DI * ( h1 + h2 ) hi = h1 + h2 hw = ( DI * hi + DS * hs ) / DW if ( hw > hi ) then ! convert snow to ice to maintain ice at waterline snow_to_ice = ( hw - hi ) * DI !KB    hs = hs - snow_to_ice/DS call add_to_top ( hw - hi , TFI , h1 , t1 ) endif call even_up ( h1 , t1 , h2 , t2 ) hi = h1 + h2 if ( hi == 0.0 ) then t1 = 0.0 t2 = 0.0 endif h2o_to_ocn = h2o_to_ocn + h2o_from_ocn ! correct mark for leftover evap thru ice h2o_to_ocn = h2o_to_ocn - DS * hs - DI * hi return end subroutine ice3lay_resize !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! ! thm_pack - form conserved quantities for two-dimensional advection           ! !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! subroutine thm_pack ( cn , hs , hi , t1 , t2 ) real ( rk ), dimension (:,:,:), intent ( inout ) :: cn , hs , hi , t1 , t2 integer :: i , j , k real ( rk ) :: tmp tmp = MU_TS * SI * LI / CI do k = 1 , size ( hi , 3 ) do j = 1 , size ( hi , 2 ) do i = 1 , size ( hi , 1 ) if ( hi ( i , j , k ) > 0.0 ) then hi ( i , j , k ) = cn ( i , j , k ) * hi ( i , j , k ) hs ( i , j , k ) = cn ( i , j , k ) * hs ( i , j , k ) t1 ( i , j , k ) = ( t1 ( i , j , k ) - tmp / t1 ( i , j , k )) * hi ( i , j , k ) t2 ( i , j , k ) = t2 ( i , j , k ) * hi ( i , j , k ) else cn ( i , j , k ) = 0.0 hi ( i , j , k ) = 0.0 hs ( i , j , k ) = 0.0 t1 ( i , j , k ) = 0.0 t2 ( i , j , k ) = 0.0 endif enddo enddo enddo return end subroutine thm_pack !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! ! thm_unpack - reform ice properties from advectively conserved quantities     ! !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~! subroutine thm_unpack ( cn , hs , hi , t1 , t2 ) real ( rk ), dimension (:,:,:), intent ( inout ) :: cn , hs , hi , t1 , t2 integer :: i , j , k real ( rk ) :: tmp tmp = 4 * MU_TS * SI * LI / CI do k = 1 , size ( hi , 3 ) do j = 1 , size ( hi , 2 ) do i = 1 , size ( hi , 1 ) if ( hi ( i , j , k ) > 0.0 ) then t1 ( i , j , k ) = t1 ( i , j , k ) / hi ( i , j , k ) t1 ( i , j , k ) = 0.5 * ( t1 ( i , j , k ) - sqrt ( t1 ( i , j , k ) * t1 ( i , j , k ) + tmp )) t2 ( i , j , k ) = t2 ( i , j , k ) / hi ( i , j , k ) hi ( i , j , k ) = hi ( i , j , k ) / cn ( i , j , k ) hs ( i , j , k ) = hs ( i , j , k ) / cn ( i , j , k ) else cn ( i , j , k ) = 0.0 hi ( i , j , k ) = 0.0 hs ( i , j , k ) = 0.0 t1 ( i , j , k ) = 0.0 t2 ( i , j , k ) = 0.0 endif enddo enddo enddo return end subroutine thm_unpack end module ice_thm_mod","tags":"","loc":"sourcefile/ice_thm.f90.html"},{"title":"stim_winton.F90 – STIM","text":"This file depends on sourcefile~~stim_winton.f90~~EfferentGraph sourcefile~stim_winton.f90 stim_winton.F90 sourcefile~ice_thm.f90 ice_thm.F90 sourcefile~stim_winton.f90->sourcefile~ice_thm.f90 sourcefile~stim_variables.f90 stim_variables.F90 sourcefile~stim_winton.f90->sourcefile~stim_variables.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules stim_winton Source Code stim_winton.F90 Source Code !> The winton ice model !> !> After Michael Winton !> !> authors: Karsten Bolding, Adolf Stips and Jesper Larsen MODULE stim_winton !> !>  The model consists of a zero heat capacity snow layer overlying two equally !>  thick sea ice layers. The upper ice layer has a variable heat capacity to !>  represent brine pockets. The lower ice layer has a fixed heat capacity. !>  The prognostic variables are hs (snow layer thickness), hi (ice layer !>  thickness), T1 and T2, the upper and lower ice layer temperatures located !>  at the midpoints of the layers. The ice model performs two functions, the !>  first is to calculate the ice temperature and the second is to calculate !>  changes in the thickness of ice and snow. !> !>------------------------------------------------------------------------------ !> !>                       THREE-LAYER VERTICAL THERMODYNAMICS !> !> Reference:  M. Winton, 2000: \"A reformulated three-layer sea ice model\", !>            Journal of Atmospheric and Oceanic Technology, 17, 525-531. !> !>------------------------------------------------------------------------------ !>        -> +---------+ <- Ts - diagnostic surface temperature ( <= 0C ) !>       /   |         | !>     hs    |  snow   | <- 0-heat capacity snow layer !>       \\   |         | !>        -> +---------+ !>       /   |         | !>      /    |         | <- T1 - upper 1/2 ice temperature; this layer has !>     /     |         |         a variable (T/S dependent) heat capacity !>     \\     |         | !>      \\    |         | <- T2 - lower 1/2 ice temp. (fixed heat capacity) !>       \\   |         | !>        -> +---------+ <- Tf - base of ice fixed at seawater freezing temp. !> !>                                                     Mike Winton (mw@gfdl.gov) !>------------------------------------------------------------------------------ !>  Note: in this implementation the equations are multiplied by hi to improve !>  thin ice accuracy !> !>  The code is based on the open source sea ice model included in the Modular !>  Ocean Model. !> !   hi      |   ice   | <- non 0-heat capacity ice layer use stim_variables use ice_thm_mod IMPLICIT NONE private public :: init_stim_winton public :: do_stim_winton real ( rk ), pointer :: Ts , T1 , T2 real ( rk ), pointer :: hi , hs , dh1 , dh2 real ( rk ), pointer :: trn real ( rk ) :: pen real ( rk ), pointer :: tmelt , bmelt real ( rk ), pointer :: fb ! heat flux from ocean to ice bottom (W/m&#94;2) contains SUBROUTINE init_stim_winton ( Ta ) real ( rk ), intent ( in ) :: Ta !! Air temperature [C] !----------------------------------------------------------------------- trn => transmissivity Ts => Tice_surface Ts = Ta T1 => Tice ( 1 ) T1 = Ta T2 => Tice ( 2 ) T2 = Tf hs => Hsnow hi => Hice dh1 => dHis dh2 => dHib tmelt => surface_ice_energy bmelt => bottom_ice_energy fb => ocean_ice_flux END SUBROUTINE init_stim_winton !----------------------------------------------------------------------- SUBROUTINE do_stim_winton ( ice_cover , dz , dt , Tw , S , Ta , precip , Qsw , Qfluxes ) !! This SUBROUTINE updates the sea ice prognostic variables. The updated !! variables are upper ice layer temperature (T1), lower ice layer temperature !! (T2), snow thickness (hs), and ice thickness (hi). !! !! The ice model performs this in two steps. First the temperatures are updated !! and secondly the changes in ice and snow thickness are calculated. !! !! Any surplus energy that is not used for melting is returned in tmelt and !! bmelt. !! !! Evaporation and bottom ablation formation are not included in !! this version of the model. Furthermore we do not keep an explicit water !! and salt budget for the sea ice and how that affects the water and salt !! budgets in the ocean. real ( rk ), intent ( in ) :: dz , dt , Ta , S , precip , Qsw integer , intent ( inout ) :: ice_cover real ( rk ), intent ( inout ) :: Tw interface SUBROUTINE Qfluxes ( T , qh , qe , qb ) integer , parameter :: rk = kind ( 1.d0 ) real ( rk ), intent ( in ) :: T real ( rk ), intent ( out ) :: qh , qe , qb END SUBROUTINE end interface real ( rk ) :: I ! solar absorbed by upper ice (W/m&#94;2) real ( rk ) :: evap ! evaporation of ice (m/s) real ( rk ) :: snow real ( rk ) :: A , B , dts = 0.01 real ( rk ) :: qe , qh , qb real ( rk ) :: h1 , h2 real ( rk ) :: ts_new real ( rk ) :: frazil real ( rk ) :: heat_to_ocn , h2o_to_ocn , h2o_from_ocn , snow_to_ice !----------------------------------------------------------------------- tmelt = 0._rk bmelt = 0._rk ! Calculate seawater freezing temperature Tf = - 0.0575_rk * S if ( ice_cover . gt . 0 ) then call ice_optics ( albedo_ice , pen , trn , hs , hi , ts , Tf ) I = Qsw * ( 1._rk - trn ) h1 = hi / 2._rk h2 = h1 ! check this out call Qfluxes ( Ts , qe , qh , qb ) A = - ( qe + qh + qb ) ! (7-) call Qfluxes ( Ts + dts , qe , qh , qb ) B = - ( qe + qh + qb ) B = ( B - A ) / dts ! (8) A = A - I - Ts * B ! (-7) !https://github.com/mom-ocean/MOM5/blob/08266af73b04d2334be4a52d0c45c174f447cee4/src/ice_sis/ice_model.F90 call ice3lay_temp ( hs , hi , t1 , t2 , ts_new , A , B , pen * I , Tf , fb , dt , tmelt , bmelt ) ts = ts_new !     frazil = 0._rk Hfrazil = 0._rk else frazil = - ( Tw - Tf ) * dz * Cw if ( frazil . gt . 0._rk ) Hfrazil = frazil / ( rho_ice * L_ice ) end if if ( ice_cover . gt . 0 . or . frazil . gt . 0._rk ) then call ice3lay_resize ( hs , hi , t1 , t2 , snow , frazil , evap , tmelt , bmelt , & tf , heat_to_ocn , h2o_to_ocn , h2o_from_ocn , & snow_to_ice ) !                       snow_to_ice, bablt) !write(*,*) 'CC ',heat_to_ocn, h2o_to_ocn, h2o_from_ocn end if hs = 0._rk if ( hi . gt . 0._rk ) then ice_cover = 2 else ice_cover = 0 end if END SUBROUTINE do_stim_winton !----------------------------------------------------------------------- END MODULE stim_winton !----------------------------------------------------------------------- ! Copyright by the GETM-team under the GNU Public License - www.gnu.org !-----------------------------------------------------------------------","tags":"","loc":"sourcefile/stim_winton.f90.html"},{"title":"stim_basal_melt.F90 – STIM","text":"This file depends on sourcefile~~stim_basal_melt.f90~~EfferentGraph sourcefile~stim_basal_melt.f90 stim_basal_melt.F90 sourcefile~stim_variables.f90 stim_variables.F90 sourcefile~stim_basal_melt.f90->sourcefile~stim_variables.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules stim_basal_melt Source Code stim_basal_melt.F90 Source Code !> The basal_melt ice model !> !> authors: Hans Burchard and Karsten Bolding module stim_basal_melt use stim_variables , only : rk use stim_variables , only : Hice use stim_variables , only : z0 => z0i use stim_variables , only : rhoi => rho_ice use stim_variables , only : Li => L_ice use stim_variables , only : vm => melt_rate use stim_variables , only : Tb => T_melt use stim_variables , only : Sb => S_melt use stim_variables , only : fH => ocean_ice_heat_flux use stim_variables , only : fS => ocean_ice_salt_flux IMPLICIT NONE private public init_stim_basal_melt , do_stim_basal_melt , clean_stim_basal_melt !----------------------------------------------------------------------- contains SUBROUTINE init_stim_basal_melt ( ice_cover ) !! Initialize the basal_melt model with an ice-cover IMPLICIT NONE integer , intent ( inout ) :: ice_cover integer :: rc !----------------------------------------------------------------------- END SUBROUTINE init_stim_basal_melt !----------------------------------------------------------------------- SUBROUTINE do_stim_basal_melt ( h , ustar , T , S ) IMPLICIT NONE real ( rk ), intent ( in ) :: h !! upper layer thickness [m] real ( rk ), intent ( inout ) :: ustar !! friction velocity ice/water interface [m/s] real ( rk ), intent ( in ) :: T !! upper layer temperature [C] real ( rk ), intent ( in ) :: S !! upper layer salinity [g/kg] #if 0 ! param. for freezing in-situ temperature eq. real ( rk ) :: l1 = - 0.0575 real ( rk ) :: l2 = 0.0901 real ( rk ) :: l3 = 7.61e-4 #else ! param. for freezing potential temperature eq. real ( rk ), parameter :: l1 = - 5.6705121472405570E-002 real ( rk ), parameter :: l2 = 7.5436448744204881E-002 real ( rk ), parameter :: l3 = 7.6828512903539831E-004 #endif real ( rk ) :: nu = 1.95e-6 !! molecular viscosity [m2/s] real ( rk ) :: kappa = 0.4 !! von Karman constant [-] real ( rk ) :: Bs = 8.5 !! constant for tracer roughness [-] real ( rk ) :: Pr_turb = 0.7 !! turbulent Prandtl number [-] real ( rk ) :: Pr_temp = 1 3.8 !! molecular Prandtl for temp [-] real ( rk ) :: Pr_salt = 243 2. !! turbulent Prandtl for salt [-] real ( rk ) :: c = 418 0. !! heat capacity of sea water [J/(kg K)] real ( rk ) :: ci = 199 5. !! heat capacity of glacial ice [J/(kg K)] real ( rk ) :: Ti = - 2 0. !! ice core temperature [deg C] !KB   real(rk) :: Li     = 3.33e5 !KB     !! latent heat of fusion [J/kg] real ( rk ) :: rho0 = 103 0. !! reference density of sea water [kg/m3] !KB   real(rk) :: rhoi   =  920. !KB     !! reference density of glacial ice [kg/m3] real ( rk ) :: log_zk_p_z0_z0t , log_zk_p_z0_z0s real ( rk ) :: betaT , betaS real ( rk ) :: A1T , A1S , LL real ( rk ) :: s1 , s2 , s3 , pp , qq real ( rk ) :: X , beta !----------------------------------------------------------------------- #if 0 X = 0.55 * exp ( 0.5 * kappa * Bs ) * sqrt ( z0 * ustar / nu ) beta = X * ( Pr_temp ** ( 2. / 3. ) - 0.2 ) - Pr_turb * Bs + 9.5 log_zk_p_z0_z0t = log (( 0.5 * h + z0 ) / z0 ) + kappa / Pr_turb * beta beta = X * ( Pr_salt ** ( 2. / 3. ) - 0.2 ) - Pr_turb * Bs + 9.5 log_zk_p_z0_z0s = log (( 0.5 * h + z0 ) / z0 ) + kappa / Pr_turb * beta #else betaT = 0.55 * exp ( 0.5 * kappa * Bs ) * sqrt ( z0 * ustar / nu ) betaT = betaT * ( Pr_temp ** ( 2. / 3. ) - 0.2 ) betaT = betaT - Pr_turb * Bs + 9.5 betaS = 0.55 * exp ( 0.5 * kappa * Bs ) * sqrt ( z0 * ustar / nu ) betaS = betaS * ( Pr_salt ** ( 2. / 3. ) - 0.2 ) betaS = betaS - Pr_turb * Bs + 9.5 log_zk_p_z0_z0t = log (( 0.5 * h + z0 ) / z0 ) + kappa / Pr_turb * betaT log_zk_p_z0_z0s = log (( 0.5 * h + z0 ) / z0 ) + kappa / Pr_turb * betaS #endif A1T = kappa * ustar / ( Pr_turb * log_zk_p_z0_z0t ) A1S = kappa * ustar / ( Pr_turb * log_zk_p_z0_z0s ) !KB   LL=l2+l3*zb LL = l2 + l3 * Hice * rhoi / rho0 s1 = l1 * ( A1T - A1S * ci / c ) s2 = A1S * S * l1 * ci / c - A1S / c * ( ci * ( LL - Ti ) + Li ) - A1T * ( T - LL ) s3 = A1S * S / c * ( ci * ( LL - Ti ) + Li ) pp = s2 / s1 qq = s3 / s1 Sb = - 0.5 * pp + sqrt ( 0.25 * pp ** 2 - qq ) !! melt layer salinity Tb = l1 * Sb + LL !! melt layer temperature vm = A1T * ( T - Tb ) / ( ci / c * ( Tb - Ti ) + Li / c ) !! melt rate in m/s (>0 for melting) fH = ( A1T * ( T - Tb ) - vm * Tb ) * c * rho0 !! upward heat flux in W/m2 (>0 for melting) fS = A1S * ( S - Sb ) - vm * Sb !! upward salinity flux (should be zero for glacial ice) if ( ustar < 1e-10 ) then fH = 0.0 fS = 0.0 vm = 0.0 end if END SUBROUTINE do_stim_basal_melt !----------------------------------------------------------------------- ! SUBROUTINE clean_stim_basal_melt () ! IMPLICIT NONE !----------------------------------------------------------------------- END SUBROUTINE clean_stim_basal_melt !EOC !----------------------------------------------------------------------- end module stim_basal_melt !----------------------------------------------------------------------- ! Copyright by the STIM-team under the GNU Public License - www.gnu.org !-----------------------------------------------------------------------","tags":"","loc":"sourcefile/stim_basal_melt.f90.html"},{"title":"stim_lebedev.F90 – STIM","text":"This file depends on sourcefile~~stim_lebedev.f90~~EfferentGraph sourcefile~stim_lebedev.f90 stim_lebedev.F90 sourcefile~stim_variables.f90 stim_variables.F90 sourcefile~stim_lebedev.f90->sourcefile~stim_variables.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules stim_lebedev Source Code stim_lebedev.F90 Source Code !> The Lebedev ice model !> !> authors: Adolf Stips and Karsten Bolding MODULE stim_lebedev !! https://agupubs.onlinelibrary.wiley.com/doi/10.1002/2016JC012199 use stim_variables , only : transmissivity , albedo_ice use stim_variables , only : rk , Hice , dHis , dHib , Tf , fdd use stim_variables , only : rho_ice , L_ice , ocean_ice_flux IMPLICIT NONE private public init_stim_lebedev , do_stim_lebedev , clean_stim_lebedev !! Constants provided by Adolf Stips real ( rk ) :: lebedev_fac = 1.33_rk real ( rk ) :: damp_leb_swr = - 1.6_rk real ( rk ) :: damp_leb_wind = - 1.6_rk real ( rk ) :: damp_leb_shf = - 1.6_rk real ( rk ) :: freeze_fac = - 0.0575_rk real ( rk ) :: lebedev_albedo = 0.545 !----------------------------------------------------------------------- contains !----------------------------------------------------------------------- SUBROUTINE init_stim_lebedev ( ice_cover ) integer , intent ( inout ) :: ice_cover integer :: rc !----------------------------------------------------------------------- if ( Hice . gt . 0._rk ) then fdd = ( 10 0._rk * Hice / lebedev_fac ) ** ( 1._rk / 0.58_rk ) ice_cover = 2 else fdd = 0._rk ice_cover = 0 end if END SUBROUTINE init_stim_lebedev !----------------------------------------------------------------------- SUBROUTINE do_stim_lebedev ( ice_cover , dt , Tw , S , Ta , precip ) !! Calculate ice thickness according to Lebedev 1938 real ( rk ), intent ( in ) :: dt , Ta , S , precip integer , intent ( inout ) :: ice_cover real ( rk ), intent ( inout ) :: Tw real ( rk ) :: x !----------------------------------------------------------------------- Tf = freeze_fac * S if ( ice_cover . eq . 2 ) then ! calculate the cumulative freezing days fdd = fdd + ( Tf - Ta ) * dt / 8640 0._rk else ! ice_hi was 0._rk if ( Ta . lt . Tf . and . Tw . lt . Tf ) then fdd = fdd + ( Tf - Ta ) * dt / 8640 0._rk end if end if ! have at least 1 cm of ice,.. - the melting is not done correct - KB if ( fdd . gt . 1._rk ) then x = Hice Hice = 0.01_rk * lebedev_fac * fdd ** 0.58_rk dHis = Hice - x #if 0 if ( dHis . lt . 0._rk ) then dHib = ( - dt * sensible_ice_water ) / ( rho_ice * L_ice ) else dHib = 0._rk end if #endif Tw = Tf ice_cover = 2 albedo_ice = lebedev_albedo transmissivity = exp ( Hice / damp_leb_swr ) !      transmissivity = exp(Hice*damp_leb_swr) if ( Hice . lt . 0._rk ) then albedo_ice = 0._rk transmissivity = 1._rk Hice = 0._rk ice_cover = 0 end if else fdd = 0._rk Hice = 0._rk dHis = 0._rk ice_cover = 0 end if #if 0 ! if we have ice change the heatfluxes ! where ( ice_hi . gt . 0._rk ) ! damp the shortwave radiation swr = swr * exp ( damp_leb_swr * ice_hi ) albedo = albedo_ice ! damp the wind stress tausx = tausx * exp ( damp_leb_wind * ice_hi ) tausy = tausy * exp ( damp_leb_wind * ice_hi ) ! damp the heatflux ­ this is of course tricky as latent heatflux and ! longwave radiation behave different from sensible heatflux ! flux routine must be rewritten to treat them all separate ! heat = heat * exp(damp_leb_shf * ice_hi) ! estimate sensible heat flux between ice and ocean water shf = sens_ice_water * ( freezing_fac * sss ­ sst ) end where #endif END SUBROUTINE do_stim_lebedev !----------------------------------------------------------------------- SUBROUTINE clean_stim_lebedev () IMPLICIT NONE !----------------------------------------------------------------------- LEVEL2 'clean_stim_lebedev' END SUBROUTINE clean_stim_lebedev !----------------------------------------------------------------------- END MODULE stim_lebedev !----------------------------------------------------------------------- ! Copyright by the STIM-team under the GNU Public License - www.gnu.org !-----------------------------------------------------------------------","tags":"","loc":"sourcefile/stim_lebedev.f90.html"},{"title":"stim_obsice.F90 – STIM","text":"This file depends on sourcefile~~stim_obsice.f90~~EfferentGraph sourcefile~stim_obsice.f90 stim_obsice.F90 sourcefile~stim_variables.f90 stim_variables.F90 sourcefile~stim_obsice.f90->sourcefile~stim_variables.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules stim_obsice Source Code stim_obsice.F90 Source Code !----------------------------------------------------------------------- !BOP ! ! !MODULE: 'obsice' ice module ! ! !INTERFACE: module stim_obsice ! ! !DESCRIPTION: !  https://agupubs.onlinelibrary.wiley.com/doi/10.1002/2016JC012199 ! ! !USES: use stim_variables , only : transmissivity , albedo_ice use stim_variables , only : rk , Hice , dHis , dHib , Tf , fdd use stim_variables , only : rho_ice , L_ice , ocean_ice_flux IMPLICIT NONE !  Default all is private. private ! ! !PUBLIC MEMBER FUNCTIONS: public init_stim_obsice , do_stim_obsice , clean_stim_obsice ! ! !PUBLIC DATA MEMBERS: ! ! !PRIVATE DATA MEMBERS: ! ! !REVISION HISTORY: !  Original author(s): Karsten Bolding ! !EOP !----------------------------------------------------------------------- contains !----------------------------------------------------------------------- !BOP ! ! !IROUTINE: Initialisation of the ice variables ! ! !INTERFACE: subroutine init_stim_obsice ( ice_cover ) ! ! !DESCRIPTION: ! ! !USES: IMPLICIT NONE ! ! !INPUT PARAMETERS: ! !INPUT PARAMETERS: ! ! !INPUT/OUTPUT PARAMETERS: integer , intent ( inout ) :: ice_cover ! ! !REVISION HISTORY: !  Original author(s): Karsten Bolding ! !  See log for the ice module ! ! !LOCAL VARIABLES: integer :: rc !EOP !----------------------------------------------------------------------- !BOC end subroutine init_stim_obsice !EOC !----------------------------------------------------------------------- !BOP ! ! !IROUTINE: do the 'obsice' ice calculations ! ! !INTERFACE: subroutine do_stim_obsice ( ice_cover , Tw , S , Ta ) ! ! !DESCRIPTION: ! ! !USES: IMPLICIT NONE ! ! !INPUT PARAMETERS: real ( rk ), intent ( in ) :: S , Ta ! ! !INPUT/OUTPUT PARAMETERS: integer , intent ( inout ) :: ice_cover real ( rk ), intent ( inout ) :: Tw ! ! !REVISION HISTORY: !  Original author(s): Karsten Bolding ! !  See log for the ice module ! ! !LOCAL VARIABLES: !EOP !----------------------------------------------------------------------- !BOC ! calculate ice thickness according to obsice 1938 Tf = - 0.0575_rk * S write ( * , * ) Tf if ( ice_cover . eq . 2 ) then Tw = Tf !KB      Tice = (alpha*Tf+Ta)/(1._rk+alpha) ! From mylake - but why? albedo_ice = 0.6_rk else Hice = 0._rk albedo_ice = 0._rk transmissivity = 1._rk end if end subroutine do_stim_obsice !EOC !----------------------------------------------------------------------- !BOP ! ! !IROUTINE: Cleaning up the 'obsice' ice variables ! ! !INTERFACE: subroutine clean_stim_obsice () ! ! !DESCRIPTION: ! ! !USES: IMPLICIT NONE ! ! !INPUT PARAMETERS: ! ! !REVISION HISTORY: !  Original author(s): Karsten Bolding ! !  See log for the ice module ! !EOP !----------------------------------------------------------------------- !BOC !LEVEL2 'clean_stim_obsice' end subroutine clean_stim_obsice !EOC !----------------------------------------------------------------------- end module stim_obsice !----------------------------------------------------------------------- ! Copyright by the STIM-team under the GNU Public License - www.gnu.org !-----------------------------------------------------------------------","tags":"","loc":"sourcefile/stim_obsice.f90.html"},{"title":"init_stim_yaml – STIM","text":"private subroutine init_stim_yaml() Uses settings proc~~init_stim_yaml~~UsesGraph proc~init_stim_yaml init_stim_yaml settings settings proc~init_stim_yaml->settings Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Initialize configuration via entries in a YAML-file\nUsing the GOTM settings module Arguments None Calls proc~~init_stim_yaml~~CallsGraph proc~init_stim_yaml init_stim_yaml option option proc~init_stim_yaml->option tice tice proc~init_stim_yaml->tice Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~init_stim_yaml~~CalledByGraph proc~init_stim_yaml init_stim_yaml interface~init_ice init_ice interface~init_ice->proc~init_stim_yaml Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_stim_yaml.html"},{"title":"post_init_stim – STIM","text":"private subroutine post_init_stim(Ta, S) Arguments Type Intent Optional Attributes Name real(kind=selected_real_kind), intent(in) :: Ta Air temperature [C] real(kind=selected_real_kind), intent(in) :: S Salinity [g/kg] Calls proc~~post_init_stim~~CallsGraph proc~post_init_stim post_init_stim proc~init_stim_variables init_stim_variables proc~post_init_stim->proc~init_stim_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~post_init_stim~~CalledByGraph proc~post_init_stim post_init_stim interface~post_init_ice post_init_ice interface~post_init_ice->proc~post_init_stim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/post_init_stim.html"},{"title":"do_stim – STIM","text":"private subroutine do_stim(dz, dt, ustar, Tw, S, Ta, precip, Qsw, Qfluxes) Arguments Arguments Type Intent Optional Attributes Name real(kind=selected_real_kind), intent(inout) :: dz layer thickness [m] real(kind=selected_real_kind), intent(inout) :: dt time step [s] real(kind=selected_real_kind), intent(inout) :: ustar surface friction velocity [m/s] real(kind=selected_real_kind), intent(inout) :: Tw water temperature [C] real(kind=selected_real_kind), intent(inout) :: S salinity [g/kg] real(kind=selected_real_kind), intent(inout) :: Ta air temperature [C] real(kind=selected_real_kind), intent(inout) :: precip precipitation [mm?] real(kind=selected_real_kind), intent(inout) :: Qsw short wave radiation [W/m&#94;2] private subroutine Qfluxes(T, qh, qe, qb) Arguments Type Intent Optional Attributes Name real(kind=selected_real_kind), intent(in) :: T temperature [C] real(kind=selected_real_kind), intent(out) :: qh latent heat [W/m&#94;2] real(kind=selected_real_kind), intent(out) :: qe sensible heat [W/m&#94;2] real(kind=selected_real_kind), intent(out) :: qb net longwave radiation [W/m&#94;2] Called by proc~~do_stim~~CalledByGraph proc~do_stim do_stim interface~do_ice do_ice interface~do_ice->proc~do_stim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/do_stim.html"},{"title":"clean_stim – STIM","text":"private subroutine clean_stim() De-allocates all memory allocated via init_ice() Arguments None Called by proc~~clean_stim~~CalledByGraph proc~clean_stim clean_stim interface~clean_ice clean_ice interface~clean_ice->proc~clean_stim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/clean_stim.html"},{"title":"init_ice – STIM","text":"public interface init_ice Calls interface~~init_ice~~CallsGraph interface~init_ice init_ice proc~init_stim_yaml init_stim_yaml interface~init_ice->proc~init_stim_yaml option option proc~init_stim_yaml->option tice tice proc~init_stim_yaml->tice Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures init_stim_yaml Module Procedures private subroutine init_stim_yaml () Initialize configuration via entries in a YAML-file\nUsing the GOTM settings module Arguments None","tags":"","loc":"interface/init_ice.html"},{"title":"post_init_ice – STIM","text":"public interface post_init_ice Calls interface~~post_init_ice~~CallsGraph interface~post_init_ice post_init_ice proc~post_init_stim post_init_stim interface~post_init_ice->proc~post_init_stim proc~init_stim_variables init_stim_variables proc~post_init_stim->proc~init_stim_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures post_init_stim Module Procedures private subroutine post_init_stim (Ta, S) Arguments Type Intent Optional Attributes Name real(kind=selected_real_kind), intent(in) :: Ta Air temperature [C] real(kind=selected_real_kind), intent(in) :: S Salinity [g/kg]","tags":"","loc":"interface/post_init_ice.html"},{"title":"do_ice – STIM","text":"public interface do_ice Calls interface~~do_ice~~CallsGraph interface~do_ice do_ice proc~do_stim do_stim interface~do_ice->proc~do_stim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures do_stim Module Procedures private subroutine do_stim (dz, dt, ustar, Tw, S, Ta, precip, Qsw, Qfluxes) Arguments Arguments Type Intent Optional Attributes Name real(kind=selected_real_kind), intent(inout) :: dz layer thickness [m] real(kind=selected_real_kind), intent(inout) :: dt time step [s] real(kind=selected_real_kind), intent(inout) :: ustar surface friction velocity [m/s] real(kind=selected_real_kind), intent(inout) :: Tw water temperature [C] real(kind=selected_real_kind), intent(inout) :: S salinity [g/kg] real(kind=selected_real_kind), intent(inout) :: Ta air temperature [C] real(kind=selected_real_kind), intent(inout) :: precip precipitation [mm?] real(kind=selected_real_kind), intent(inout) :: Qsw short wave radiation [W/m&#94;2] private subroutine Qfluxes(T, qh, qe, qb) Arguments Type Intent Optional Attributes Name real(kind=selected_real_kind), intent(in) :: T temperature [C] real(kind=selected_real_kind), intent(out) :: qh latent heat [W/m&#94;2] real(kind=selected_real_kind), intent(out) :: qe sensible heat [W/m&#94;2] real(kind=selected_real_kind), intent(out) :: qb net longwave radiation [W/m&#94;2]","tags":"","loc":"interface/do_ice.html"},{"title":"clean_ice – STIM","text":"public interface clean_ice Calls interface~~clean_ice~~CallsGraph interface~clean_ice clean_ice proc~clean_stim clean_stim interface~clean_ice->proc~clean_stim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures clean_stim Module Procedures private subroutine clean_stim () De-allocates all memory allocated via init_ice() Arguments None","tags":"","loc":"interface/clean_ice.html"},{"title":"init_stim_variables – STIM","text":"public subroutine init_stim_variables(ice_model) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ice_model Called by proc~~init_stim_variables~~CalledByGraph proc~init_stim_variables init_stim_variables proc~post_init_stim post_init_stim proc~post_init_stim->proc~init_stim_variables interface~post_init_ice post_init_ice interface~post_init_ice->proc~post_init_stim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_stim_variables.html"},{"title":"clean_stim_variables – STIM","text":"public subroutine clean_stim_variables() Arguments None Contents None","tags":"","loc":"proc/clean_stim_variables.html"},{"title":"init_stim_mylake – STIM","text":"public subroutine init_stim_mylake() Arguments None Contents None","tags":"","loc":"proc/init_stim_mylake.html"},{"title":"do_stim_mylake – STIM","text":"public subroutine do_stim_mylake(ice_cover, dz, dt, Tw, S, Ta, precip, Qsw, Qfluxes) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ice_cover real(kind=rk), intent(in) :: dz real(kind=rk), intent(in) :: dt real(kind=rk), intent(inout) :: Tw real(kind=rk), intent(in) :: S real(kind=rk), intent(in) :: Ta real(kind=rk), intent(in) :: precip real(kind=rk), intent(in) :: Qsw private subroutine Qfluxes(T, qh, qe, qb) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: T real(kind=rk), intent(out) :: qh real(kind=rk), intent(out) :: qe real(kind=rk), intent(out) :: qb Contents None","tags":"","loc":"proc/do_stim_mylake.html"},{"title":"clean_stim_mylake – STIM","text":"public subroutine clean_stim_mylake() Arguments None Contents None","tags":"","loc":"proc/clean_stim_mylake.html"},{"title":"e_to_melt – STIM","text":"public function e_to_melt(hs, h1, t1, h2, t2) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), optional :: hs real(kind=rk), intent(in), optional :: h1 real(kind=rk), intent(in), optional :: t1 real(kind=rk), intent(in), optional :: h2 real(kind=rk), intent(in), optional :: t2 Return Value real(kind=rk) Called by proc~~e_to_melt~~CalledByGraph proc~e_to_melt e_to_melt proc~ice3lay_resize ice3lay_resize proc~ice3lay_resize->proc~e_to_melt proc~ice3lay_temp ice3lay_temp proc~ice3lay_temp->proc~e_to_melt proc~do_stim_winton do_stim_winton proc~do_stim_winton->proc~ice3lay_resize proc~do_stim_winton->proc~ice3lay_temp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/e_to_melt.html"},{"title":"ice_thm_param – STIM","text":"public subroutine ice_thm_param(alb_sno_in, alb_ice_in, pen_ice_in, opt_dep_ice_in, slab_ice_in, t_range_melt_in, cm2_bugs_in, ks_in, h_lo_lim_in) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: alb_sno_in real(kind=rk), intent(in) :: alb_ice_in real(kind=rk), intent(in) :: pen_ice_in real(kind=rk), intent(in) :: opt_dep_ice_in logical, intent(in) :: slab_ice_in real(kind=rk), intent(in) :: t_range_melt_in logical, intent(in) :: cm2_bugs_in real(kind=rk), intent(in) :: ks_in real(kind=rk), intent(in) :: h_lo_lim_in Contents None","tags":"","loc":"proc/ice_thm_param.html"},{"title":"ice_optics – STIM","text":"public subroutine ice_optics(alb, pen, trn, hs, hi, ts, tfw) check for ice albdeos out of range (0 to 1) 2007/04/11 Fix for thin ice negative ice albedos from Mike Winton\n           Move ai calculation after if test check for ice albdeos out of range (0 to 1) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: alb real(kind=rk), intent(out) :: pen real(kind=rk), intent(out) :: trn real(kind=rk), intent(in) :: hs real(kind=rk), intent(in) :: hi real(kind=rk), intent(in) :: ts real(kind=rk), intent(in) :: tfw Called by proc~~ice_optics~~CalledByGraph proc~ice_optics ice_optics proc~do_stim_winton do_stim_winton proc~do_stim_winton->proc~ice_optics Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ice_optics.html"},{"title":"ice3lay_temp – STIM","text":"public subroutine ice3lay_temp(hs, hi, t1, t2, ts, A, B, I, tfw, fb, dt, tmelt, bmelt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: hs real(kind=rk), intent(in) :: hi real(kind=rk), intent(inout) :: t1 real(kind=rk), intent(inout) :: t2 real(kind=rk), intent(out) :: ts real(kind=rk), intent(in) :: A real(kind=rk), intent(in) :: B real(kind=rk), intent(in) :: I real(kind=rk), intent(in) :: tfw real(kind=rk), intent(in) :: fb real(kind=rk), intent(in) :: dt real(kind=rk), intent(inout) :: tmelt real(kind=rk), intent(inout) :: bmelt Calls proc~~ice3lay_temp~~CallsGraph proc~ice3lay_temp ice3lay_temp proc~e_to_melt e_to_melt proc~ice3lay_temp->proc~e_to_melt proc~thm_checkout thm_checkout proc~ice3lay_temp->proc~thm_checkout Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ice3lay_temp~~CalledByGraph proc~ice3lay_temp ice3lay_temp proc~do_stim_winton do_stim_winton proc~do_stim_winton->proc~ice3lay_temp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ice3lay_temp.html"},{"title":"thm_checkout – STIM","text":"private subroutine thm_checkout(ts, hs, hi, t1, t2, bmelt, tmelt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: ts real(kind=rk), intent(in) :: hs real(kind=rk), intent(in) :: hi real(kind=rk), intent(in) :: t1 real(kind=rk), intent(in) :: t2 real(kind=rk), intent(in) :: bmelt real(kind=rk), intent(in) :: tmelt Called by proc~~thm_checkout~~CalledByGraph proc~thm_checkout thm_checkout proc~ice3lay_temp ice3lay_temp proc~ice3lay_temp->proc~thm_checkout proc~do_stim_winton do_stim_winton proc~do_stim_winton->proc~ice3lay_temp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/thm_checkout.html"},{"title":"add_to_top – STIM","text":"private subroutine add_to_top(h, t, h1, t1) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: h real(kind=rk), intent(in) :: t real(kind=rk), intent(inout) :: h1 real(kind=rk), intent(inout) :: t1 Called by proc~~add_to_top~~CalledByGraph proc~add_to_top add_to_top proc~ice3lay_resize ice3lay_resize proc~ice3lay_resize->proc~add_to_top proc~even_up even_up proc~ice3lay_resize->proc~even_up proc~even_up->proc~add_to_top proc~do_stim_winton do_stim_winton proc~do_stim_winton->proc~ice3lay_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/add_to_top.html"},{"title":"add_to_bot – STIM","text":"private subroutine add_to_bot(h, t, h2, t2) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: h real(kind=rk), intent(in) :: t real(kind=rk), intent(inout) :: h2 real(kind=rk), intent(inout) :: t2 Called by proc~~add_to_bot~~CalledByGraph proc~add_to_bot add_to_bot proc~ice3lay_resize ice3lay_resize proc~ice3lay_resize->proc~add_to_bot proc~even_up even_up proc~ice3lay_resize->proc~even_up proc~even_up->proc~add_to_bot proc~do_stim_winton do_stim_winton proc~do_stim_winton->proc~ice3lay_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/add_to_bot.html"},{"title":"even_up – STIM","text":"private subroutine even_up(h1, t1, h2, t2) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: h1 real(kind=rk), intent(inout) :: t1 real(kind=rk), intent(inout) :: h2 real(kind=rk), intent(inout) :: t2 Calls proc~~even_up~~CallsGraph proc~even_up even_up proc~add_to_bot add_to_bot proc~even_up->proc~add_to_bot proc~add_to_top add_to_top proc~even_up->proc~add_to_top Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~even_up~~CalledByGraph proc~even_up even_up proc~ice3lay_resize ice3lay_resize proc~ice3lay_resize->proc~even_up proc~do_stim_winton do_stim_winton proc~do_stim_winton->proc~ice3lay_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/even_up.html"},{"title":"ice3lay_resize – STIM","text":"public subroutine ice3lay_resize(hs, hi, t1, t2, snow, frazil, evap, tmelt, bmelt, tfw, heat_to_ocn, h2o_to_ocn, h2o_from_ocn, snow_to_ice, bablt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: hs real(kind=rk), intent(inout) :: hi real(kind=rk), intent(inout) :: t1 real(kind=rk), intent(inout) :: t2 real(kind=rk), intent(in) :: snow real(kind=rk), intent(in) :: frazil real(kind=rk), intent(in) :: evap real(kind=rk), intent(in) :: tmelt real(kind=rk), intent(in) :: bmelt real(kind=rk), intent(in) :: tfw real(kind=rk), intent(out) :: heat_to_ocn real(kind=rk), intent(out) :: h2o_to_ocn real(kind=rk), intent(out) :: h2o_from_ocn real(kind=rk), intent(out) :: snow_to_ice real(kind=rk), intent(out), optional :: bablt Calls proc~~ice3lay_resize~~CallsGraph proc~ice3lay_resize ice3lay_resize proc~e_to_melt e_to_melt proc~ice3lay_resize->proc~e_to_melt proc~add_to_bot add_to_bot proc~ice3lay_resize->proc~add_to_bot proc~even_up even_up proc~ice3lay_resize->proc~even_up proc~add_to_top add_to_top proc~ice3lay_resize->proc~add_to_top proc~even_up->proc~add_to_bot proc~even_up->proc~add_to_top Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ice3lay_resize~~CalledByGraph proc~ice3lay_resize ice3lay_resize proc~do_stim_winton do_stim_winton proc~do_stim_winton->proc~ice3lay_resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ice3lay_resize.html"},{"title":"thm_pack – STIM","text":"public subroutine thm_pack(cn, hs, hi, t1, t2) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout), dimension(:,:,:) :: cn real(kind=rk), intent(inout), dimension(:,:,:) :: hs real(kind=rk), intent(inout), dimension(:,:,:) :: hi real(kind=rk), intent(inout), dimension(:,:,:) :: t1 real(kind=rk), intent(inout), dimension(:,:,:) :: t2 Contents None","tags":"","loc":"proc/thm_pack.html"},{"title":"thm_unpack – STIM","text":"public subroutine thm_unpack(cn, hs, hi, t1, t2) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout), dimension(:,:,:) :: cn real(kind=rk), intent(inout), dimension(:,:,:) :: hs real(kind=rk), intent(inout), dimension(:,:,:) :: hi real(kind=rk), intent(inout), dimension(:,:,:) :: t1 real(kind=rk), intent(inout), dimension(:,:,:) :: t2 Contents None","tags":"","loc":"proc/thm_unpack.html"},{"title":"init_stim_winton – STIM","text":"public subroutine init_stim_winton(Ta) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Ta Air temperature [C] Calls proc~~init_stim_winton~~CallsGraph proc~init_stim_winton init_stim_winton tice tice proc~init_stim_winton->tice Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_stim_winton.html"},{"title":"do_stim_winton – STIM","text":"public subroutine do_stim_winton(ice_cover, dz, dt, Tw, S, Ta, precip, Qsw, Qfluxes) This SUBROUTINE updates the sea ice prognostic variables. The updated\nvariables are upper ice layer temperature (T1), lower ice layer temperature\n(T2), snow thickness (hs), and ice thickness (hi). The ice model performs this in two steps. First the temperatures are updated\nand secondly the changes in ice and snow thickness are calculated. Any surplus energy that is not used for melting is returned in tmelt and\nbmelt. Evaporation and bottom ablation formation are not included in\nthis version of the model. Furthermore we do not keep an explicit water\nand salt budget for the sea ice and how that affects the water and salt\nbudgets in the ocean. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ice_cover real(kind=rk), intent(in) :: dz real(kind=rk), intent(in) :: dt real(kind=rk), intent(inout) :: Tw real(kind=rk), intent(in) :: S real(kind=rk), intent(in) :: Ta real(kind=rk), intent(in) :: precip real(kind=rk), intent(in) :: Qsw private subroutine Qfluxes(T, qh, qe, qb) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: T real(kind=rk), intent(out) :: qh real(kind=rk), intent(out) :: qe real(kind=rk), intent(out) :: qb Calls proc~~do_stim_winton~~CallsGraph proc~do_stim_winton do_stim_winton proc~ice3lay_resize ice3lay_resize proc~do_stim_winton->proc~ice3lay_resize proc~ice3lay_temp ice3lay_temp proc~do_stim_winton->proc~ice3lay_temp proc~ice_optics ice_optics proc~do_stim_winton->proc~ice_optics proc~even_up even_up proc~ice3lay_resize->proc~even_up proc~add_to_bot add_to_bot proc~ice3lay_resize->proc~add_to_bot proc~add_to_top add_to_top proc~ice3lay_resize->proc~add_to_top proc~e_to_melt e_to_melt proc~ice3lay_resize->proc~e_to_melt proc~thm_checkout thm_checkout proc~ice3lay_temp->proc~thm_checkout proc~ice3lay_temp->proc~e_to_melt proc~even_up->proc~add_to_bot proc~even_up->proc~add_to_top Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/do_stim_winton.html"},{"title":"init_stim_basal_melt – STIM","text":"public subroutine init_stim_basal_melt(ice_cover) Initialize the basal_melt model with an ice-cover Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ice_cover Contents None","tags":"","loc":"proc/init_stim_basal_melt.html"},{"title":"do_stim_basal_melt – STIM","text":"public subroutine do_stim_basal_melt(h, ustar, T, S) melt layer salinity\nmelt layer temperature melt rate in m/s (>0 for melting) upward heat flux in W/m2 (>0 for melting) upward salinity flux (should be zero for glacial ice) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: h upper layer thickness [m] real(kind=rk), intent(inout) :: ustar friction velocity ice/water interface [m/s] real(kind=rk), intent(in) :: T upper layer temperature [C] real(kind=rk), intent(in) :: S upper layer salinity [g/kg] Contents None","tags":"","loc":"proc/do_stim_basal_melt.html"},{"title":"clean_stim_basal_melt – STIM","text":"public subroutine clean_stim_basal_melt() Arguments None Contents None","tags":"","loc":"proc/clean_stim_basal_melt.html"},{"title":"init_stim_lebedev – STIM","text":"public subroutine init_stim_lebedev(ice_cover) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ice_cover Contents None","tags":"","loc":"proc/init_stim_lebedev.html"},{"title":"do_stim_lebedev – STIM","text":"public subroutine do_stim_lebedev(ice_cover, dt, Tw, S, Ta, precip) Calculate ice thickness according to Lebedev 1938 Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ice_cover real(kind=rk), intent(in) :: dt real(kind=rk), intent(inout) :: Tw real(kind=rk), intent(in) :: S real(kind=rk), intent(in) :: Ta real(kind=rk), intent(in) :: precip Contents None","tags":"","loc":"proc/do_stim_lebedev.html"},{"title":"clean_stim_lebedev – STIM","text":"public subroutine clean_stim_lebedev() Arguments None Contents None","tags":"","loc":"proc/clean_stim_lebedev.html"},{"title":"init_stim_obsice – STIM","text":"public subroutine init_stim_obsice(ice_cover) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ice_cover Contents None","tags":"","loc":"proc/init_stim_obsice.html"},{"title":"do_stim_obsice – STIM","text":"public subroutine do_stim_obsice(ice_cover, Tw, S, Ta) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ice_cover real(kind=rk), intent(inout) :: Tw real(kind=rk), intent(in) :: S real(kind=rk), intent(in) :: Ta Contents None","tags":"","loc":"proc/do_stim_obsice.html"},{"title":"clean_stim_obsice – STIM","text":"public subroutine clean_stim_obsice() Arguments None Contents None","tags":"","loc":"proc/clean_stim_obsice.html"},{"title":"ice – STIM","text":"This module provides the GOTM interface to STIM author: Karsten Bolding Uses stim_models module~~ice~~UsesGraph module~ice ice module~stim_models stim_models module~ice->module~stim_models module~stim_variables stim_variables module~stim_models->module~stim_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables ice_cover ice_model Enumerations Interfaces init_ice post_init_ice do_ice clean_ice Subroutines init_stim_yaml post_init_stim do_stim clean_stim Variables Type Visibility Attributes Name Initial integer, public :: ice_cover = 0 integer, public :: ice_model select ice model to apply Enumerations enum, bind(c) Enumerators enumerator :: SIMPLE = 0 enumerator :: BASAL_MELT = 1 enumerator :: LEBEDEV = 2 enumerator :: MYLAKE = 3 enumerator :: WINTON = 4 Interfaces public interface init_ice private subroutine init_stim_yaml () Initialize configuration via entries in a YAML-file\nUsing the GOTM settings module Arguments None public interface post_init_ice private subroutine post_init_stim (Ta, S) Arguments Type Intent Optional Attributes Name real(kind=selected_real_kind), intent(in) :: Ta Air temperature [C] real(kind=selected_real_kind), intent(in) :: S Salinity [g/kg] public interface do_ice private subroutine do_stim (dz, dt, ustar, Tw, S, Ta, precip, Qsw, Qfluxes) Arguments Arguments Type Intent Optional Attributes Name real(kind=selected_real_kind), intent(inout) :: dz layer thickness [m] real(kind=selected_real_kind), intent(inout) :: dt time step [s] real(kind=selected_real_kind), intent(inout) :: ustar surface friction velocity [m/s] real(kind=selected_real_kind), intent(inout) :: Tw water temperature [C] real(kind=selected_real_kind), intent(inout) :: S salinity [g/kg] real(kind=selected_real_kind), intent(inout) :: Ta air temperature [C] real(kind=selected_real_kind), intent(inout) :: precip precipitation [mm?] real(kind=selected_real_kind), intent(inout) :: Qsw short wave radiation [W/m&#94;2] private subroutine Qfluxes(T, qh, qe, qb) Arguments Type Intent Optional Attributes Name real(kind=selected_real_kind), intent(in) :: T temperature [C] real(kind=selected_real_kind), intent(out) :: qh latent heat [W/m&#94;2] real(kind=selected_real_kind), intent(out) :: qe sensible heat [W/m&#94;2] real(kind=selected_real_kind), intent(out) :: qb net longwave radiation [W/m&#94;2] public interface clean_ice private subroutine clean_stim () De-allocates all memory allocated via init_ice() Arguments None Subroutines private subroutine init_stim_yaml () Initialize configuration via entries in a YAML-file\nUsing the GOTM settings module Arguments None private subroutine post_init_stim (Ta, S) Arguments Type Intent Optional Attributes Name real(kind=selected_real_kind), intent(in) :: Ta Air temperature [C] real(kind=selected_real_kind), intent(in) :: S Salinity [g/kg] private subroutine do_stim (dz, dt, ustar, Tw, S, Ta, precip, Qsw, Qfluxes) Arguments Arguments Type Intent Optional Attributes Name real(kind=selected_real_kind), intent(inout) :: dz layer thickness [m] real(kind=selected_real_kind), intent(inout) :: dt time step [s] real(kind=selected_real_kind), intent(inout) :: ustar surface friction velocity [m/s] real(kind=selected_real_kind), intent(inout) :: Tw water temperature [C] real(kind=selected_real_kind), intent(inout) :: S salinity [g/kg] real(kind=selected_real_kind), intent(inout) :: Ta air temperature [C] real(kind=selected_real_kind), intent(inout) :: precip precipitation [mm?] real(kind=selected_real_kind), intent(inout) :: Qsw short wave radiation [W/m&#94;2] private subroutine Qfluxes(T, qh, qe, qb) Arguments Type Intent Optional Attributes Name real(kind=selected_real_kind), intent(in) :: T temperature [C] real(kind=selected_real_kind), intent(out) :: qh latent heat [W/m&#94;2] real(kind=selected_real_kind), intent(out) :: qe sensible heat [W/m&#94;2] real(kind=selected_real_kind), intent(out) :: qb net longwave radiation [W/m&#94;2] private subroutine clean_stim () De-allocates all memory allocated via init_ice() Arguments None","tags":"","loc":"module/ice.html"},{"title":"stim_variables – STIM","text":"Used by module~~stim_variables~~UsedByGraph module~stim_variables stim_variables module~stim_basal_melt stim_basal_melt module~stim_basal_melt->module~stim_variables module~stim_winton stim_winton module~stim_winton->module~stim_variables module~stim_models stim_models module~stim_models->module~stim_variables module~stim_lebedev stim_lebedev module~stim_lebedev->module~stim_variables module~stim_obsice stim_obsice module~stim_obsice->module~stim_variables module~stim_mylake stim_mylake module~stim_mylake->module~stim_variables module~ice ice module~ice->module~stim_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables rk ice_cord Cw L_ice K_ice lambda_ice rho_ice init_ice_energy surface_ice_energy bottom_ice_energy Tf Tice_surface Tice Hfrazil Hsnow Hice dHis dHib albedo_ice attenuation_ice melt_rate T_melt S_melt ocean_ice_flux ocean_ice_heat_flux ocean_ice_salt_flux transmissivity z0i fdd Subroutines init_stim_variables clean_stim_variables Variables Type Visibility Attributes Name Initial integer, public, parameter :: rk = kind(1.d0) real(kind=rk), public :: ice_cord = 1._rk real(kind=rk), public :: Cw = 4.18e+6_rk volumetric heat capacity of water (J K-1 m-3) real(kind=rk), public :: L_ice = 333500._rk latent heat of freezing (J kg-1) real(kind=rk), public :: K_ice = 2.1_rk ice heat conduction coefficient (W m-1 K-1) real(kind=rk), public :: lambda_ice = 5._rk real(kind=rk), public :: rho_ice = 910._rk kg m-3 real(kind=rk), public :: init_ice_energy = 0._rk real(kind=rk), public, target :: surface_ice_energy = 0._rk real(kind=rk), public, target :: bottom_ice_energy = 0._rk real(kind=rk), public, target :: Tf = 0._rk freezing temperature real(kind=rk), public, target :: Tice_surface = 0._rk real(kind=rk), public, allocatable, target :: Tice (:) real(kind=rk), public, target :: Hfrazil = 0._rk Total frazil ice thickness real(kind=rk), public, target :: Hsnow = 0._rk Total snow thickness real(kind=rk), public, target :: Hice = 0._rk Total ice thickness real(kind=rk), public, target :: dHis = 0._rk surface ice growth real(kind=rk), public, target :: dHib = 0._rk bottom ice growth real(kind=rk), public, target :: albedo_ice = 0._rk real(kind=rk), public, target :: attenuation_ice = 0._rk real(kind=rk), public, target :: melt_rate = 0._rk ice melt rate [m/y] !KB why????? real(kind=rk), public, target :: T_melt = 0._rk melt layer temperature real(kind=rk), public, target :: S_melt = 0._rk melt layer salinity real(kind=rk), public, target :: ocean_ice_flux = 0._rk real(kind=rk), public, target :: ocean_ice_heat_flux = 0._rk upward heat flux [W/m2] real(kind=rk), public, target :: ocean_ice_salt_flux = 0._rk upward salinity flux [(m/s)*(g/kg)] real(kind=rk), public, target :: transmissivity = 1._rk real(kind=rk), public, target :: z0i = 0.01_rk real(kind=rk), public, target :: fdd Subroutines public subroutine init_stim_variables (ice_model) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ice_model public subroutine clean_stim_variables () Arguments None","tags":"","loc":"module/stim_variables.html"},{"title":"stim_models – STIM","text":"Collection of the various ice models in STIM Author: Karsten Bolding Uses stim_variables module~~stim_models~~UsesGraph module~stim_models stim_models module~stim_variables stim_variables module~stim_models->module~stim_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~stim_models~~UsedByGraph module~stim_models stim_models module~ice ice module~ice->module~stim_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/stim_models.html"},{"title":"stim_mylake – STIM","text":"The MyLAKE ice model authors: Karsten Bolding (after ?? and ??) Uses stim_variables module~~stim_mylake~~UsesGraph module~stim_mylake stim_mylake module~stim_variables stim_variables module~stim_mylake->module~stim_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables Tice ice_energy Subroutines init_stim_mylake do_stim_mylake clean_stim_mylake Variables Type Visibility Attributes Name Initial real(kind=rk), private, pointer :: Tice real(kind=rk), private, pointer :: ice_energy Subroutines public subroutine init_stim_mylake () Arguments None public subroutine do_stim_mylake (ice_cover, dz, dt, Tw, S, Ta, precip, Qsw, Qfluxes) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ice_cover real(kind=rk), intent(in) :: dz real(kind=rk), intent(in) :: dt real(kind=rk), intent(inout) :: Tw real(kind=rk), intent(in) :: S real(kind=rk), intent(in) :: Ta real(kind=rk), intent(in) :: precip real(kind=rk), intent(in) :: Qsw private subroutine Qfluxes(T, qh, qe, qb) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: T real(kind=rk), intent(out) :: qh real(kind=rk), intent(out) :: qe real(kind=rk), intent(out) :: qb public subroutine clean_stim_mylake () Arguments None","tags":"","loc":"module/stim_mylake.html"},{"title":"ice_thm_mod – STIM","text":"Used by module~~ice_thm_mod~~UsedByGraph module~ice_thm_mod ice_thm_mod module~stim_winton stim_winton module~stim_winton->module~ice_thm_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables rk LI KS DS KI DI CI SI MU_TS TFI CW DW ALB_SNO ALB_ICE PEN_ICE OPT_DEP_ICE T_RANGE_MELT H_LO_LIM SLAB_ICE CRIT_THICKNESS T_RANGE MIN_ICE_ALB MAX_ICE_ALB ALB_OCEAN CM2_BUGS Functions e_to_melt Subroutines ice_thm_param ice_optics ice3lay_temp thm_checkout add_to_top add_to_bot even_up ice3lay_resize thm_pack thm_unpack Variables Type Visibility Attributes Name Initial integer, private, parameter :: rk = kind(1.d0) real(kind=rk), public :: LI = 334.e3 real(kind=rk), private :: KS = 0.31 real(kind=rk), public, parameter :: DS = 330.0 real(kind=rk), private, parameter :: KI = 2.03 real(kind=rk), public, parameter :: DI = 905.0 real(kind=rk), private, parameter :: CI = 21e2 real(kind=rk), private, parameter :: SI = 1.0 real(kind=rk), public, parameter :: MU_TS = 0.054 real(kind=rk), public, parameter :: TFI = -MU_TS*SI real(kind=rk), private, parameter :: CW = 4.2e3 real(kind=rk), public, parameter :: DW = 1030.0 real(kind=rk), private :: ALB_SNO = 0.85 real(kind=rk), private :: ALB_ICE = 0.5826 real(kind=rk), private :: PEN_ICE = 0.3 real(kind=rk), private :: OPT_DEP_ICE = 0.67 real(kind=rk), private :: T_RANGE_MELT = 1.0 real(kind=rk), private :: H_LO_LIM = 0.0 logical, private :: SLAB_ICE = .false. real(kind=rk), private, parameter :: CRIT_THICKNESS = 1.00 real(kind=rk), private, parameter :: T_RANGE = 10.0 real(kind=rk), private, parameter :: MIN_ICE_ALB = 0.55 real(kind=rk), private, parameter :: MAX_ICE_ALB = 0.80 real(kind=rk), private, parameter :: ALB_OCEAN = 0.10 logical, private :: CM2_BUGS = .false. Functions public function e_to_melt (hs, h1, t1, h2, t2) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), optional :: hs real(kind=rk), intent(in), optional :: h1 real(kind=rk), intent(in), optional :: t1 real(kind=rk), intent(in), optional :: h2 real(kind=rk), intent(in), optional :: t2 Return Value real(kind=rk) Subroutines public subroutine ice_thm_param (alb_sno_in, alb_ice_in, pen_ice_in, opt_dep_ice_in, slab_ice_in, t_range_melt_in, cm2_bugs_in, ks_in, h_lo_lim_in) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: alb_sno_in real(kind=rk), intent(in) :: alb_ice_in real(kind=rk), intent(in) :: pen_ice_in real(kind=rk), intent(in) :: opt_dep_ice_in logical, intent(in) :: slab_ice_in real(kind=rk), intent(in) :: t_range_melt_in logical, intent(in) :: cm2_bugs_in real(kind=rk), intent(in) :: ks_in real(kind=rk), intent(in) :: h_lo_lim_in public subroutine ice_optics (alb, pen, trn, hs, hi, ts, tfw) check for ice albdeos out of range (0 to 1) Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(out) :: alb real(kind=rk), intent(out) :: pen real(kind=rk), intent(out) :: trn real(kind=rk), intent(in) :: hs real(kind=rk), intent(in) :: hi real(kind=rk), intent(in) :: ts real(kind=rk), intent(in) :: tfw public subroutine ice3lay_temp (hs, hi, t1, t2, ts, A, B, I, tfw, fb, dt, tmelt, bmelt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: hs real(kind=rk), intent(in) :: hi real(kind=rk), intent(inout) :: t1 real(kind=rk), intent(inout) :: t2 real(kind=rk), intent(out) :: ts real(kind=rk), intent(in) :: A real(kind=rk), intent(in) :: B real(kind=rk), intent(in) :: I real(kind=rk), intent(in) :: tfw real(kind=rk), intent(in) :: fb real(kind=rk), intent(in) :: dt real(kind=rk), intent(inout) :: tmelt real(kind=rk), intent(inout) :: bmelt private subroutine thm_checkout (ts, hs, hi, t1, t2, bmelt, tmelt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: ts real(kind=rk), intent(in) :: hs real(kind=rk), intent(in) :: hi real(kind=rk), intent(in) :: t1 real(kind=rk), intent(in) :: t2 real(kind=rk), intent(in) :: bmelt real(kind=rk), intent(in) :: tmelt private subroutine add_to_top (h, t, h1, t1) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: h real(kind=rk), intent(in) :: t real(kind=rk), intent(inout) :: h1 real(kind=rk), intent(inout) :: t1 private subroutine add_to_bot (h, t, h2, t2) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: h real(kind=rk), intent(in) :: t real(kind=rk), intent(inout) :: h2 real(kind=rk), intent(inout) :: t2 private subroutine even_up (h1, t1, h2, t2) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: h1 real(kind=rk), intent(inout) :: t1 real(kind=rk), intent(inout) :: h2 real(kind=rk), intent(inout) :: t2 public subroutine ice3lay_resize (hs, hi, t1, t2, snow, frazil, evap, tmelt, bmelt, tfw, heat_to_ocn, h2o_to_ocn, h2o_from_ocn, snow_to_ice, bablt) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout) :: hs real(kind=rk), intent(inout) :: hi real(kind=rk), intent(inout) :: t1 real(kind=rk), intent(inout) :: t2 real(kind=rk), intent(in) :: snow real(kind=rk), intent(in) :: frazil real(kind=rk), intent(in) :: evap real(kind=rk), intent(in) :: tmelt real(kind=rk), intent(in) :: bmelt real(kind=rk), intent(in) :: tfw real(kind=rk), intent(out) :: heat_to_ocn real(kind=rk), intent(out) :: h2o_to_ocn real(kind=rk), intent(out) :: h2o_from_ocn real(kind=rk), intent(out) :: snow_to_ice real(kind=rk), intent(out), optional :: bablt public subroutine thm_pack (cn, hs, hi, t1, t2) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout), dimension(:,:,:) :: cn real(kind=rk), intent(inout), dimension(:,:,:) :: hs real(kind=rk), intent(inout), dimension(:,:,:) :: hi real(kind=rk), intent(inout), dimension(:,:,:) :: t1 real(kind=rk), intent(inout), dimension(:,:,:) :: t2 public subroutine thm_unpack (cn, hs, hi, t1, t2) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(inout), dimension(:,:,:) :: cn real(kind=rk), intent(inout), dimension(:,:,:) :: hs real(kind=rk), intent(inout), dimension(:,:,:) :: hi real(kind=rk), intent(inout), dimension(:,:,:) :: t1 real(kind=rk), intent(inout), dimension(:,:,:) :: t2","tags":"","loc":"module/ice_thm_mod.html"},{"title":"stim_winton – STIM","text":"The winton ice model After Michael Winton authors: Karsten Bolding, Adolf Stips and Jesper Larsen The model consists of a zero heat capacity snow layer overlying two equally\n  thick sea ice layers. The upper ice layer has a variable heat capacity to\n  represent brine pockets. The lower ice layer has a fixed heat capacity.\n  The prognostic variables are hs (snow layer thickness), hi (ice layer\n  thickness), T1 and T2, the upper and lower ice layer temperatures located\n  at the midpoints of the layers. The ice model performs two functions, the\n  first is to calculate the ice temperature and the second is to calculate\n  changes in the thickness of ice and snow. THREE-LAYER VERTICAL THERMODYNAMICS Reference:  M. Winton, 2000: \"A reformulated three-layer sea ice model\", Journal of Atmospheric and Oceanic Technology, 17, 525-531. -> +---------+ <- Ts - diagnostic surface temperature ( <= 0 C ) / | | hs | snow | <- 0 - heat capacity snow layer \\ | | -> +---------+ / | | / | | <- T1 - upper 1 / 2 ice temperature ; this layer has / | | a variable ( T / S dependent ) heat capacity \\ | | \\ | | <- T2 - lower 1 / 2 ice temp . ( fixed heat capacity ) \\ | | -> +---------+ <- Tf - base of ice fixed at seawater freezing temp . Mike Winton ( mw @ gfdl . gov ) Note: in this implementation the equations are multiplied by hi to improve\n  thin ice accuracy The code is based on the open source sea ice model included in the Modular\n  Ocean Model. Uses ice_thm_mod stim_variables module~~stim_winton~~UsesGraph module~stim_winton stim_winton module~stim_variables stim_variables module~stim_winton->module~stim_variables module~ice_thm_mod ice_thm_mod module~stim_winton->module~ice_thm_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables Ts T1 T2 hi hs dh1 dh2 trn pen tmelt bmelt fb Subroutines init_stim_winton do_stim_winton Variables Type Visibility Attributes Name Initial real(kind=rk), private, pointer :: Ts real(kind=rk), private, pointer :: T1 real(kind=rk), private, pointer :: T2 real(kind=rk), private, pointer :: hi real(kind=rk), private, pointer :: hs real(kind=rk), private, pointer :: dh1 real(kind=rk), private, pointer :: dh2 real(kind=rk), private, pointer :: trn real(kind=rk), private :: pen real(kind=rk), private, pointer :: tmelt real(kind=rk), private, pointer :: bmelt real(kind=rk), private, pointer :: fb Subroutines public subroutine init_stim_winton (Ta) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: Ta Air temperature [C] public subroutine do_stim_winton (ice_cover, dz, dt, Tw, S, Ta, precip, Qsw, Qfluxes) This SUBROUTINE updates the sea ice prognostic variables. The updated\nvariables are upper ice layer temperature (T1), lower ice layer temperature\n(T2), snow thickness (hs), and ice thickness (hi). Read more… Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ice_cover real(kind=rk), intent(in) :: dz real(kind=rk), intent(in) :: dt real(kind=rk), intent(inout) :: Tw real(kind=rk), intent(in) :: S real(kind=rk), intent(in) :: Ta real(kind=rk), intent(in) :: precip real(kind=rk), intent(in) :: Qsw private subroutine Qfluxes(T, qh, qe, qb) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: T real(kind=rk), intent(out) :: qh real(kind=rk), intent(out) :: qe real(kind=rk), intent(out) :: qb","tags":"","loc":"module/stim_winton.html"},{"title":"stim_basal_melt – STIM","text":"The basal_melt ice model authors: Hans Burchard and Karsten Bolding Uses stim_variables module~~stim_basal_melt~~UsesGraph module~stim_basal_melt stim_basal_melt module~stim_variables stim_variables module~stim_basal_melt->module~stim_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines init_stim_basal_melt do_stim_basal_melt clean_stim_basal_melt Subroutines public subroutine init_stim_basal_melt (ice_cover) Initialize the basal_melt model with an ice-cover Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ice_cover public subroutine do_stim_basal_melt (h, ustar, T, S) melt layer salinity\nmelt layer temperature Read more… Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: h upper layer thickness [m] real(kind=rk), intent(inout) :: ustar friction velocity ice/water interface [m/s] real(kind=rk), intent(in) :: T upper layer temperature [C] real(kind=rk), intent(in) :: S upper layer salinity [g/kg] public subroutine clean_stim_basal_melt () Arguments None","tags":"","loc":"module/stim_basal_melt.html"},{"title":"stim_lebedev – STIM","text":"The Lebedev ice model authors: Adolf Stips and Karsten Bolding https://agupubs.onlinelibrary.wiley.com/doi/10.1002/2016JC012199 Constants provided by Adolf Stips Uses stim_variables module~~stim_lebedev~~UsesGraph module~stim_lebedev stim_lebedev module~stim_variables stim_variables module~stim_lebedev->module~stim_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables lebedev_fac damp_leb_swr damp_leb_wind damp_leb_shf freeze_fac lebedev_albedo Subroutines init_stim_lebedev do_stim_lebedev clean_stim_lebedev Variables Type Visibility Attributes Name Initial real(kind=rk), private :: lebedev_fac = 1.33_rk real(kind=rk), private :: damp_leb_swr = -1.6_rk real(kind=rk), private :: damp_leb_wind = -1.6_rk real(kind=rk), private :: damp_leb_shf = -1.6_rk real(kind=rk), private :: freeze_fac = -0.0575_rk real(kind=rk), private :: lebedev_albedo = 0.545 Subroutines public subroutine init_stim_lebedev (ice_cover) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ice_cover public subroutine do_stim_lebedev (ice_cover, dt, Tw, S, Ta, precip) Calculate ice thickness according to Lebedev 1938 Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ice_cover real(kind=rk), intent(in) :: dt real(kind=rk), intent(inout) :: Tw real(kind=rk), intent(in) :: S real(kind=rk), intent(in) :: Ta real(kind=rk), intent(in) :: precip public subroutine clean_stim_lebedev () Arguments None","tags":"","loc":"module/stim_lebedev.html"},{"title":"stim_obsice – STIM","text":"Uses stim_variables module~~stim_obsice~~UsesGraph module~stim_obsice stim_obsice module~stim_variables stim_variables module~stim_obsice->module~stim_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines init_stim_obsice do_stim_obsice clean_stim_obsice Subroutines public subroutine init_stim_obsice (ice_cover) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ice_cover public subroutine do_stim_obsice (ice_cover, Tw, S, Ta) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ice_cover real(kind=rk), intent(inout) :: Tw real(kind=rk), intent(in) :: S real(kind=rk), intent(in) :: Ta public subroutine clean_stim_obsice () Arguments None","tags":"","loc":"module/stim_obsice.html"}]}