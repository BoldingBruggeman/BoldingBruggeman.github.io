var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program Hi, my name is kb. This is a project which I wrote. This file will provide the documents. I'm\nwriting the body of the text here. It contains an overall description of the\nproject. It might explain how to go about installing/compiling it. It might\nprovide a change-log for the code. linalg Maybe it will talk about the\nhistory and/or motivation for this software. Note You can include any notes (or bugs, warnings, or todos) like so. Bug You can have multi-paragraph versions of these too! That means you can\ninclude ordered lists unordered lists images etc. Isn't that cool? Bug Hey I'm doing it again... This ones ends mid... ...paragraph. You can have as many paragraphs as you like here and can use headlines, links,\nimages, etc. Basically, you can use anything in Markdown and Markdown-Extra.\nFurthermore, you can insert LaTeX into your documentation. So, for example,\nyou can provide inline math using like y = x&#94;2 or math on its own line\nlike x = \\sqrt{y} or e = mc&#94;2. You can even use LaTeX environments!\nSo you can get numbered equations like this: \\begin{equation}\n  PV = nRT\n\\end{equation} So let your imagination run wild. As you can tell, I'm more or less just\nfilling in space now. This will be the last sentence. Developer Info Jorn Bruggeman I program stuff in Fortran.","tags":"home","loc":"index.html"},{"title":"field_manager.F90 – Fortran Program","text":"Files dependent on this one sourcefile~~field_manager.f90~~AfferentGraph sourcefile~field_manager.f90 field_manager.F90 sourcefile~text_output.f90 text_output.F90 sourcefile~text_output.f90->sourcefile~field_manager.f90 sourcefile~output_manager_core.f90 output_manager_core.F90 sourcefile~text_output.f90->sourcefile~output_manager_core.f90 sourcefile~interp.f90 interp.F90 sourcefile~interp.f90->sourcefile~field_manager.f90 sourcefile~base.f90 base.F90 sourcefile~interp.f90->sourcefile~base.f90 sourcefile~interp.f90->sourcefile~output_manager_core.f90 sourcefile~base.f90->sourcefile~field_manager.f90 sourcefile~base.f90->sourcefile~output_manager_core.f90 sourcefile~output_manager.f90 output_manager.F90 sourcefile~output_manager.f90->sourcefile~field_manager.f90 sourcefile~output_manager.f90->sourcefile~text_output.f90 sourcefile~slice.f90 slice.F90 sourcefile~output_manager.f90->sourcefile~slice.f90 sourcefile~library.f90 library.F90 sourcefile~output_manager.f90->sourcefile~library.f90 sourcefile~time_average.f90 time_average.F90 sourcefile~output_manager.f90->sourcefile~time_average.f90 sourcefile~output_manager.f90->sourcefile~output_manager_core.f90 sourcefile~netcdf_output.f90 netcdf_output.F90 sourcefile~output_manager.f90->sourcefile~netcdf_output.f90 sourcefile~slice.f90->sourcefile~field_manager.f90 sourcefile~slice.f90->sourcefile~base.f90 sourcefile~slice.f90->sourcefile~output_manager_core.f90 sourcefile~library.f90->sourcefile~field_manager.f90 sourcefile~library.f90->sourcefile~interp.f90 sourcefile~library.f90->sourcefile~base.f90 sourcefile~library.f90->sourcefile~slice.f90 sourcefile~library.f90->sourcefile~time_average.f90 sourcefile~library.f90->sourcefile~output_manager_core.f90 sourcefile~time_average.f90->sourcefile~field_manager.f90 sourcefile~time_average.f90->sourcefile~base.f90 sourcefile~time_average.f90->sourcefile~output_manager_core.f90 sourcefile~output_manager_core.f90->sourcefile~field_manager.f90 sourcefile~netcdf_output.f90->sourcefile~field_manager.f90 sourcefile~netcdf_output.f90->sourcefile~output_manager_core.f90 var pansourcefilefield_managerf90AfferentGraph = svgPanZoom('#sourcefilefield_managerf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules field_manager Source Code field_manager.F90 Source Code module field_manager use iso_fortran_env , only : error_unit implicit none ! Public subroutine and functions public type_field_manager ! Public data types and variables public type_field public type_category_node public type_dimension , type_dimension_pointer , has_dimension public type_attribute , type_real_attribute , type_integer_attribute , type_string_attribute , type_attributes public type_field_set , type_field_set_member public type_nd_data_pointer ! Public parameters public string_length , default_fill_value , default_minimum , default_maximum private integer , parameter :: string_length = 256 integer , parameter :: nmaxdims = 10 integer , parameter :: rk = kind ( _ ONE_ ) integer , parameter , public :: id_dim_lon = 1 integer , parameter , public :: id_dim_lat = 2 integer , parameter , public :: id_dim_z = 3 integer , parameter , public :: id_dim_zi = 4 integer , parameter , public :: id_dim_time = 5 integer , parameter , public :: id_dim_unused = 20 ! First free id for user-specified dimensions integer , parameter , public :: status_not_registered = 0 integer , parameter , public :: status_registered_no_data = 1 integer , parameter , public :: status_registered_with_data = 2 integer , parameter , public :: output_level_none = 0 integer , parameter , public :: output_level_required = 2 integer , parameter , public :: output_level_default = 8 integer , parameter , public :: output_level_debug = 32 real ( rk ), parameter :: default_fill_value = - huge ( _ ONE_ ) real ( rk ), parameter :: default_minimum = default_fill_value + spacing ( default_fill_value ) real ( rk ), parameter :: default_maximum = huge ( _ ONE_ ) type type_dimension character ( len = string_length ) :: name = '' character ( len = string_length ) :: iterator = '' integer :: length = - 1 integer :: global_length = - 1 integer :: offset = 0 integer :: id = - 1 type ( type_field ), pointer :: coordinate => null () type ( type_dimension ), pointer :: next => null () end type type type_dimension_pointer type ( type_dimension ), pointer :: p => null () end type type type_attribute character ( len = string_length ) :: name = '' class ( type_attribute ), pointer :: next => null () end type type , extends ( type_attribute ) :: type_real_attribute real ( rk ) :: value = 0.0_rk end type type , extends ( type_attribute ) :: type_integer_attribute integer :: value = 0 end type type , extends ( type_attribute ) :: type_string_attribute character ( len = string_length ) :: value = '' end type type type_attributes class ( type_attribute ), pointer :: first => null () contains procedure :: set_object => attributes_set_object procedure :: delete => attributes_delete procedure :: set_real => attributes_set_real procedure :: set_integer => attributes_set_integer procedure :: set_string => attributes_set_string generic :: set => set_real , set_integer , set_string , set_object procedure :: update => attributes_update end type type type_nd_data_pointer real ( rk ), pointer :: p0d => null () real ( rk ), pointer :: p1d (:) => null () real ( rk ), pointer :: p2d (:,:) => null () real ( rk ), pointer :: p3d (:,:,:) => null () contains procedure :: set_0d => data_set_0d procedure :: set_1d => data_set_1d procedure :: set_2d => data_set_2d procedure :: set_3d => data_set_3d generic :: set => set_0d , set_1d , set_2d , set_3d procedure :: get_extents => data_get_extents procedure :: is_empty => data_is_empty end type type type_field integer :: id = 0 character ( len = string_length ) :: name = '' character ( len = string_length ) :: units = '' character ( len = string_length ) :: long_name = '' character ( len = string_length ) :: standard_name = '' real ( rk ) :: fill_value = default_fill_value real ( rk ) :: minimum = default_minimum real ( rk ) :: maximum = default_maximum integer :: output_level = output_level_default logical :: in_output = . false . logical , pointer :: used_now => null () integer :: status = status_not_registered type ( type_dimension_pointer ), allocatable :: dimensions (:) type ( type_attributes ) :: attributes integer , allocatable :: extents (:) type ( type_nd_data_pointer ) :: data class ( type_category_node ), pointer :: category => null () type ( type_field ), pointer :: next => null () contains procedure :: has_dimension => field_has_dimension procedure :: finalize => field_finalize ! For backward compatibility - direct access to \"attributes\" now possible procedure :: field_set_real_attribute generic :: set_attribute => field_set_real_attribute end type type_field type , abstract :: type_node class ( type_node ), pointer :: parent => null () class ( type_node ), pointer :: first_child => null () class ( type_node ), pointer :: next_sibling => null () contains procedure :: finalize => node_finalize end type type , extends ( type_node ) :: type_field_node type ( type_field ), pointer :: field => null () end type type , extends ( type_node ) :: type_category_node character ( len = string_length ) :: name = '' integer :: output_level = output_level_none contains procedure :: get_all_fields procedure :: has_fields procedure :: get_path => category_get_path end type integer , parameter :: hash_table_size = 256 type type_dictionary_bin type ( type_field ), pointer :: first_field => null () end type type type_field_set_member type ( type_field ), pointer :: field => null () type ( type_field_set_member ), pointer :: next => null () end type type type_field_set type ( type_field_set_member ), pointer :: first => null () contains procedure :: add => field_set_add procedure :: finalize => field_set_finalize end type type type_field_manager type ( type_dimension ), pointer :: first_dimension => null () type ( type_dimension_pointer ), allocatable :: prepend_dimensions (:) type ( type_dimension_pointer ), allocatable :: append_dimensions (:) type ( type_dictionary_bin ) :: field_table ( hash_table_size ) type ( type_category_node ) :: root integer :: nregistered = 0 contains procedure :: initialize procedure :: finalize procedure :: register procedure :: find procedure :: list procedure :: send_data_0d procedure :: send_data_1d procedure :: send_data_2d procedure :: send_data_3d procedure :: send_data_by_name_0d procedure :: send_data_by_name_1d procedure :: send_data_by_name_2d procedure :: send_data_by_name_3d procedure :: select_for_output procedure :: select_category_for_output procedure :: register_dimension procedure :: find_dimension procedure :: find_category procedure :: get_state procedure :: reset_used generic :: send_data => send_data_0d , send_data_1d , send_data_2d , send_data_3d , send_data_by_name_0d , send_data_by_name_1d , send_data_by_name_2d , send_data_by_name_3d end type type_field_manager contains subroutine register_dimension ( self , name , length , global_length , offset , id , newid ) class ( type_field_manager ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name integer , optional , intent ( in ) :: length integer , optional , intent ( in ) :: global_length integer , optional , intent ( in ) :: offset integer , optional , intent ( in ) :: id integer , optional , intent ( out ) :: newid type ( type_dimension ), pointer :: dim if ( name == '' ) call fatal_error ( 'register_dimension' , 'dimension name cannot be empty' ) ! Check whether dimension has already been registered. dim => self % first_dimension do while ( associated ( dim )) if ( dim % name == name ) call fatal_error ( 'register_dimension' , 'dimension \"' // trim ( name ) // '\" has already been registered.' ) if ( present ( id )) then if ( dim % id == id ) call fatal_error ( 'register_dimension' , 'id specified for dimension ' // trim ( name ) // ' has already been assigned to ' // trim ( dim % name ) // '.' ) end if dim => dim % next end do ! Create dimension object allocate ( dim ) dim % name = name if ( present ( length )) dim % length = length if ( present ( offset )) dim % offset = offset if ( present ( id )) then dim % id = id elseif ( present ( newid )) then newid = next_free_dimension_id ( self ) dim % id = newid end if dim % global_length = dim % length if ( present ( global_length )) dim % global_length = global_length select case ( dim % id ) case ( id_dim_lon ) dim % iterator = 'i' case ( id_dim_lat ) dim % iterator = 'j' case ( id_dim_z ) dim % iterator = 'k' case ( id_dim_zi ) dim % iterator = 'k1' end select ! Basic consistency checks if ( dim % length <- 1 ) call fatal_error ( 'register_dimension' , 'length for dimension ' // trim ( dim % name ) // ' must be -1 (unlimited) or more' ) #if 0 if ( dim % offset < 0 ) call fatal_error ( 'register_dimension' , 'offset for dimension ' // trim ( dim % name ) // ' must be 0 or more' ) #endif ! Prepend to dimension list. dim % next => self % first_dimension self % first_dimension => dim end subroutine register_dimension integer function next_free_dimension_id ( self ) class ( type_field_manager ), intent ( in ) :: self type ( type_dimension ), pointer :: dim next_free_dimension_id = id_dim_unused do dim => self % first_dimension do while ( associated ( dim )) if ( dim % id == next_free_dimension_id ) exit dim => dim % next end do if (. not . associated ( dim )) return next_free_dimension_id = next_free_dimension_id + 1 end do end function next_free_dimension_id subroutine initialize ( self , prepend_by_default , append_by_default ) class ( type_field_manager ), intent ( inout ) :: self integer , optional , intent ( in ) :: prepend_by_default (:), append_by_default (:) integer :: i if ( present ( prepend_by_default )) then allocate ( self % prepend_dimensions ( size ( prepend_by_default ))) do i = 1 , size ( prepend_by_default ) self % prepend_dimensions ( i )% p => find_dimension ( self , prepend_by_default ( i )) if (. not . associated ( self % prepend_dimensions ( i )% p )) call fatal_error ( 'initialize' , 'Auto-prepend dimension has not been registered yet.' ) end do else allocate ( self % prepend_dimensions ( 0 )) end if if ( present ( append_by_default )) then allocate ( self % append_dimensions ( size ( append_by_default ))) do i = 1 , size ( append_by_default ) self % append_dimensions ( i )% p => find_dimension ( self , append_by_default ( i )) if (. not . associated ( self % append_dimensions ( i )% p )) call fatal_error ( 'initialize' , 'Auto-append dimension has not been registered yet.' ) end do else allocate ( self % append_dimensions ( 0 )) end if end subroutine initialize subroutine list ( self ) class ( type_field_manager ), intent ( in ) :: self character ( 256 ) :: line integer :: ibin type ( type_field ), pointer :: field write ( line , '(A8,4x,A12,4x,A40)' ) 'name' , 'unit' , adjustl ( 'long_name' ) write ( * , * ) trim ( line ) write ( line , '(A68)' ) '----------------------------------------------------------------' write ( * , * ) trim ( line ) do ibin = 1 , hash_table_size field => self % field_table ( ibin )% first_field do while ( associated ( field )) write ( line , '(I2,2x,A15,2x,A15,2x,A45)' ) field % id , adjustl ( field % name ), adjustl ( field % units ), adjustl ( field % long_name ) write ( * , * ) trim ( line ) !KB         write(*,*) field%dimensions field => field % next end do end do write ( * , * ) 'field tree:' call list_node ( self % root , 1 ) stop 'field_manager::list()' end subroutine list recursive subroutine list_node ( category , depth ) type ( type_category_node ), intent ( in ) :: category integer , intent ( in ) :: depth class ( type_node ), pointer :: node node => category % first_child do while ( associated ( node )) select type ( node ) class is ( type_category_node ) write ( * , * ) repeat ( '  ' , depth ) // trim ( node % name ) call list_node ( node , depth + 1 ) class is ( type_field_node ) write ( * , * ) repeat ( '  ' , depth ) // trim ( node % field % name ) end select node => node % next_sibling end do end subroutine list_node subroutine finalize ( self ) class ( type_field_manager ), intent ( inout ) :: self integer :: ibin type ( type_field ), pointer :: field , next_field type ( type_dimension ), pointer :: dim , next_dim do ibin = 1 , hash_table_size field => self % field_table ( ibin )% first_field do while ( associated ( field )) next_field => field % next call field % finalize () deallocate ( field ) field => next_field end do self % field_table ( ibin )% first_field => null () end do dim => self % first_dimension do while ( associated ( dim )) next_dim => dim % next deallocate ( dim ) dim => next_dim end do self % first_dimension => null () call self % root % finalize () if ( allocated ( self % prepend_dimensions )) deallocate ( self % prepend_dimensions ) if ( allocated ( self % append_dimensions )) deallocate ( self % append_dimensions ) self % nregistered = 0 end subroutine finalize subroutine reset_used ( self ) class ( type_field_manager ), intent ( inout ) :: self integer :: ibin type ( type_field ), pointer :: field do ibin = 1 , hash_table_size field => self % field_table ( ibin )% first_field do while ( associated ( field )) if ( associated ( field % used_now )) field % used_now = . false . field => field % next end do end do end subroutine reset_used function find_dimension ( self , dimid ) result ( dim ) class ( type_field_manager ), intent ( in ) :: self integer , intent ( in ) :: dimid type ( type_dimension ), pointer :: dim dim => self % first_dimension do while ( associated ( dim )) if ( dim % id == dimid ) return dim => dim % next end do end function find_dimension function select_for_output ( self , name ) result ( field ) class ( type_field_manager ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name type ( type_field ), pointer :: field field => self % find ( name , create = . true .) field % in_output = . true . end function select_for_output function select_category_for_output ( self , name , output_level ) result ( category ) class ( type_field_manager ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: output_level class ( type_category_node ), pointer :: category category => self % find_category ( name , create = . true .) call activate ( category ) contains recursive subroutine activate ( category ) type ( type_category_node ), intent ( inout ) :: category class ( type_node ), pointer :: child category % output_level = max ( category % output_level , output_level ) child => category % first_child do while ( associated ( child )) select type ( child ) class is ( type_category_node ) call activate ( child ) end select child => child % next_sibling end do end subroutine activate end function select_category_for_output subroutine field_set_add ( self , field ) class ( type_field_set ), intent ( inout ) :: self type ( type_field ), target :: field type ( type_field_set_member ), pointer :: member type ( type_field_set_member ), pointer :: last last => null () member => self % first do while ( associated ( member )) if ( associated ( member % field , field )) return last => member member => member % next end do allocate ( member ) member % field => field if ( associated ( last )) then last % next => member else self % first => member end if end subroutine field_set_add subroutine field_set_finalize ( self ) class ( type_field_set ), intent ( inout ) :: self type ( type_field_set_member ), pointer :: member , next_member member => self % first do while ( associated ( member )) next_member => member % next deallocate ( member ) member => next_member end do self % first => null () end subroutine field_set_finalize recursive subroutine get_all_fields ( self , set , output_level ) class ( type_category_node ), intent ( inout ) :: self type ( type_field_set ), intent ( inout ) :: set integer , intent ( in ) :: output_level class ( type_node ), pointer :: child child => self % first_child do while ( associated ( child )) select type ( child ) class is ( type_category_node ) call get_all_fields ( child , set , output_level ) class is ( type_field_node ) if ( child % field % output_level <= output_level ) call set % add ( child % field ) end select child => child % next_sibling end do end subroutine get_all_fields recursive logical function has_fields ( self ) class ( type_category_node ), intent ( inout ) :: self class ( type_node ), pointer :: child has_fields = . true . child => self % first_child do while ( associated ( child )) select type ( child ) class is ( type_category_node ) if ( child % has_fields ()) return class is ( type_field_node ) return end select child => child % next_sibling end do has_fields = . false . end function has_fields function find ( self , name , create ) result ( field ) class ( type_field_manager ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name logical , optional , intent ( in ) :: create type ( type_field ), pointer :: field integer :: ibin logical :: create_eff ibin = mod ( hash ( trim ( name )), hash_table_size ) + 1 field => self % field_table ( ibin )% first_field do while ( associated ( field )) if ( field % name == name ) return field => field % next end do create_eff = . false . if ( present ( create )) create_eff = create if ( create_eff ) then allocate ( field ) field % name = name field % next => self % field_table ( ibin )% first_field self % field_table ( ibin )% first_field => field end if end function find subroutine register ( self , name , units , long_name , standard_name , fill_value , minimum , maximum , dimensions , data0d , data1d , data2d , data3d , no_default_dimensions , category , output_level , coordinate_dimension , part_of_state , used , used_now , field ) class ( type_field_manager ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name , units , long_name character ( len =* ), optional , intent ( in ) :: standard_name real ( rk ), optional , intent ( in ) :: fill_value , minimum , maximum integer , optional , intent ( in ) :: dimensions (:) real ( rk ), optional , target :: data0d , data1d (:), data2d (:,:), data3d (:,:,:) logical , optional , intent ( in ) :: no_default_dimensions character ( len =* ), optional , intent ( in ) :: category integer , optional , intent ( in ) :: output_level integer , optional , intent ( in ) :: coordinate_dimension logical , optional , intent ( in ) :: part_of_state logical , optional , intent ( out ) :: used logical , target , optional :: used_now type ( type_field ), optional , pointer :: field type ( type_field ), pointer :: field_ type ( type_dimension ), pointer :: dim logical :: no_default_dimensions_ integer :: i , n if ( name == '' ) call fatal_error ( 'field_manager%register' , 'name cannot be empty.' ) if ( long_name == '' ) call fatal_error ( 'field_manager%register' , 'long_name cannot be empty.' ) ! Find existing field_ (a placeholder with status_not_registered may have been created by a call to select_for_output) or create new one. field_ => self % find ( name , create = . true .) if ( field_ % status > status_not_registered ) call fatal_error ( 'field_manager%register' , 'field with name \"' // trim ( name ) // '\" has already been registered.' ) field_ % status = status_registered_no_data ! Increment number of registered fields self % nregistered = self % nregistered + 1 ! Copy field_ configuration field_ % id = self % nregistered field_ % name = name field_ % units = units field_ % long_name = long_name if ( present ( standard_name )) field_ % standard_name = standard_name if ( present ( fill_value )) field_ % fill_value = fill_value if ( present ( minimum )) field_ % minimum = minimum if ( present ( maximum )) field_ % maximum = maximum if ( present ( output_level )) field_ % output_level = output_level if ( present ( coordinate_dimension )) then dim => find_dimension ( self , coordinate_dimension ) if (. not . associated ( dim )) call fatal_error ( 'field_manager%register' , 'coordinate dimension of variable ' // trim ( field_ % name ) // ' has not been registered yet.' ) dim % coordinate => field_ end if no_default_dimensions_ = . false . if ( present ( no_default_dimensions )) no_default_dimensions_ = no_default_dimensions if ( no_default_dimensions_ ) then ! Use actual provided dimensions only (no prepend/append) if ( present ( dimensions )) then allocate ( field_ % dimensions ( size ( dimensions ))) do i = 1 , size ( dimensions ) field_ % dimensions ( i )% p => find_dimension ( self , dimensions ( i )) if (. not . associated ( field_ % dimensions ( i )% p )) & call fatal_error ( 'field_manager%register' , 'Dimension of variable ' // trim ( field_ % name ) // ' has not been registered yet.' ) end do else allocate ( field_ % dimensions ( 0 )) end if else ! Also prepend/append implicit dimensions if ( present ( dimensions )) then allocate ( field_ % dimensions ( size ( self % prepend_dimensions ) + size ( dimensions ) + size ( self % append_dimensions ))) do i = 1 , size ( dimensions ) field_ % dimensions ( size ( self % prepend_dimensions ) + i )% p => find_dimension ( self , dimensions ( i )) if (. not . associated ( field_ % dimensions ( size ( self % prepend_dimensions ) + i )% p )) & call fatal_error ( 'field_manager%register' , 'Dimension of variable ' // trim ( field_ % name ) // ' has not been registered yet.' ) end do else allocate ( field_ % dimensions ( size ( self % prepend_dimensions ) + size ( self % append_dimensions ))) end if field_ % dimensions (: size ( self % prepend_dimensions )) = self % prepend_dimensions field_ % dimensions ( size ( field_ % dimensions ) - size ( self % append_dimensions ) + 1 :) = self % append_dimensions end if ! Determine extents of field_ (excluding singleton dimensions) n = 0 do i = 1 , size ( field_ % dimensions ) if ( field_ % dimensions ( i )% p % length > 1 ) n = n + 1 end do allocate ( field_ % extents ( n )) n = 0 do i = 1 , size ( field_ % dimensions ) if ( field_ % dimensions ( i )% p % length > 1 ) then n = n + 1 field_ % extents ( n ) = field_ % dimensions ( i )% p % length end if end do call add_field_to_tree ( self , field_ , category ) if ( present ( part_of_state )) then if ( part_of_state ) call add_field_to_tree ( self , field_ , 'state' ) end if ! Note: the \"in_output\" flag can have been set by a call to select_for_output (typically from the output manager), ! even before the actual variable is registered with the field_ manager. if ( present ( used )) used = field_ % in_output if ( present ( used_now )) then field_ % used_now => used_now used_now = field_ % in_output end if if ( present ( data0d )) call self % send_data_0d ( field_ , data0d ) if ( present ( data1d )) call self % send_data_1d ( field_ , data1d ) if ( present ( data2d )) call self % send_data_2d ( field_ , data2d ) if ( present ( data3d )) call self % send_data_3d ( field_ , data3d ) if ( present ( field )) field => field_ end subroutine register logical function has_dimension ( dimensions , id ) type ( type_dimension_pointer ), intent ( in ) :: dimensions (:) integer , intent ( in ) :: id integer :: i has_dimension = . true . do i = 1 , size ( dimensions ) if ( dimensions ( i )% p % id == id ) return end do has_dimension = . false . end function has_dimension logical function field_has_dimension ( self , id ) class ( type_field ), intent ( in ) :: self integer , intent ( in ) :: id field_has_dimension = has_dimension ( self % dimensions , id ) end function field_has_dimension subroutine attributes_delete ( self , name ) class ( type_attributes ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name class ( type_attribute ), pointer :: attribute , previous_attribute previous_attribute => null () attribute => self % first do while ( associated ( attribute )) if ( attribute % name == name ) then if ( associated ( previous_attribute )) then previous_attribute % next => attribute % next else self % first => attribute % next end if deallocate ( attribute ) return end if previous_attribute => attribute attribute => attribute % next end do end subroutine attributes_delete subroutine attributes_set_object ( self , name , attribute ) class ( type_attributes ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name class ( type_attribute ), intent ( inout ), target :: attribute call self % delete ( name ) attribute % name = name attribute % next => self % first self % first => attribute end subroutine attributes_set_object subroutine attributes_set_real ( self , name , value ) class ( type_attributes ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name real ( rk ), intent ( in ) :: value class ( type_real_attribute ), pointer :: attribute allocate ( attribute ) attribute % value = value call self % set ( name , attribute ) end subroutine attributes_set_real subroutine attributes_set_integer ( self , name , value ) class ( type_attributes ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: value class ( type_integer_attribute ), pointer :: attribute allocate ( attribute ) attribute % value = value call self % set ( name , attribute ) end subroutine attributes_set_integer subroutine attributes_set_string ( self , name , value ) class ( type_attributes ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: value class ( type_string_attribute ), pointer :: attribute allocate ( attribute ) attribute % value = value call self % set ( name , attribute ) end subroutine attributes_set_string subroutine attributes_update ( self , other ) class ( type_attributes ), intent ( inout ) :: self class ( type_attributes ), intent ( in ) :: other class ( type_attribute ), pointer :: attribute , copy attribute => other % first do while ( associated ( attribute )) allocate ( copy , source = attribute ) call self % set ( attribute % name , copy ) attribute => attribute % next end do end subroutine attributes_update subroutine field_finalize ( self ) class ( type_field ), intent ( inout ) :: self class ( type_attribute ), pointer :: attribute , next_attribute if ( allocated ( self % dimensions )) deallocate ( self % dimensions ) if ( allocated ( self % extents )) deallocate ( self % extents ) attribute => self % attributes % first do while ( associated ( attribute )) next_attribute => attribute % next deallocate ( attribute ) attribute => next_attribute end do self % attributes % first => null () end subroutine field_finalize subroutine add_field_to_tree ( self , field , category ) class ( type_field_manager ), intent ( inout ), target :: self type ( type_field ), target :: field character ( len =* ), intent ( in ), optional :: category class ( type_category_node ), pointer :: parent class ( type_node ), pointer :: node ! Find parent node parent => self % root if ( present ( category )) parent => self % find_category ( category , create = . true .) ! If field has not been selected for output yet, do so if its output_level does not exceed that the parent category. if (. not . field % in_output ) field % in_output = field % output_level <= parent % output_level if (. not . associated ( field % category )) field % category => parent ! Create node with field pointer and add to children of parent. allocate ( type_field_node :: node ) select type ( node ) class is ( type_field_node ) node % field => field end select call add_to_category ( parent , node ) end subroutine add_field_to_tree function find_category ( self , name , create ) result ( category ) class ( type_field_manager ), intent ( inout ), target :: self character ( len =* ), intent ( in ) :: name logical , optional , intent ( in ) :: create class ( type_category_node ), pointer :: category class ( type_node ), pointer :: node character ( len = string_length ) :: remaining_path integer :: istop logical :: done logical :: create_ category => self % root remaining_path = name do istop = index ( remaining_path , '/' ) - 1 done = istop ==- 1 if ( done ) istop = len_trim ( remaining_path ) if ( istop > 0 ) then ! First try to find existing parent node => category % first_child do while ( associated ( node )) select type ( node ) class is ( type_category_node ) if ( node % name == remaining_path (: istop )) exit end select node => node % next_sibling end do ! If parent does not exist yet, create it if allowed to do so. if (. not . associated ( node )) then create_ = . false . if ( present ( create )) create_ = create if (. not . create_ ) return allocate ( type_category_node :: node ) select type ( node ) class is ( type_category_node ) node % name = remaining_path (: istop ) node % output_level = category % output_level end select call add_to_category ( category , node ) end if ! Update current path position. select type ( node ) class is ( type_category_node ) category => node end select end if ! If no more path components, we're done. Otherwise, strip the component we processed and continue. if ( done ) return remaining_path = remaining_path ( istop + 2 :) end do end function find_category subroutine add_to_category ( parent , node ) type ( type_category_node ), target , intent ( inout ) :: parent class ( type_node ), target :: node class ( type_node ), pointer :: previous_sibling if ( associated ( parent % first_child )) then previous_sibling => parent % first_child do while ( associated ( previous_sibling % next_sibling )) previous_sibling => previous_sibling % next_sibling end do previous_sibling % next_sibling => node else parent % first_child => node end if node % parent => parent end subroutine add_to_category subroutine send_data_by_name_0d ( self , name , data ) class ( type_field_manager ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name real ( rk ), target :: data type ( type_field ), pointer :: field field => self % find ( name ) if (. not . associated ( field )) call fatal_error ( 'send_data_by_name_0d' , 'Field \"' // trim ( name ) // '\" has not been registered.' ) call self % send_data_0d ( field , data ) end subroutine send_data_by_name_0d subroutine send_data_by_name_1d ( self , name , data ) class ( type_field_manager ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name real ( rk ), target :: data (:) type ( type_field ), pointer :: field field => self % find ( name ) if (. not . associated ( field )) call fatal_error ( 'send_data_by_name_1d' , 'Field \"' // trim ( name ) // '\" has not been registered.' ) call self % send_data_1d ( field , data ) end subroutine send_data_by_name_1d subroutine send_data_by_name_2d ( self , name , data ) class ( type_field_manager ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name real ( rk ), target :: data (:,:) type ( type_field ), pointer :: field field => self % find ( name ) if (. not . associated ( field )) call fatal_error ( 'send_data_by_name_2d' , 'Field \"' // trim ( name ) // '\" has not been registered.' ) call self % send_data_2d ( field , data ) end subroutine send_data_by_name_2d subroutine send_data_by_name_3d ( self , name , data ) class ( type_field_manager ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name real ( rk ), target :: data (:,:,:) type ( type_field ), pointer :: field field => self % find ( name ) if (. not . associated ( field )) call fatal_error ( 'send_data_by_name_3d' , 'Field \"' // trim ( name ) // '\" has not been registered.' ) call self % send_data_3d ( field , data ) end subroutine send_data_by_name_3d subroutine check_sent_data ( field ) type ( type_field ), intent ( inout ) :: field integer , allocatable :: extents (:) integer :: i character ( len = 8 ) :: str1 , str2 , str3 call field % data % get_extents ( extents ) ! Check array rank if ( size ( extents ) /= size ( field % extents )) then write ( str1 , '(i0)' ) size ( extents ) write ( str2 , '(i0)' ) size ( field % extents ) call fatal_error ( 'check_sent_data' , trim ( str1 ) // 'D data provided for ' // trim ( field % name ) // ', but this field should have ' // trim ( str2 ) // ' non-singleton dimensions.' ) end if ! Check array extents do i = 1 , size ( extents ) if ( extents ( i ) /= field % extents ( i )) then write ( str1 , '(i0)' ) i write ( str2 , '(i0)' ) extents ( i ) write ( str3 , '(i0)' ) field % extents ( i ) call fatal_error ( 'check_sent_data' , 'Field ' // trim ( field % name ) // ', dimension ' // trim ( str1 ) // ': & &extents of provided data (' // trim ( str2 ) // ') does not match expected value ' // trim ( str3 ) // '.' ) end if end do if ( field % status == status_registered_with_data ) call fatal_error ( 'check_sent_data' , 'Data for field \"' // trim ( field % name ) // '\" have already been provided.' ) field % status = status_registered_with_data end subroutine check_sent_data subroutine send_data_0d ( self , field , data ) class ( type_field_manager ), intent ( inout ) :: self type ( type_field ), intent ( inout ) :: field real ( rk ), target :: data call field % data % set ( data ) call check_sent_data ( field ) end subroutine send_data_0d subroutine send_data_1d ( self , field , data ) class ( type_field_manager ), intent ( inout ) :: self type ( type_field ), intent ( inout ) :: field real ( rk ), target :: data (:) call field % data % set ( data ) call check_sent_data ( field ) end subroutine send_data_1d subroutine send_data_2d ( self , field , data ) class ( type_field_manager ), intent ( inout ) :: self type ( type_field ), intent ( inout ) :: field real ( rk ), target :: data (:,:) call field % data % set ( data ) call check_sent_data ( field ) end subroutine send_data_2d subroutine send_data_3d ( self , field , data ) class ( type_field_manager ), intent ( inout ) :: self type ( type_field ), intent ( inout ) :: field real ( rk ), target :: data (:,:,:) call field % data % set ( data ) call check_sent_data ( field ) end subroutine send_data_3d subroutine data_set_0d ( self , data ) class ( type_nd_data_pointer ), intent ( inout ) :: self real ( rk ), target :: data self % p0d => data end subroutine data_set_0d subroutine data_set_1d ( self , data ) class ( type_nd_data_pointer ), intent ( inout ) :: self real ( rk ), target :: data (:) if ( size ( data , 1 ) == 1 ) then call self % set ( data ( 1 )) else self % p1d => data end if end subroutine data_set_1d subroutine data_set_2d ( self , data ) class ( type_nd_data_pointer ), intent ( inout ) :: self real ( rk ), target :: data (:,:) if ( size ( data , 1 ) == 1 ) then call self % set ( data ( 1 ,:)) elseif ( size ( data , 2 ) == 1 ) then call self % set ( data (:, 1 )) else self % p2d => data end if end subroutine data_set_2d subroutine data_set_3d ( self , data ) class ( type_nd_data_pointer ), intent ( inout ) :: self real ( rk ), target :: data (:,:,:) if ( size ( data , 1 ) == 1 ) then call self % set ( data ( 1 ,:,:)) elseif ( size ( data , 2 ) == 1 ) then call self % set ( data (:, 1 ,:)) elseif ( size ( data , 3 ) == 1 ) then call self % set ( data (:,:, 1 )) else self % p3d => data end if end subroutine data_set_3d subroutine data_get_extents ( self , extents ) class ( type_nd_data_pointer ), intent ( in ) :: self integer , allocatable , intent ( out ) :: extents (:) if ( associated ( self % p3d )) then allocate ( extents ( 3 )) extents (:) = shape ( self % p3d ) elseif ( associated ( self % p2d )) then allocate ( extents ( 2 )) extents (:) = shape ( self % p2d ) elseif ( associated ( self % p1d )) then allocate ( extents ( 1 )) extents (:) = shape ( self % p1d ) elseif ( associated ( self % p0d )) then allocate ( extents ( 0 )) end if end subroutine logical function data_is_empty ( self ) class ( type_nd_data_pointer ), intent ( in ) :: self integer , allocatable :: extents (:) call self % get_extents ( extents ) if (. not . allocated ( extents )) then data_is_empty = . true . else data_is_empty = any ( extents == 0 ) end if end function subroutine fatal_error ( location , error ) character ( len =* ), intent ( in ) :: location , error write ( error_unit , * ) trim ( location ) // ': ' // trim ( error ) stop 'field_manager::fatal_error' end subroutine recursive subroutine node_finalize ( self ) class ( type_node ), intent ( inout ) :: self class ( type_node ), pointer :: child , next_child child => self % first_child do while ( associated ( child )) next_child => child % next_sibling call child % finalize () deallocate ( child ) child => next_child end do self % first_child => null () end subroutine node_finalize function get_state ( self ) result ( field_set ) class ( type_field_manager ), intent ( inout ) :: self type ( type_field_set ) :: field_set class ( type_category_node ), pointer :: category category => self % find_category ( 'state' ) if ( associated ( category )) call category % get_all_fields ( field_set , huge ( output_level_debug )) end function get_state function category_get_path ( self ) result ( path ) class ( type_category_node ), target , intent ( in ) :: self character ( len = 256 ) :: path class ( type_node ), pointer :: current path = trim ( self % name ) current => self % parent do while ( associated ( current )) select type ( current ) class is ( type_category_node ) path = trim ( current % name ) // '/' // trim ( path ) end select current => current % parent end do end function category_get_path integer function hash ( str ) character ( len =* ), intent ( in ) :: str integer :: i character , dimension ( len ( str )) :: tmp do i = 1 , len ( str ) tmp ( i ) = str ( i : i ) end do hash = sum ( ichar ( tmp )) end function subroutine field_set_real_attribute ( self , name , value ) class ( type_field ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: name real ( rk ), intent ( in ) :: value call self % attributes % set ( name , value ) end subroutine field_set_real_attribute end module field_manager","tags":"","loc":"sourcefile/field_manager.f90.html"},{"title":"output_manager_core.F90 – Fortran Program","text":"This file depends on sourcefile~~output_manager_core.f90~~EfferentGraph sourcefile~output_manager_core.f90 output_manager_core.F90 sourcefile~field_manager.f90 field_manager.F90 sourcefile~output_manager_core.f90->sourcefile~field_manager.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~output_manager_core.f90~~AfferentGraph sourcefile~output_manager_core.f90 output_manager_core.F90 sourcefile~text_output.f90 text_output.F90 sourcefile~text_output.f90->sourcefile~output_manager_core.f90 sourcefile~interp.f90 interp.F90 sourcefile~interp.f90->sourcefile~output_manager_core.f90 sourcefile~base.f90 base.F90 sourcefile~interp.f90->sourcefile~base.f90 sourcefile~base.f90->sourcefile~output_manager_core.f90 sourcefile~output_manager.f90 output_manager.F90 sourcefile~output_manager.f90->sourcefile~output_manager_core.f90 sourcefile~output_manager.f90->sourcefile~text_output.f90 sourcefile~slice.f90 slice.F90 sourcefile~output_manager.f90->sourcefile~slice.f90 sourcefile~library.f90 library.F90 sourcefile~output_manager.f90->sourcefile~library.f90 sourcefile~time_average.f90 time_average.F90 sourcefile~output_manager.f90->sourcefile~time_average.f90 sourcefile~netcdf_output.f90 netcdf_output.F90 sourcefile~output_manager.f90->sourcefile~netcdf_output.f90 sourcefile~slice.f90->sourcefile~output_manager_core.f90 sourcefile~slice.f90->sourcefile~base.f90 sourcefile~library.f90->sourcefile~output_manager_core.f90 sourcefile~library.f90->sourcefile~interp.f90 sourcefile~library.f90->sourcefile~base.f90 sourcefile~library.f90->sourcefile~slice.f90 sourcefile~library.f90->sourcefile~time_average.f90 sourcefile~time_average.f90->sourcefile~output_manager_core.f90 sourcefile~time_average.f90->sourcefile~base.f90 sourcefile~netcdf_output.f90->sourcefile~output_manager_core.f90 var pansourcefileoutput_manager_coref90AfferentGraph = svgPanZoom('#sourcefileoutput_manager_coref90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules output_manager_core Source Code output_manager_core.F90 Source Code module output_manager_core use iso_fortran_env , only : error_unit use field_manager use yaml_settings implicit none public type_output_variable_settings , type_output_item , type_output_field , type_file , write_time_string , read_time_string , host , type_host public type_base_output_field , type_base_operator , wrap_field private integer , parameter , public :: max_path = 256 integer , parameter , public :: time_method_none = 0 ! time-independent variable integer , parameter , public :: time_method_instantaneous = 1 integer , parameter , public :: time_method_mean = 2 integer , parameter , public :: time_method_integrated = 3 integer , parameter , public :: time_unit_none = 0 integer , parameter , public :: time_unit_second = 1 integer , parameter , public :: time_unit_hour = 2 integer , parameter , public :: time_unit_day = 3 integer , parameter , public :: time_unit_month = 4 integer , parameter , public :: time_unit_year = 5 integer , parameter , public :: time_unit_dt = 6 integer , parameter , public :: time_from_list = 7 integer , parameter , public :: rk = kind ( _ ONE_ ) type , abstract :: type_host contains procedure ( host_julian_day ), deferred :: julian_day procedure ( host_calendar_date ), deferred :: calendar_date procedure :: fatal_error => host_fatal_error procedure :: log_message => host_log_message end type abstract interface subroutine host_julian_day ( self , yyyy , mm , dd , julian ) import type_host class ( type_host ), intent ( in ) :: self integer , intent ( in ) :: yyyy , mm , dd integer , intent ( out ) :: julian end subroutine end interface abstract interface subroutine host_calendar_date ( self , julian , yyyy , mm , dd ) import type_host class ( type_host ), intent ( in ) :: self integer , intent ( in ) :: julian integer , intent ( out ) :: yyyy , mm , dd end subroutine end interface type type_output_variable_settings integer :: time_method = time_method_instantaneous class ( type_base_operator ), pointer :: final_operator => null () contains procedure :: initialize => output_variable_settings_initialize end type type type_output_item class ( type_output_variable_settings ), pointer :: settings => null () character ( len = string_length ) :: name = '' character ( len = string_length ) :: prefix = '' character ( len = string_length ) :: postfix = '' integer :: output_level = output_level_default class ( type_category_node ), pointer :: category => null () type ( type_field ), pointer :: field => null () type ( type_output_item ), pointer :: next => null () end type type type_output_field_pointer class ( type_base_output_field ), pointer :: p => null () end type type type_base_output_field class ( type_output_variable_settings ), pointer :: settings => null () character ( len = string_length ) :: output_name = '' logical :: is_coordinate = . false . type ( type_nd_data_pointer ) :: data type ( type_output_field_pointer ), allocatable :: coordinates (:) class ( type_base_output_field ), pointer :: next => null () contains procedure :: new_data => base_field_new_data procedure :: before_save => base_field_before_save procedure :: flag_as_required => base_field_flag_as_required procedure :: get_metadata => base_field_get_metadata procedure :: get_field => base_field_get_field end type type_base_output_field type , extends ( type_base_output_field ) :: type_output_field type ( type_field ), pointer :: source => null () contains procedure :: flag_as_required => field_flag_as_required procedure :: get_metadata => field_get_metadata end type type_output_field type type_file type ( type_field_manager ), pointer :: field_manager => null () character ( len = max_path ) :: path = '' character ( len = max_path ) :: postfix = '' character ( len = string_length ) :: title = '' integer :: time_unit = time_unit_none integer :: time_step = 0 integer :: first_index = 0 integer :: next_julian = - 1 integer :: next_seconds = - 1 integer :: first_julian = - 1 integer :: first_seconds = - 1 integer :: last_julian = huge ( 1 ) integer :: last_seconds = 0 type ( type_output_item ), pointer :: first_item => null () class ( type_base_output_field ), pointer :: first_field => null () class ( type_file ), pointer :: next => null () contains procedure :: configure procedure :: initialize procedure :: save procedure :: finalize procedure :: create_settings procedure :: is_dimension_used procedure :: append_item end type type_file type type_base_operator class ( type_base_operator ), pointer :: previous => null () contains procedure :: configure => operator_configure procedure :: apply => operator_apply procedure :: apply_all => operator_apply_all end type class ( type_host ), pointer , save :: host => null () contains recursive subroutine base_field_flag_as_required ( self , required ) class ( type_base_output_field ), intent ( inout ) :: self logical , intent ( in ) :: required end subroutine recursive subroutine base_field_get_metadata ( self , long_name , units , dimensions , minimum , maximum , fill_value , standard_name , path , attributes ) class ( type_base_output_field ), intent ( in ) :: self character ( len = :), allocatable , intent ( out ), optional :: long_name , units , standard_name , path type ( type_dimension_pointer ), allocatable , intent ( out ), optional :: dimensions (:) real ( rk ), intent ( out ), optional :: minimum , maximum , fill_value type ( type_attributes ), intent ( out ), optional :: attributes if ( present ( dimensions )) allocate ( dimensions ( 0 )) end subroutine recursive subroutine base_field_new_data ( self ) class ( type_base_output_field ), intent ( inout ) :: self end subroutine recursive subroutine base_field_before_save ( self ) class ( type_base_output_field ), intent ( inout ) :: self end subroutine recursive function base_field_get_field ( self , field ) result ( output_field ) class ( type_base_output_field ), intent ( in ) :: self type ( type_field ), target :: field class ( type_base_output_field ), pointer :: output_field output_field => wrap_field ( field , . false .) end function function wrap_field ( field , allow_unregistered ) result ( output_field ) type ( type_field ), target :: field logical , intent ( in ) :: allow_unregistered class ( type_output_field ), pointer :: output_field output_field => null () select case ( field % status ) case ( status_not_registered ) if ( allow_unregistered ) then call host % log_message ( 'WARNING: output field \"' // trim ( field % name ) // '\" is skipped because it has not been registered with field manager.' ) else call host % fatal_error ( 'create_field' , 'Requested output field \"' // trim ( field % name ) // '\" has not been registered with field manager.' ) end if case ( status_registered_no_data ) call host % fatal_error ( 'create_field' , 'Data for requested field \"' // trim ( field % name ) // '\" have not been provided to field manager.' ) case default allocate ( output_field ) output_field % source => field output_field % data = output_field % source % data output_field % output_name = trim ( field % name ) end select end function recursive subroutine field_flag_as_required ( self , required ) class ( type_output_field ), intent ( inout ) :: self logical , intent ( in ) :: required if ( associated ( self % source % used_now ) . and . required ) self % source % used_now = . true . end subroutine recursive subroutine field_get_metadata ( self , long_name , units , dimensions , minimum , maximum , fill_value , standard_name , path , attributes ) class ( type_output_field ), intent ( in ) :: self character ( len = :), allocatable , intent ( out ), optional :: long_name , units , standard_name , path type ( type_dimension_pointer ), allocatable , intent ( out ), optional :: dimensions (:) type ( type_attributes ), intent ( out ), optional :: attributes real ( rk ), intent ( out ), optional :: minimum , maximum , fill_value if ( self % source % status == status_not_registered ) then if ( present ( dimensions )) allocate ( dimensions ( 0 )) return end if if ( present ( long_name )) long_name = trim ( self % source % long_name ) if ( present ( units )) units = trim ( self % source % units ) if ( present ( dimensions )) then allocate ( dimensions ( size ( self % source % dimensions ))) dimensions (:) = self % source % dimensions (:) end if if ( present ( minimum )) minimum = self % source % minimum if ( present ( maximum )) maximum = self % source % maximum if ( present ( fill_value )) fill_value = self % source % fill_value if ( present ( standard_name ) . and . self % source % standard_name /= '' ) standard_name = trim ( self % source % standard_name ) if ( present ( path ) . and . associated ( self % source % category )) path = trim ( self % source % category % get_path ()) if ( present ( attributes )) call attributes % update ( self % source % attributes ) end subroutine subroutine configure ( self , settings ) class ( type_file ), intent ( inout ) :: self class ( type_settings ), intent ( inout ) :: settings end subroutine subroutine initialize ( self ) class ( type_file ), intent ( inout ) :: self stop 'output_manager_core:initialize not implemented' end subroutine function create_settings ( self ) result ( settings ) class ( type_file ), intent ( inout ) :: self class ( type_output_variable_settings ), pointer :: settings allocate ( settings ) end function create_settings subroutine save ( self , julianday , secondsofday , microseconds ) class ( type_file ), intent ( inout ) :: self integer , intent ( in ) :: julianday , secondsofday , microseconds stop 'output_manager_core:save not implemented' end subroutine subroutine finalize ( self ) class ( type_file ), intent ( inout ) :: self end subroutine subroutine write_time_string ( jul , secs , timestr ) integer , intent ( in ) :: jul , secs character ( len =* ), intent ( out ) :: timestr integer :: ss , min , hh , dd , mm , yy hh = secs / 3600 min = ( secs - hh * 3600 ) / 60 ss = secs - 3600 * hh - 60 * min call host % calendar_date ( jul , yy , mm , dd ) write ( timestr , '(i4.4,a1,i2.2,a1,i2.2,1x,i2.2,a1,i2.2,a1,i2.2)' ) & yy , '-' , mm , '-' , dd , hh , ':' , min , ':' , ss end subroutine write_time_string subroutine read_time_string ( timestr , jul , secs , success ) character ( len = 19 ) :: timestr integer , intent ( out ) :: jul , secs logical , intent ( out ) :: success integer :: ios character :: c1 , c2 , c3 , c4 integer :: yy , mm , dd , hh , min , ss read ( timestr , '(i4,a1,i2,a1,i2,1x,i2,a1,i2,a1,i2)' , iostat = ios ) & yy , c1 , mm , c2 , dd , hh , c3 , min , c4 , ss success = ios == 0 if ( ios == 0 ) then call host % julian_day ( yy , mm , dd , jul ) secs = 3600 * hh + 60 * min + ss end if end subroutine read_time_string subroutine host_fatal_error ( self , location , error ) class ( type_host ), intent ( in ) :: self character ( len =* ), intent ( in ) :: location , error write ( error_unit , * ) trim ( location ) // ': ' // trim ( error ) stop 1 end subroutine subroutine host_log_message ( self , message ) class ( type_host ), intent ( in ) :: self character ( len =* ), intent ( in ) :: message write ( error_unit , * ) trim ( message ) end subroutine logical function is_dimension_used ( self , dim ) class ( type_file ), intent ( inout ) :: self type ( type_dimension ), target :: dim class ( type_base_output_field ), pointer :: output_field type ( type_dimension_pointer ), allocatable :: dimensions (:) integer :: i is_dimension_used = . true . output_field => self % first_field do while ( associated ( output_field )) call output_field % get_metadata ( dimensions = dimensions ) do i = 1 , size ( dimensions ) if ( associated ( dimensions ( i )% p , dim )) return end do output_field => output_field % next end do is_dimension_used = . false . end function is_dimension_used subroutine append_item ( self , item ) class ( type_file ), intent ( inout ) :: self type ( type_output_item ), target :: item ! Select this category for output in the field manager. if (. not . associated ( item % settings )) item % settings => self % create_settings () if (. not . associated ( item % field )) item % category => self % field_manager % select_category_for_output ( item % name , item % output_level ) ! Prepend to list of output categories. item % next => self % first_item self % first_item => item end subroutine append_item subroutine output_variable_settings_initialize ( self , settings , parent ) class ( type_output_variable_settings ), intent ( inout ) :: self class ( type_settings ), intent ( inout ) :: settings class ( type_output_variable_settings ), intent ( in ), optional :: parent if ( present ( parent )) then self % time_method = parent % time_method self % final_operator => parent % final_operator end if call settings % get ( self % time_method , 'time_method' , 'treatment of time dimension' , options = ( / type_option ( time_method_mean , 'mean' , 'mean' ), & type_option ( time_method_instantaneous , 'instantaneous' , 'point' ), type_option ( time_method_integrated , 'integrated' , 'integrated' ) / ), default = self % time_method ) end subroutine output_variable_settings_initialize subroutine operator_configure ( self , settings , field_manager ) class ( type_base_operator ), target , intent ( inout ) :: self class ( type_settings ), intent ( inout ) :: settings type ( type_field_manager ), intent ( inout ) :: field_manager end subroutine function operator_apply ( self , source ) result ( output_field ) class ( type_base_operator ), intent ( inout ), target :: self class ( type_base_output_field ), target :: source class ( type_base_output_field ), pointer :: output_field output_field => source end function recursive function operator_apply_all ( self , source ) result ( output_field ) class ( type_base_operator ), intent ( inout ), target :: self class ( type_base_output_field ), target :: source class ( type_base_output_field ), pointer :: output_field output_field => source if ( associated ( self % previous )) output_field => self % previous % apply_all ( output_field ) if ( associated ( output_field )) output_field => self % apply ( output_field ) end function end module output_manager_core","tags":"","loc":"sourcefile/output_manager_core.f90.html"},{"title":"flexout_version.F90.in – Fortran Program","text":"This file will be pre-processed by CMake generating flexout_version.F90 The module can be used by projects wanting to trace exact code information. Contents Modules flexout_version Source Code flexout_version.F90.in Source Code !! This file will be pre-processed by CMake generating *flexout_version.F90* !! The module can be used by projects wanting to trace exact code information. module flexout_version !! Version information will be optained from Git and includes *branch* and !! *hash* information. character ( len =* ), parameter :: git_commit_id = \"@GIT_COMMIT_ID@\" character ( len =* ), parameter :: git_branch_name = \"@GIT_BRANCH_NAME@\" end module","tags":"","loc":"sourcefile/flexout_version.f90.in.html"},{"title":"output_manager.F90 – Fortran Program","text":"This file depends on sourcefile~~output_manager.f90~~EfferentGraph sourcefile~output_manager.f90 output_manager.F90 sourcefile~text_output.f90 text_output.F90 sourcefile~output_manager.f90->sourcefile~text_output.f90 sourcefile~field_manager.f90 field_manager.F90 sourcefile~output_manager.f90->sourcefile~field_manager.f90 sourcefile~slice.f90 slice.F90 sourcefile~output_manager.f90->sourcefile~slice.f90 sourcefile~library.f90 library.F90 sourcefile~output_manager.f90->sourcefile~library.f90 sourcefile~time_average.f90 time_average.F90 sourcefile~output_manager.f90->sourcefile~time_average.f90 sourcefile~output_manager_core.f90 output_manager_core.F90 sourcefile~output_manager.f90->sourcefile~output_manager_core.f90 sourcefile~netcdf_output.f90 netcdf_output.F90 sourcefile~output_manager.f90->sourcefile~netcdf_output.f90 sourcefile~text_output.f90->sourcefile~field_manager.f90 sourcefile~text_output.f90->sourcefile~output_manager_core.f90 sourcefile~slice.f90->sourcefile~field_manager.f90 sourcefile~slice.f90->sourcefile~output_manager_core.f90 sourcefile~base.f90 base.F90 sourcefile~slice.f90->sourcefile~base.f90 sourcefile~library.f90->sourcefile~field_manager.f90 sourcefile~library.f90->sourcefile~slice.f90 sourcefile~library.f90->sourcefile~time_average.f90 sourcefile~library.f90->sourcefile~output_manager_core.f90 sourcefile~interp.f90 interp.F90 sourcefile~library.f90->sourcefile~interp.f90 sourcefile~library.f90->sourcefile~base.f90 sourcefile~time_average.f90->sourcefile~field_manager.f90 sourcefile~time_average.f90->sourcefile~output_manager_core.f90 sourcefile~time_average.f90->sourcefile~base.f90 sourcefile~output_manager_core.f90->sourcefile~field_manager.f90 sourcefile~netcdf_output.f90->sourcefile~field_manager.f90 sourcefile~netcdf_output.f90->sourcefile~output_manager_core.f90 sourcefile~interp.f90->sourcefile~field_manager.f90 sourcefile~interp.f90->sourcefile~output_manager_core.f90 sourcefile~interp.f90->sourcefile~base.f90 sourcefile~base.f90->sourcefile~field_manager.f90 sourcefile~base.f90->sourcefile~output_manager_core.f90 var pansourcefileoutput_managerf90EfferentGraph = svgPanZoom('#sourcefileoutput_managerf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules output_manager Source Code output_manager.F90 Source Code module output_manager use field_manager use output_manager_core use netcdf_output use text_output use output_operators_library use output_operators_time_average use output_operators_slice use yaml_settings implicit none public output_manager_init , output_manager_start , output_manager_prepare_save , output_manager_save , output_manager_clean , output_manager_add_file private class ( type_file ), pointer :: first_file logical :: files_initialized logical , save , public :: allow_missing_fields = . false . interface output_manager_save module procedure output_manager_save1 module procedure output_manager_save2 end interface type , extends ( type_dictionary_populator ) :: type_file_populator type ( type_field_manager ), pointer :: fm => null () character ( len = :), allocatable :: title character ( len = :), allocatable :: postfix contains procedure :: create => process_file end type type , extends ( type_list_populator ) :: type_operator_populator type ( type_field_manager ), pointer :: field_manager => null () class ( type_output_variable_settings ), pointer :: variable_settings => null () contains procedure :: create => create_operator_settings end type type , extends ( type_list_populator ) :: type_group_populator class ( type_file ), pointer :: file class ( type_output_variable_settings ), pointer :: variable_settings => null () contains procedure :: create => create_group_settings end type type , extends ( type_list_populator ) :: type_variable_populator class ( type_file ), pointer :: file => null () class ( type_output_variable_settings ), pointer :: variable_settings => null () contains procedure :: create => create_variable_settings end type contains subroutine output_manager_init ( field_manager , title , postfix , settings ) type ( type_field_manager ), target :: field_manager character ( len =* ), intent ( in ) :: title character ( len =* ), optional , intent ( in ) :: postfix class ( type_settings ), pointer , optional :: settings if (. not . associated ( host )) then write ( * , * ) 'output_manager_init: the host of an output manager must set the host pointer before calling output_manager_init' stop 1 end if nullify ( first_file ) files_initialized = . false . call configure_from_yaml ( field_manager , title , postfix , settings ) end subroutine subroutine output_manager_clean () class ( type_file ), pointer :: file file => first_file do while ( associated ( file )) call file % finalize () file => file % next end do end subroutine subroutine populate ( file ) class ( type_file ), intent ( inout ) :: file type ( type_output_item ), pointer :: item type ( type_field_set ) :: set class ( type_field_set_member ), pointer :: member , next_member class ( type_output_variable_settings ), pointer :: output_settings type ( type_settings ) :: settings class ( type_base_output_field ), pointer :: output_field , coordinate_field type ( type_dimension_pointer ), allocatable :: dimensions (:) integer :: i ! First add fields selected by name ! (they take priority over fields included with wildcard expressions) item => file % first_item do while ( associated ( item )) if ( associated ( item % field )) call create_field ( item % settings , item % field , trim ( item % name ), . false .) item => item % next end do item => file % first_item do while ( associated ( item )) if ( associated ( item % category )) then call host % log_message ( 'Processing output category /' // trim ( item % name ) // ':' ) if ( item % category % has_fields () . or . allow_missing_fields ) then call item % category % get_all_fields ( set , item % output_level ) member => set % first if (. not . associated ( member )) call host % log_message ( 'WARNING: output category \"' // trim ( item % name ) // '\" does not contain any variables with requested output level.' ) do while ( associated ( member )) call host % log_message ( '  - ' // trim ( member % field % name )) output_settings => file % create_settings () call output_settings % initialize ( settings , item % settings ) call create_field ( output_settings , member % field , trim ( item % prefix ) // trim ( member % field % name ) // trim ( item % postfix ), . true .) next_member => member % next deallocate ( member ) member => next_member end do set % first => null () else call host % fatal_error ( 'collect_from_categories' , 'No variables have been registered under output category \"' // trim ( item % name ) // '\".' ) end if end if item => item % next end do output_field => file % first_field do while ( associated ( output_field )) call output_field % get_metadata ( dimensions = dimensions ) allocate ( output_field % coordinates ( size ( dimensions ))) do i = 1 , size ( dimensions ) if (. not . associated ( dimensions ( i )% p )) cycle if (. not . associated ( dimensions ( i )% p % coordinate )) cycle coordinate_field => find_field ( dimensions ( i )% p % coordinate % name ) if (. not . associated ( coordinate_field )) then coordinate_field => output_field % get_field ( dimensions ( i )% p % coordinate ) if ( associated ( coordinate_field )) call append_field ( trim ( dimensions ( i )% p % coordinate % name ), coordinate_field , file % create_settings ()) end if if ( associated ( coordinate_field )) coordinate_field % is_coordinate = . true . output_field % coordinates ( i )% p => coordinate_field end do output_field => output_field % next end do contains function find_field ( output_name ) result ( field ) character ( len =* ), intent ( in ) :: output_name class ( type_base_output_field ), pointer :: field field => file % first_field do while ( associated ( field )) if ( field % output_name == output_name ) return field => field % next end do end function subroutine create_field ( output_settings , field , output_name , ignore_if_exists ) class ( type_output_variable_settings ), target :: output_settings type ( type_field ), target :: field character ( len =* ), intent ( in ) :: output_name logical , intent ( in ) :: ignore_if_exists class ( type_base_operator ), pointer :: final_operator class ( type_base_output_field ), pointer :: output_field class ( type_time_average_operator ), pointer :: time_filter output_field => find_field ( output_name ) if ( associated ( output_field )) then if (. not . ignore_if_exists ) call host % fatal_error ( 'create_field' , 'A different output field with name \"' // output_name // '\" already exists.' ) return end if final_operator => output_settings % final_operator if ( output_settings % time_method /= time_method_instantaneous . and . output_settings % time_method /= time_method_none ) then ! Apply time averaging/integration operator allocate ( time_filter ) time_filter % method = output_settings % time_method time_filter % previous => final_operator final_operator => time_filter end if output_field => wrap_field ( field , allow_missing_fields ) if ( associated ( final_operator )) output_field => final_operator % apply_all ( output_field ) if ( associated ( output_field )) call append_field ( output_name , output_field , output_settings ) end subroutine subroutine append_field ( output_name , output_field , output_settings ) character ( len =* ), intent ( in ) :: output_name class ( type_base_output_field ), intent ( inout ), target :: output_field class ( type_output_variable_settings ), target :: output_settings class ( type_base_output_field ), pointer :: last_field output_field % settings => output_settings output_field % output_name = trim ( output_name ) if ( associated ( file % first_field )) then last_field => file % first_field do while ( associated ( last_field % next )) last_field => last_field % next end do last_field % next => output_field else file % first_field => output_field end if end subroutine end subroutine populate subroutine output_manager_start ( julianday , secondsofday , microseconds , n ) integer , intent ( in ) :: julianday , secondsofday , microseconds , n class ( type_file ), pointer :: file file => first_file do while ( associated ( file )) call populate ( file ) ! If we do not have a start time yet, use current. if ( file % first_julian <= 0 ) then file % first_julian = julianday file % first_seconds = secondsofday end if ! Create output file call file % initialize () file => file % next end do files_initialized = . true . end subroutine subroutine set_next_output ( self , julianday , secondsofday , microseconds , n ) class ( type_file ), intent ( inout ) :: self integer , intent ( in ) :: julianday , secondsofday , microseconds , n integer :: yyyy , mm , dd , yyyy0 , mm0 integer ( kind = selected_int_kind ( 12 )) :: offset ! Determine time (julian day, seconds of day) for first output. self % next_julian = self % first_julian self % next_seconds = self % first_seconds offset = 86400 * ( julianday - self % first_julian ) + ( secondsofday - self % first_seconds ) if ( offset > 0 ) then select case ( self % time_unit ) case ( time_unit_second ) self % next_seconds = self % next_seconds + (( offset + self % time_step - 1 ) / self % time_step ) * self % time_step self % next_julian = self % next_julian + self % next_seconds / 86400 self % next_seconds = mod ( self % next_seconds , 86400 ) case ( time_unit_hour ) self % next_seconds = self % next_seconds + (( offset + self % time_step * 3600 - 1 ) / ( self % time_step * 3600 )) * self % time_step * 3600 self % next_julian = self % next_julian + self % next_seconds / 86400 self % next_seconds = mod ( self % next_seconds , 86400 ) case ( time_unit_day ) self % next_julian = self % next_julian + (( offset + self % time_step * 86400 - 1 ) / ( self % time_step * 86400 )) * self % time_step case ( time_unit_month ) call host % calendar_date ( julianday , yyyy , mm , dd ) call host % calendar_date ( self % first_julian , yyyy , mm0 , dd ) mm = mm0 + (( mm - mm0 + self % time_step - 1 ) / self % time_step ) * self % time_step yyyy = yyyy + ( mm - 1 ) / 12 mm = mod ( mm - 1 , 12 ) + 1 call host % julian_day ( yyyy , mm , dd , self % next_julian ) if ( self % next_julian == julianday . and . secondsofday > self % next_seconds ) then mm = mm + self % time_step yyyy = yyyy + ( mm - 1 ) / 12 mm = mod ( mm - 1 , 12 ) + 1 call host % julian_day ( yyyy , mm , dd , self % next_julian ) end if case ( time_unit_year ) call host % calendar_date ( julianday , yyyy , mm , dd ) call host % calendar_date ( self % first_julian , yyyy0 , mm , dd ) yyyy = yyyy0 + (( yyyy - yyyy0 + self % time_step - 1 ) / self % time_step ) * self % time_step call host % julian_day ( yyyy , mm , dd , self % next_julian ) if ( self % next_julian == julianday . and . secondsofday > self % next_seconds ) then yyyy = yyyy + self % time_step call host % julian_day ( yyyy , mm , dd , self % next_julian ) end if end select end if end subroutine subroutine output_manager_save1 ( julianday , secondsofday , n ) integer , intent ( in ) :: julianday , secondsofday , n call output_manager_save2 ( julianday , secondsofday , 0 , n ) end subroutine subroutine output_manager_prepare_save ( julianday , secondsofday , microseconds , n ) integer , intent ( in ) :: julianday , secondsofday , microseconds , n class ( type_file ), pointer :: file class ( type_base_output_field ), pointer :: output_field logical :: required if (. not . files_initialized ) call output_manager_start ( julianday , secondsofday , microseconds , n ) ! Start by marking all fields as not needing computation if ( associated ( first_file )) call first_file % field_manager % reset_used () file => first_file do while ( associated ( file )) if ( in_window ( file , julianday , secondsofday , microseconds , n )) then if ( file % next_julian == - 1 ) call set_next_output ( file , julianday , secondsofday , microseconds , n ) output_field => file % first_field do while ( associated ( output_field )) select case ( file % time_unit ) case ( time_unit_dt ) required = file % first_index == - 1 . or . mod ( n - file % first_index , file % time_step ) == 0 case default required = file % next_julian == - 1 . or . ( julianday == file % next_julian . and . secondsofday >= file % next_seconds ) . or . julianday > file % next_julian end select call output_field % flag_as_required ( required ) output_field => output_field % next end do end if file => file % next end do end subroutine logical function in_window ( self , julianday , secondsofday , microseconds , n ) class ( type_file ), intent ( in ) :: self integer , intent ( in ) :: julianday , secondsofday , microseconds , n in_window = (( julianday == self % first_julian . and . secondsofday >= self % first_seconds ) . or . julianday > self % first_julian ) & . and . (( julianday == self % last_julian . and . secondsofday <= self % last_seconds ) . or . julianday < self % last_julian ) end function subroutine output_manager_save2 ( julianday , secondsofday , microseconds , n ) integer , intent ( in ) :: julianday , secondsofday , microseconds , n class ( type_file ), pointer :: file class ( type_base_output_field ), pointer :: output_field integer :: yyyy , mm , dd logical :: output_required if (. not . files_initialized ) call output_manager_start ( julianday , secondsofday , microseconds , n ) file => first_file do while ( associated ( file )) if ( in_window ( file , julianday , secondsofday , microseconds , n )) then if ( file % next_julian == - 1 ) call set_next_output ( file , julianday , secondsofday , microseconds , n ) ! Increment time-integrated fields output_field => file % first_field do while ( associated ( output_field )) call output_field % new_data () output_field => output_field % next end do ! Determine whether output is required if ( file % time_unit /= time_unit_dt ) then output_required = ( julianday == file % next_julian . and . secondsofday >= file % next_seconds ) . or . julianday > file % next_julian else if ( file % first_index == - 1 ) file % first_index = n output_required = mod ( n - file % first_index , file % time_step ) == 0 end if if ( output_required ) then output_field => file % first_field do while ( associated ( output_field )) call output_field % before_save () output_field => output_field % next end do ! Do output call file % save ( julianday , secondsofday , microseconds ) ! Determine time (julian day, seconds of day) for next output. select case ( file % time_unit ) case ( time_unit_second ) file % next_seconds = file % next_seconds + file % time_step file % next_julian = file % next_julian + file % next_seconds / 86400 file % next_seconds = mod ( file % next_seconds , 86400 ) case ( time_unit_hour ) file % next_seconds = file % next_seconds + file % time_step * 3600 file % next_julian = file % next_julian + file % next_seconds / 86400 file % next_seconds = mod ( file % next_seconds , 86400 ) case ( time_unit_day ) file % next_julian = file % next_julian + file % time_step case ( time_unit_month ) call host % calendar_date ( julianday , yyyy , mm , dd ) mm = mm + file % time_step yyyy = yyyy + ( mm - 1 ) / 12 mm = mod ( mm - 1 , 12 ) + 1 call host % julian_day ( yyyy , mm , dd , file % next_julian ) case ( time_unit_year ) call host % calendar_date ( julianday , yyyy , mm , dd ) yyyy = yyyy + file % time_step call host % julian_day ( yyyy , mm , dd , file % next_julian ) end select end if end if ! in output time window file => file % next end do end subroutine output_manager_save2 subroutine configure_from_yaml ( field_manager , title , postfix , settings ) type ( type_field_manager ), target :: field_manager character ( len =* ), intent ( in ) :: title character ( len =* ), optional , intent ( in ) :: postfix class ( type_settings ), pointer , optional :: settings logical :: file_exists integer , parameter :: yaml_unit = 100 class ( type_settings ), pointer :: settings_ class ( type_file_populator ), pointer :: populator allocate ( populator ) populator % fm => field_manager populator % title = trim ( title ) if ( present ( postfix )) populator % postfix = postfix if ( present ( settings )) then settings_ => settings call settings_ % populate ( populator ) else settings_ => type_settings_create ( populator = populator ) end if inquire ( file = 'output.yaml' , exist = file_exists ) if ( file_exists ) then call settings_ % load ( 'output.yaml' , yaml_unit ) elseif (. not . present ( settings )) then call host % log_message ( 'WARNING: no output files will be written because output.yaml is not present.' ) return end if end subroutine subroutine output_manager_add_file ( field_manager , file ) type ( type_field_manager ), target :: field_manager class ( type_file ), target :: file file % field_manager => field_manager file % next => first_file first_file => file end subroutine output_manager_add_file subroutine process_file ( self , pair ) class ( type_file_populator ), intent ( inout ) :: self type ( type_key_value_pair ), intent ( inout ) :: pair class ( type_logical_setting ) , pointer :: logical_setting integer :: fmt class ( type_file ), pointer :: file character ( len = :), allocatable :: string class ( type_settings ), pointer :: file_settings logical :: success class ( type_output_variable_settings ), pointer :: variable_settings type ( type_dimension ), pointer :: dim integer :: global_start , global_stop , stride character ( len = 8 ) :: strmax logical :: is_active class ( type_slice_operator ), pointer :: slice_operator if ( pair % key == 'allow_missing_fields' ) then logical_setting => type_logical_setting_create ( pair , allow_missing_fields , 'ignore unknown requested output fields' ) return end if file_settings => type_settings_create ( pair , 'path of output file' ) is_active = file_settings % get_logical ( 'is_active' , 'write output to this file' , default = . true .) #ifdef NETCDF_FMT fmt = file_settings % get_integer ( 'format' , 'format' , options = ( / type_option ( 1 , 'text' , 'text' ), type_option ( 2 , 'NetCDF' , 'netcdf' ) / ), default = 2 ) #else fmt = file_settings % get_integer ( 'format' , 'format' , options = ( / type_option ( 1 , 'text' , 'text' ) / ), default = 1 ) #endif select case ( fmt ) case ( 1 ) allocate ( type_text_file :: file ) case ( 2 ) #ifdef NETCDF_FMT allocate ( type_netcdf_file :: file ) #endif end select ! Create file object and prepend to list. file % path = pair % name if ( allocated ( self % postfix )) file % postfix = self % postfix call output_manager_add_file ( self % fm , file ) ! Can be used for CF global attributes call file_settings % get ( file % title , 'title' , 'title' , default = self % title ) call file_settings % get ( file % time_unit , 'time_unit' , 'time unit' , default = time_unit_day , options = ( / & type_option ( time_unit_second , 'second' , 'second' ), type_option ( time_unit_hour , 'hour' , 'hour' ), type_option ( time_unit_day , 'day' , 'day' ), & type_option ( time_unit_month , 'month' , 'month' ), type_option ( time_unit_year , 'year' , 'year' ), type_option ( time_unit_dt , 'model time step' , 'dt' ) / )) ! Determine time step call file_settings % get ( file % time_step , 'time_step' , 'number of time units between output' , minimum = 1 , default = 1 ) string = file_settings % get_string ( 'time_start' , 'start' , 'yyyy-mm-dd HH:MM:SS' , default = '' ) if ( string /= '' ) then call read_time_string ( string , file % first_julian , file % first_seconds , success ) if (. not . success ) call host % fatal_error ( 'process_file' , 'Error in output configuration: invalid time_start \"' // string // '\" specified for file \"' // pair % name // '\". Required format: yyyy-mm-dd HH:MM:SS.' ) end if string = file_settings % get_string ( 'time_stop' , 'stop' , 'yyyy-mm-dd HH:MM:SS' , default = '' ) if ( string /= '' ) then call read_time_string ( string , file % last_julian , file % last_seconds , success ) if (. not . success ) call host % fatal_error ( 'process_file' , 'Error in output configuration: invalid time_stop \"' // string // '\" specified for file \"' // pair % name // '\". Required format: yyyy-mm-dd HH:MM:SS.' ) end if ! Determine dimension ranges allocate ( slice_operator ) dim => self % fm % first_dimension do while ( associated ( dim )) if ( dim % iterator /= '' ) then write ( strmax , '(i0)' ) dim % global_length global_start = file_settings % get_integer ( trim ( dim % iterator ) // '_start' , 'start index for ' // trim ( dim % iterator ) // ' dimension' , default = 1 , minimum = 0 , maximum = dim % global_length ) global_stop = file_settings % get_integer ( trim ( dim % iterator ) // '_stop' , 'stop index for ' // trim ( dim % iterator ) // ' dimension' , default = dim % global_length , minimum = 1 , maximum = dim % global_length ) if ( global_start > global_stop ) call host % fatal_error ( 'process_file' , 'Error parsing output.yaml: ' // trim ( dim % iterator ) // '_stop must equal or exceed ' // trim ( dim % iterator ) // '_start' ) stride = file_settings % get_integer ( trim ( dim % iterator ) // '_stride' , 'stride for ' // trim ( dim % iterator ) // ' dimension' , default = 1 , minimum = 1 ) call slice_operator % add ( trim ( dim % name ), global_start , global_stop , stride ) end if dim => dim % next end do variable_settings => file % create_settings () call variable_settings % initialize ( file_settings ) variable_settings % final_operator => slice_operator ! Allow specific file implementation to parse additional settings from yaml file. call file % configure ( file_settings ) call configure_group ( file , file_settings , variable_settings ) end subroutine process_file recursive subroutine configure_group ( file , settings , default_variable_settings ) class ( type_file ), target , intent ( inout ) :: file class ( type_settings ), intent ( inout ) :: settings class ( type_output_variable_settings ), optional , intent ( in ) :: default_variable_settings class ( type_output_variable_settings ), pointer :: variable_settings class ( type_operator_populator ), pointer :: operator_populator class ( type_group_populator ), pointer :: group_populator class ( type_variable_populator ), pointer :: variable_populator variable_settings => file % create_settings () call variable_settings % initialize ( settings , default_variable_settings ) ! Get operators allocate ( operator_populator ) operator_populator % field_manager => file % field_manager operator_populator % variable_settings => variable_settings call settings % get_list ( 'operators' , operator_populator ) ! Get list with groups [if any] allocate ( group_populator ) group_populator % file => file group_populator % variable_settings => variable_settings call settings % get_list ( 'groups' , group_populator ) ! Get list with variables allocate ( variable_populator ) variable_populator % file => file variable_populator % variable_settings => variable_settings call settings % get_list ( 'variables' , variable_populator ) end subroutine recursive subroutine create_group_settings ( self , index , item ) class ( type_group_populator ), intent ( inout ) :: self integer , intent ( in ) :: index type ( type_list_item ), intent ( inout ) :: item class ( type_settings ), pointer :: group_settings group_settings => type_settings_create ( item ) call configure_group ( self % file , group_settings , self % variable_settings ) end subroutine recursive subroutine create_operator_settings ( self , index , item ) class ( type_operator_populator ), intent ( inout ) :: self integer , intent ( in ) :: index type ( type_list_item ), intent ( inout ) :: item class ( type_settings ), pointer :: settings settings => type_settings_create ( item ) call apply_operator ( self % variable_settings % final_operator , settings , self % field_manager ) end subroutine recursive subroutine create_variable_settings ( self , index , item ) class ( type_variable_populator ), intent ( inout ) :: self integer , intent ( in ) :: index type ( type_list_item ), intent ( inout ) :: item class ( type_settings ), pointer :: variable_settings character ( len = :), allocatable :: source_name type ( type_output_item ), pointer :: output_item integer :: n variable_settings => type_settings_create ( item ) ! Name of source variable source_name = variable_settings % get_string ( 'source' , 'name in model' ) allocate ( output_item ) output_item % settings => self % file % create_settings () call output_item % settings % initialize ( variable_settings , self % variable_settings ) ! Determine whether to create an output field or an output category n = len ( source_name ) if ( source_name ( n : n ) == '*' ) then if ( n == 1 ) then output_item % name = '' else output_item % name = source_name (: n - 2 ) end if ! Prefix for output name call variable_settings % get ( output_item % prefix , 'prefix' , 'name prefix used in output' , default = '' ) ! Postfix for output name call variable_settings % get ( output_item % postfix , 'postfix' , 'name postfix used in output' , default = '' ) ! Output level call variable_settings % get ( output_item % output_level , 'output_level' , 'output level' , default = output_level_default ) else output_item % field => self % file % field_manager % select_for_output ( source_name ) ! Name of output variable (may differ from source name) call variable_settings % get ( output_item % name , 'name' , 'name used in output' , default = source_name ) end if call self % file % append_item ( output_item ) end subroutine end module","tags":"","loc":"sourcefile/output_manager.f90.html"},{"title":"netcdf_output.F90 – Fortran Program","text":"This file depends on sourcefile~~netcdf_output.f90~~EfferentGraph sourcefile~netcdf_output.f90 netcdf_output.F90 sourcefile~output_manager_core.f90 output_manager_core.F90 sourcefile~netcdf_output.f90->sourcefile~output_manager_core.f90 sourcefile~field_manager.f90 field_manager.F90 sourcefile~netcdf_output.f90->sourcefile~field_manager.f90 sourcefile~output_manager_core.f90->sourcefile~field_manager.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~netcdf_output.f90~~AfferentGraph sourcefile~netcdf_output.f90 netcdf_output.F90 sourcefile~output_manager.f90 output_manager.F90 sourcefile~output_manager.f90->sourcefile~netcdf_output.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules netcdf_output Source Code netcdf_output.F90 Source Code module netcdf_output use field_manager use output_manager_core use yaml_settings #ifdef NETCDF_FMT use netcdf implicit none public type_netcdf_file , NF90_FLOAT , NF90_DOUBLE public type_netcdf_variable_settings integer , save , public :: default_xtype = NF90_FLOAT integer , save , public :: default_coordinate_xtype = NF90_FLOAT private type , extends ( type_file ) :: type_netcdf_file integer :: itime = 0 ! Next time index in NetCDF file integer :: ncid = - 1 ! NetCDF identifier for file integer :: time_id = - 1 ! Identifier of time dimension integer :: reference_julian = - 1 integer :: reference_seconds = - 1 integer :: sync_interval = 1 ! Number of output time step between calls to nf90_sync (-1 to disable syncing) contains procedure :: configure procedure :: initialize procedure :: save procedure :: finalize procedure :: create_settings end type type , extends ( type_output_variable_settings ) :: type_netcdf_variable_settings integer :: varid = - 1 integer , allocatable :: start (:) integer , allocatable :: edges (:) integer :: itimedim = - 1 integer :: xtype = - 1 contains procedure :: initialize => netcdf_variable_settings_initialize end type contains subroutine configure ( self , settings ) class ( type_netcdf_file ), intent ( inout ) :: self class ( type_settings ), intent ( inout ) :: settings character ( len = :), allocatable :: time_reference logical :: success ! Determine time of first output (default to start of simulation) time_reference = settings % get_string ( 'time_reference' , 'reference date and time to use in time units' , default = '' ) if ( time_reference /= '' ) then call read_time_string ( time_reference , self % reference_julian , self % reference_seconds , success ) if (. not . success ) call host % fatal_error ( 'process_file' , 'Error parsing output.yaml: invalid value \"' // time_reference // '\" specified for ' // trim ( self % path ) // '/time_reference. Required format: yyyy-mm-dd HH:MM:SS.' ) end if ! Determine interval between calls to nf90_sync (default: after every output) call settings % get ( self % sync_interval , 'sync_interval' , 'number of output steps between sychronization to disk (<= 0: sync on close only)' , default = 1 ) end subroutine subroutine initialize ( self ) class ( type_netcdf_file ), intent ( inout ) :: self class ( type_base_output_field ), pointer :: output_field integer :: iret integer :: i integer , allocatable :: current_dim_ids (:) integer :: length character ( len = 19 ) :: time_string character ( len = 256 ) :: coordinates type ( type_dimension ), pointer :: dim class ( type_attribute ), pointer :: attribute character ( len = :), allocatable :: long_name , units , standard_name , path type ( type_dimension_pointer ), allocatable :: dimensions (:) real ( rk ) :: minimum , maximum , fill_value type ( type_attributes ) :: attributes type type_dimension_ids type ( type_dimension ), pointer :: dimension => null () integer :: netcdf_dimid = - 1 type ( type_dimension_ids ), pointer :: next => null () end type type ( type_dimension_ids ), pointer :: first_dim_id if (. not . associated ( self % first_field )) then call host % log_message ( 'NOTE: \"' // trim ( self % path ) // trim ( self % postfix ) // '.nc\" will not be created because it would contain no data.' ) return end if ! If no reference time is configured (to be used in time units), use time of first output. if ( self % reference_julian ==- 1 ) then self % reference_julian = self % first_julian self % reference_seconds = self % first_seconds end if first_dim_id => null () ! Create NetCDF file iret = nf90_create ( trim ( self % path ) // trim ( self % postfix ) // '.nc' , NF90_CLOBBER , self % ncid ); call check_err ( iret ) ! Create recommended CF global attributes if ( len ( trim ( self % title )) . gt . 0 ) then iret = nf90_put_att ( self % ncid , NF90_GLOBAL , 'title' , trim ( self % title )); call check_err ( iret ) end if #if 0 !      iret = nf90_put_att(self%ncid,NF90_GLOBAL,'institution','add an institution'); call check_err(iret) !      iret = nf90_put_att(self%ncid,NF90_GLOBAL,'source','add a source'); call check_err(iret) !      iret = nf90_put_att(self%ncid,NF90_GLOBAL,'history','add a history'); call check_err(iret) !      iret = nf90_put_att(self%ncid,NF90_GLOBAL,'references','add references'); call check_err(iret) #endif iret = nf90_put_att ( self % ncid , NF90_GLOBAL , 'comment' , 'file created by the GOTM output_manager' ); call check_err ( iret ) ! Create time coordinate dim => self % field_manager % find_dimension ( id_dim_time ) if ( self % is_dimension_used ( dim )) then iret = nf90_def_var ( self % ncid , trim ( dim % name ), NF90_DOUBLE ,( / get_dim_id ( dim ) / ), self % time_id ); call check_err ( iret ) call write_time_string ( self % reference_julian , self % reference_seconds , time_string ) iret = nf90_put_att ( self % ncid , self % time_id , 'long_name' , 'time' ); call check_err ( iret ) iret = nf90_put_att ( self % ncid , self % time_id , 'units' , 'seconds since ' // trim ( time_string )); call check_err ( iret ) iret = nf90_put_att ( self % ncid , self % time_id , 'calendar' , 'standard' ); call check_err ( iret ) end if ! Create variables output_field => self % first_field do while ( associated ( output_field )) call output_field % get_metadata ( long_name = long_name , units = units , dimensions = dimensions , minimum = minimum , maximum = maximum , fill_value = fill_value , standard_name = standard_name , path = path , attributes = attributes ) select type ( settings => output_field % settings ) class is ( type_netcdf_variable_settings ) ! Map internal dimension indices to indices in NetCDF file. allocate ( current_dim_ids ( size ( dimensions ))) do i = 1 , size ( dimensions ) current_dim_ids ( i ) = get_dim_id ( dimensions ( i )% p ) end do if ( settings % xtype == - 1 ) then if ( output_field % is_coordinate ) then settings % xtype = default_coordinate_xtype else settings % xtype = default_xtype end if end if iret = nf90_def_var ( self % ncid , trim ( output_field % output_name ), settings % xtype , current_dim_ids , settings % varid ); call check_err ( iret ) deallocate ( current_dim_ids ) iret = nf90_put_att ( self % ncid , settings % varid , 'units' , units ); call check_err ( iret ) iret = nf90_put_att ( self % ncid , settings % varid , 'long_name' , long_name ); call check_err ( iret ) if ( allocated ( standard_name )) iret = nf90_put_att ( self % ncid , settings % varid , 'standard_name' , standard_name ); call check_err ( iret ) if ( minimum /= default_minimum ) iret = put_att_typed_real ( self % ncid , settings % varid , 'valid_min' , minimum , settings % xtype ); call check_err ( iret ) if ( maximum /= default_maximum ) iret = put_att_typed_real ( self % ncid , settings % varid , 'valid_max' , maximum , settings % xtype ); call check_err ( iret ) if ( fill_value /= default_fill_value ) iret = put_att_typed_real ( self % ncid , settings % varid , '_FillValue' , fill_value , settings % xtype ); call check_err ( iret ) if ( fill_value /= default_fill_value ) iret = put_att_typed_real ( self % ncid , settings % varid , 'missing_value' , fill_value , settings % xtype ); call check_err ( iret ) if ( allocated ( path )) iret = nf90_put_att ( self % ncid , settings % varid , 'path' , path ); call check_err ( iret ) attribute => attributes % first do while ( associated ( attribute )) select type ( attribute ) class is ( type_real_attribute ) iret = nf90_put_att ( self % ncid , settings % varid , trim ( attribute % name ), attribute % value ); call check_err ( iret ) class is ( type_integer_attribute ) iret = nf90_put_att ( self % ncid , settings % varid , trim ( attribute % name ), attribute % value ); call check_err ( iret ) class is ( type_string_attribute ) iret = nf90_put_att ( self % ncid , settings % varid , trim ( attribute % name ), trim ( attribute % value )); call check_err ( iret ) end select attribute => attribute % next end do coordinates = '' do i = 1 , size ( output_field % coordinates ) if ( associated ( output_field % coordinates ( i )% p )) coordinates = trim ( coordinates ) // ' ' // trim ( output_field % coordinates ( i )% p % output_name ) end do if ( coordinates /= '' ) then iret = nf90_put_att ( self % ncid , settings % varid , 'coordinates' , trim ( coordinates ( 2 :))); call check_err ( iret ) end if ! Fill arrays with start index and count per dimension allocate ( settings % start ( size ( dimensions ))) allocate ( settings % edges ( size ( dimensions ))) do i = 1 , size ( dimensions ) if ( dimensions ( i )% p % id == id_dim_time ) then settings % start ( i ) = self % itime settings % edges ( i ) = 1 settings % itimedim = i else settings % start ( i ) = 1 settings % edges ( i ) = dimensions ( i )% p % length end if end do end select output_field => output_field % next end do ! Exit define mode iret = nf90_enddef ( self % ncid ); call check_err ( iret ) contains integer function get_dim_id ( dim ) type ( type_dimension ), pointer :: dim type ( type_dimension_ids ), pointer :: dim_id dim_id => first_dim_id do while ( associated ( dim_id )) if ( dim_id % dimension % name == dim % name . and . dim_id % dimension % length == dim % length ) exit dim_id => dim_id % next end do if (. not . associated ( dim_id )) then allocate ( dim_id ) dim_id % dimension => dim dim_id % next => first_dim_id first_dim_id => dim_id if ( dim % id == id_dim_time ) then length = NF90_UNLIMITED else length = dim % length end if iret = nf90_def_dim ( self % ncid , trim ( dim % name ), length , dim_id % netcdf_dimid ); call check_err ( iret ) end if get_dim_id = dim_id % netcdf_dimid end function end subroutine initialize function put_att_typed_real ( ncid , varid , name , value , data_type ) result ( iret ) integer , intent ( in ) :: ncid , varid , data_type character ( len =* ), intent ( in ) :: name real ( rk ), intent ( in ) :: value integer :: iret select case ( data_type ) case ( NF90_FLOAT ) iret = nf90_put_att ( ncid , varid , name , real ( value , kind ( NF90_FILL_FLOAT ))) case ( NF90_DOUBLE ) iret = nf90_put_att ( ncid , varid , name , real ( value , kind ( NF90_FILL_DOUBLE ))) case default call host % fatal_error ( 'put_real_att' , 'invalid value for data_type' ) end select end function put_att_typed_real function create_settings ( self ) result ( settings ) class ( type_netcdf_file ), intent ( inout ) :: self class ( type_output_variable_settings ), pointer :: settings allocate ( type_netcdf_variable_settings :: settings ) end function create_settings subroutine save ( self , julianday , secondsofday , microseconds ) class ( type_netcdf_file ), intent ( inout ) :: self integer , intent ( in ) :: julianday , secondsofday , microseconds class ( type_base_output_field ), pointer :: output_field integer :: iret real ( rk ) :: time_value if ( self % ncid ==- 1 ) return ! Increment time index self % itime = self % itime + 1 ! Store time coordinate if ( self % time_id /=- 1 ) then time_value = ( julianday - self % reference_julian ) * real ( 86400 , rk ) + secondsofday - self % reference_seconds + microseconds * 1.e-6_rk iret = nf90_put_var ( self % ncid , self % time_id , time_value ,( / self % itime / )) if ( iret /= NF90_NOERR ) call host % fatal_error ( 'netcdf_output:save' , 'error saving variable \"time\" to ' // trim ( self % path ) // trim ( self % postfix ) // '.nc: ' // nf90_strerror ( iret )) end if output_field => self % first_field do while ( associated ( output_field )) select type ( settings => output_field % settings ) class is ( type_netcdf_variable_settings ) if ( settings % itimedim /=- 1 ) settings % start ( settings % itimedim ) = self % itime if ( associated ( output_field % data % p3d )) then iret = nf90_put_var ( self % ncid , settings % varid , output_field % data % p3d , settings % start , settings % edges ) elseif ( associated ( output_field % data % p2d )) then iret = nf90_put_var ( self % ncid , settings % varid , output_field % data % p2d , settings % start , settings % edges ) elseif ( associated ( output_field % data % p1d )) then iret = nf90_put_var ( self % ncid , settings % varid , output_field % data % p1d , settings % start , settings % edges ) elseif ( associated ( output_field % data % p0d )) then iret = nf90_put_var ( self % ncid , settings % varid , output_field % data % p0d , settings % start ) end if if ( iret /= NF90_NOERR ) call host % fatal_error ( 'netcdf_output:save' , 'error saving variable \"' // trim ( output_field % output_name ) // '\" to ' // trim ( self % path ) // trim ( self % postfix ) // '.nc: ' // nf90_strerror ( iret )) end select output_field => output_field % next end do if ( self % sync_interval > 0 . and . mod ( self % itime , self % sync_interval ) == 0 ) then iret = nf90_sync ( self % ncid ) if ( iret /= NF90_NOERR ) call host % fatal_error ( 'netcdf_output:save' , 'error in call to nf90_sync for ' // trim ( self % path ) // trim ( self % postfix ) // '.nc: ' // nf90_strerror ( iret )) end if end subroutine save subroutine finalize ( self ) class ( type_netcdf_file ), intent ( inout ) :: self integer :: iret if ( self % ncid /=- 1 ) then iret = nf90_close ( self % ncid ); call check_err ( iret ) end if end subroutine finalize subroutine check_err ( iret ) integer , intent ( in ) :: iret if ( iret /= NF90_NOERR ) & call host % fatal_error ( 'check_err' , nf90_strerror ( iret )) end subroutine subroutine netcdf_variable_settings_initialize ( self , settings , parent ) class ( type_netcdf_variable_settings ), intent ( inout ) :: self class ( type_settings ), intent ( inout ) :: settings class ( type_output_variable_settings ), optional , intent ( in ) :: parent call self % type_output_variable_settings % initialize ( settings , parent ) if ( present ( parent )) then select type ( parent ) class is ( type_netcdf_variable_settings ) self % xtype = parent % xtype end select end if call settings % get ( self % xtype , 'xtype' , 'data type' , options = ( / type_option ( - 1 , 'default' , 'default' ), type_option ( NF90_FLOAT , '32-bit float' , 'single' ), type_option ( NF90_DOUBLE , '64-bit double' , 'double' ) / ), default = self % xtype ) end subroutine netcdf_variable_settings_initialize #endif end module netcdf_output","tags":"","loc":"sourcefile/netcdf_output.f90.html"},{"title":"text_output.F90 – Fortran Program","text":"This file depends on sourcefile~~text_output.f90~~EfferentGraph sourcefile~text_output.f90 text_output.F90 sourcefile~output_manager_core.f90 output_manager_core.F90 sourcefile~text_output.f90->sourcefile~output_manager_core.f90 sourcefile~field_manager.f90 field_manager.F90 sourcefile~text_output.f90->sourcefile~field_manager.f90 sourcefile~output_manager_core.f90->sourcefile~field_manager.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~text_output.f90~~AfferentGraph sourcefile~text_output.f90 text_output.F90 sourcefile~output_manager.f90 output_manager.F90 sourcefile~output_manager.f90->sourcefile~text_output.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules text_output Source Code text_output.F90 Source Code module text_output use field_manager use output_manager_core implicit none public type_text_file private character , parameter :: separator = char ( 9 ) character ( len = 4 ), parameter :: extension = '.txt' type , abstract :: type_single_text_file character ( len = max_path ) :: path = '' character ( len = max_path ) :: title = '' integer :: unit = - 1 class ( type_single_text_file ), pointer :: next => null () contains procedure ( host_write_header ), deferred :: write_header procedure ( host_write_data ), deferred :: write_data end type abstract interface subroutine host_write_header ( self ) import type_single_text_file class ( type_single_text_file ), intent ( in ) :: self end subroutine end interface abstract interface subroutine host_write_data ( self , timestr ) import type_single_text_file class ( type_single_text_file ), intent ( in ) :: self character ( len =* ), intent ( in ) :: timestr end subroutine end interface type type_scalar class ( type_base_output_field ), pointer :: field => null () real ( rk ), pointer :: value => null () end type type , extends ( type_single_text_file ) :: type_single_text_file_with_scalars type ( type_scalar ), allocatable :: variables (:) type ( type_scalar ), allocatable :: constants (:) contains procedure :: write_header => single_text_file_with_scalars_write_header procedure :: write_data => single_text_file_with_scalars_write_data end type type , extends ( type_single_text_file ) :: type_single_text_file_with_1d_variable class ( type_base_output_field ), pointer :: field => null () type ( type_dimension ), pointer :: dimension => null () class ( type_base_output_field ), pointer :: coordinate => null () real ( rk ), pointer :: values (:) => null () contains procedure :: write_header => single_text_file_with_1d_variable_write_header procedure :: write_data => single_text_file_with_1d_variable_write_data end type type , extends ( type_file ) :: type_text_file class ( type_single_text_file ), pointer :: first_file => null () contains procedure :: initialize procedure :: save procedure :: finalize end type contains subroutine initialize ( self ) class ( type_text_file ), intent ( inout ) :: self integer :: ios integer :: i integer :: nscalar , nconstants class ( type_base_output_field ), pointer :: output_field class ( type_single_text_file_with_scalars ), pointer :: scalar_file class ( type_single_text_file ), pointer :: current_file class ( type_single_text_file_with_1d_variable ), pointer :: file_with_1d_data type ( type_dimension_pointer ), allocatable :: dimensions (:) nscalar = 0 nconstants = 0 output_field => self % first_field do while ( associated ( output_field )) if ( associated ( output_field % data % p1d )) then ! 1D variable - create separate file for it allocate ( file_with_1d_data ) file_with_1d_data % field => output_field file_with_1d_data % values => output_field % data % p1d file_with_1d_data % path = trim ( self % path ) // '_' // trim ( file_with_1d_data % field % output_name ) // trim ( self % postfix ) // extension file_with_1d_data % title = self % title call output_field % get_metadata ( dimensions = dimensions ) do i = 1 , size ( dimensions ) if ( dimensions ( i )% p % length > 1 ) then file_with_1d_data % dimension => dimensions ( i )% p file_with_1d_data % coordinate => output_field % coordinates ( i )% p exit end if end do file_with_1d_data % next => self % first_file self % first_file => file_with_1d_data elseif ( associated ( output_field % data % p0d )) then ! 0D variable - just count these variables for now. if ( has_dimension ( dimensions , id_dim_time )) then nscalar = nscalar + 1 else nconstants = nconstants + 1 end if else call host % log_message ( 'WARNING: in output file \"' // trim ( self % path ) // '\", skipping variable \"' // trim ( output_field % output_name ) & // '\" because it has more than one non-singleton dimension. Currently only 0D and 1D variables are supported in text output.' ) end if output_field => output_field % next end do ! If we have one or more 0d fields to write, add the file with scalars to our list. if ( nscalar > 0 ) then allocate ( scalar_file ) scalar_file % path = trim ( self % path ) // trim ( self % postfix ) // extension scalar_file % title = self % title allocate ( scalar_file % variables ( nscalar )) allocate ( scalar_file % constants ( nconstants )) nscalar = 0 nconstants = 0 output_field => self % first_field do while ( associated ( output_field )) if ( associated ( output_field % data % p0d )) then if ( has_dimension ( dimensions , id_dim_time )) then nscalar = nscalar + 1 scalar_file % variables ( nscalar )% field => output_field scalar_file % variables ( nscalar )% value => output_field % data % p0d else nconstants = nconstants + 1 scalar_file % constants ( nconstants )% field => output_field scalar_file % constants ( nconstants )% value => output_field % data % p0d end if end if output_field => output_field % next end do scalar_file % next => self % first_file self % first_file => scalar_file end if if (. not . associated ( self % first_file )) then call host % log_message ( 'NOTE: output \"' // trim ( self % path ) // trim ( self % postfix ) // '\" will not be created because it would contain no data.' ) return end if current_file => self % first_file do while ( associated ( current_file )) ! Open file current_file % unit = get_free_unit ( 1000 , 10000 ) open ( unit = current_file % unit , file = current_file % path , action = 'write' , status = 'replace' , iostat = ios ) if ( ios /= 0 ) call host % fatal_error ( 'type_text_file::initialize' , 'Failed to open \"' // trim ( current_file % path ) // '\" for writing.' ) ! Write header call current_file % write_header () current_file => current_file % next end do end subroutine initialize subroutine save ( self , julianday , secondsofday , microseconds ) class ( type_text_file ), intent ( inout ) :: self integer , intent ( in ) :: julianday , secondsofday , microseconds character ( len = 19 ) :: timestr class ( type_single_text_file ), pointer :: current_file call write_time_string ( julianday , secondsofday , timestr ) current_file => self % first_file do while ( associated ( current_file )) call current_file % write_data ( timestr ) current_file => current_file % next end do end subroutine save subroutine finalize ( self ) class ( type_text_file ), intent ( inout ) :: self class ( type_single_text_file ), pointer :: current_file current_file => self % first_file do while ( associated ( current_file )) close ( current_file % unit ) current_file => current_file % next end do end subroutine finalize subroutine single_text_file_with_scalars_write_header ( self ) class ( type_single_text_file_with_scalars ), intent ( in ) :: self integer :: i character ( len = :), allocatable :: long_name , units ! Header (three lines: simulation title, variable short names, variable long names + units) write ( self % unit , fmt = '(\"# title: \",A)' ) trim ( self % title ) do i = 1 , size ( self % constants ) call self % constants ( i )% field % get_metadata ( long_name = long_name , units = units ) write ( self % unit , fmt = '(\"# \",A,\": \",G0.8,X,A)' ) trim ( long_name ), self % constants ( i )% value , trim ( units ) end do write ( self % unit , fmt = '(\"# \",A,*(:,\"' // trim ( separator ) // '\",A))' ) 'time' ,( trim ( self % variables ( i )% field % output_name ), i = 1 , size ( self % variables )) write ( self % unit , fmt = '(\"# \",A)' , advance = 'NO' ) 'time' do i = 1 , size ( self % variables ) call self % variables ( i )% field % get_metadata ( long_name = long_name , units = units ) write ( self % unit , fmt = '(\"' // trim ( separator ) // '\",A,\" (\",A,\")\")' , advance = 'NO' ) trim ( long_name ), trim ( units ) end do write ( self % unit , * ) end subroutine single_text_file_with_scalars_write_header subroutine single_text_file_with_scalars_write_data ( self , timestr ) class ( type_single_text_file_with_scalars ), intent ( in ) :: self character ( len =* ), intent ( in ) :: timestr integer :: i write ( self % unit , fmt = '(A,*(:,\"' // separator // '\",G0.8))' ) timestr ,( self % variables ( i )% value , i = 1 , size ( self % variables )) end subroutine single_text_file_with_scalars_write_data subroutine single_text_file_with_1d_variable_write_header ( self ) class ( type_single_text_file_with_1d_variable ), intent ( in ) :: self character ( len = :), allocatable :: long_name , units type ( type_dimension_pointer ), allocatable :: dimensions (:) integer :: i logical :: first , has_singleton , real_x class ( type_base_output_field ), pointer :: coordinate ! Simulation title write ( self % unit , fmt = '(\"# title: \",A)' ) trim ( self % title ) ! Variable name and units call self % field % get_metadata ( long_name = long_name , units = units , dimensions = dimensions ) write ( self % unit , fmt = '(\"# variable: \",A,\" (\",A,\")\")' ) trim ( long_name ), trim ( units ) ! Dimensions write ( self % unit , fmt = '(\"# dimensions: \")' , advance = 'NO' ) first = . true . has_singleton = . false . do i = 1 , size ( dimensions ) if ( dimensions ( i )% p % id == id_dim_time ) cycle if (. not . first ) write ( self % unit , fmt = '(A)' , advance = 'NO' ) ',' write ( self % unit , fmt = '(A,\"=\")' , advance = 'NO' ) trim ( dimensions ( i )% p % name ) if ( dimensions ( i )% p % length > 1 ) then ! This is the only non-singleton dimension (length>1). write ( self % unit , fmt = '(I0,\":\",I0)' , advance = 'NO' ) 1 , self % dimension % length else ! This is a singleton dimension (length=1). has_singleton = . true . write ( self % unit , fmt = '(A)' , advance = 'NO' ) '1' end if first = . false . end do write ( self % unit , * ) ! Coordinates associated with singleton dimensions (length=1). if ( has_singleton ) then write ( self % unit , fmt = '(\"# fixed coordinates:\")' ) do i = 1 , size ( dimensions ) if ( dimensions ( i )% p % id /= id_dim_time . and . dimensions ( i )% p % length == 1 ) then coordinate => self % field % coordinates ( i )% p if ( associated ( coordinate )) then call coordinate % get_metadata ( long_name = long_name , units = units ) write ( self % unit , fmt = '(\"#   \",A,\": \",G0.8,X,A)' ) trim ( long_name ), coordinate % data % p0d , trim ( units ) end if end if end do end if ! Row dimension write ( self % unit , fmt = '(\"# rows: time\")' ) ! Column dimension real_x = . false . if ( associated ( self % coordinate )) then call self % coordinate % get_metadata ( long_name = long_name , units = units , dimensions = dimensions ) if ( associated ( self % coordinate , self % field )) then ! The variable being saved is itself the coordinate variable. write ( self % unit , fmt = '(\"# columns: \",A)' ) trim ( long_name ) elseif ( associated ( self % coordinate % data % p1d ). and .. not . has_dimension ( dimensions , id_dim_time )) then ! The coordinate variable is 1D and time-invariant. We will use it as column header. real_x = . true . write ( self % unit , fmt = '(\"# columns: \",A,\" (\",A,\")\")' ) trim ( long_name ), trim ( units ) else ! The coordinate variable is multidimensional (possibly because it is time-varying). It'll be included in a separate file. write ( self % unit , fmt = '(\"# columns: \",A,\" (for values see \",A,\")\")' ) trim ( long_name ), self % path ( 1 : len_trim ( self % path ) - len ( extension ) - len_trim ( self % field % output_name )) // trim ( self % coordinate % output_name ) // extension end if else ! No coordinate variable specified. Just use the dimension name. write ( self % unit , fmt = '(\"# columns: \",A)' ) self % dimension % name end if ! Column names if ( real_x ) then ! Use actual coordinate in column header. write ( self % unit , fmt = '(\"# time\",*(:,\"' // trim ( separator ) // '\",G0.8))' ) self % coordinate % data % p1d else ! Use dimension indices in column header. write ( self % unit , fmt = '(\"# time\",*(:,\"' // trim ( separator ) // '\",I0))' ) ( i , i = 1 , self % dimension % length ) end if end subroutine single_text_file_with_1d_variable_write_header subroutine single_text_file_with_1d_variable_write_data ( self , timestr ) class ( type_single_text_file_with_1d_variable ), intent ( in ) :: self character ( len =* ), intent ( in ) :: timestr write ( self % unit , fmt = '(A,*(:,\"' // separator // '\",G0.8))' ) timestr , self % values end subroutine single_text_file_with_1d_variable_write_data function get_free_unit ( start , stop ) result ( unit ) integer , intent ( in ) :: start , stop integer :: unit logical :: opened do unit = start , stop inquire ( unit = unit , opened = opened ) if (. not . opened ) return end do unit = - 1 end function get_free_unit end module text_output","tags":"","loc":"sourcefile/text_output.f90.html"},{"title":"time_average.F90 – Fortran Program","text":"This file depends on sourcefile~~time_average.f90~~EfferentGraph sourcefile~time_average.f90 time_average.F90 sourcefile~output_manager_core.f90 output_manager_core.F90 sourcefile~time_average.f90->sourcefile~output_manager_core.f90 sourcefile~field_manager.f90 field_manager.F90 sourcefile~time_average.f90->sourcefile~field_manager.f90 sourcefile~base.f90 base.F90 sourcefile~time_average.f90->sourcefile~base.f90 sourcefile~output_manager_core.f90->sourcefile~field_manager.f90 sourcefile~base.f90->sourcefile~output_manager_core.f90 sourcefile~base.f90->sourcefile~field_manager.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~time_average.f90~~AfferentGraph sourcefile~time_average.f90 time_average.F90 sourcefile~library.f90 library.F90 sourcefile~library.f90->sourcefile~time_average.f90 sourcefile~output_manager.f90 output_manager.F90 sourcefile~output_manager.f90->sourcefile~time_average.f90 sourcefile~output_manager.f90->sourcefile~library.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules output_operators_time_average Source Code time_average.F90 Source Code module output_operators_time_average use output_manager_core use field_manager use output_operators_base implicit none private public type_time_average_operator type , extends ( type_base_operator ) :: type_time_average_operator integer :: method = time_method_mean contains procedure :: apply end type type , extends ( type_universal_operator_result ) :: type_result integer :: method = time_method_mean integer :: n = 0 contains procedure :: flag_as_required procedure :: new_data procedure :: before_save procedure :: get_metadata end type contains function apply ( self , source ) result ( output_field ) class ( type_time_average_operator ), intent ( inout ), target :: self class ( type_base_output_field ), target :: source class ( type_base_output_field ), pointer :: output_field real ( rk ) :: fill_value type ( type_dimension_pointer ), allocatable :: dimensions (:) integer :: itimedim class ( type_result ), pointer :: result call source % get_metadata ( dimensions = dimensions , fill_value = fill_value ) do itimedim = 1 , size ( dimensions ) if ( dimensions ( itimedim )% p % id == id_dim_time ) exit end do if ( itimedim > size ( dimensions )) then output_field => source return end if allocate ( result ) result % operator => self result % source => source result % output_name = 'time_average(' // trim ( result % source % output_name ) // ')' output_field => result result % method = self % method if ( associated ( result % source % data % p3d )) then allocate ( result % result_3d ( size ( result % source % data % p3d , 1 ), size ( result % source % data % p3d , 2 ), size ( result % source % data % p3d , 3 ))) result % data % p3d => result % result_3d elseif ( associated ( result % source % data % p2d )) then allocate ( result % result_2d ( size ( result % source % data % p2d , 1 ), size ( result % source % data % p2d , 2 ))) result % data % p2d => result % result_2d elseif ( associated ( result % source % data % p1d )) then allocate ( result % result_1d ( size ( result % source % data % p1d ))) result % data % p1d => result % result_1d elseif ( associated ( result % source % data % p0d )) then result % data % p0d => result % result_0d end if if ( self % method == time_method_mean ) call result % fill ( fill_value ) end function recursive subroutine flag_as_required ( self , required ) class ( type_result ), intent ( inout ) :: self logical , intent ( in ) :: required call self % source % flag_as_required (. true .) end subroutine recursive subroutine new_data ( self ) class ( type_result ), intent ( inout ) :: self call self % source % before_save () if ( self % n == 0 ) call self % fill ( 0.0_rk ) if ( allocated ( self % result_3d )) then self % result_3d (:,:,:) = self % result_3d + self % source % data % p3d elseif ( allocated ( self % result_2d )) then self % result_2d (:,:) = self % result_2d + self % source % data % p2d elseif ( allocated ( self % result_1d )) then self % result_1d (:) = self % result_1d + self % source % data % p1d else self % result_0d = self % result_0d + self % source % data % p0d end if self % n = self % n + 1 end subroutine recursive subroutine before_save ( self ) class ( type_result ), intent ( inout ) :: self if ( self % method == time_method_mean ) then if ( allocated ( self % result_3d )) then self % result_3d (:,:,:) = self % result_3d / self % n elseif ( allocated ( self % result_2d )) then self % result_2d (:,:) = self % result_2d / self % n elseif ( allocated ( self % result_1d )) then self % result_1d (:) = self % result_1d / self % n else self % result_0d = self % result_0d / self % n end if end if self % n = 0 end subroutine recursive subroutine get_metadata ( self , long_name , units , dimensions , minimum , maximum , fill_value , standard_name , path , attributes ) class ( type_result ), intent ( in ) :: self character ( len = :), allocatable , intent ( out ), optional :: long_name , units , standard_name , path type ( type_dimension_pointer ), allocatable , intent ( out ), optional :: dimensions (:) real ( rk ), intent ( out ), optional :: minimum , maximum , fill_value type ( type_attributes ), intent ( out ), optional :: attributes ! Workaround for gfortran BUG 88511 - passing optional allocatable deferred length character arguments to the next routine causes memory corruption character ( len = :), allocatable :: long_name2 , units2 , standard_name2 , path2 call self % type_universal_operator_result % get_metadata ( long_name2 , units2 , dimensions , minimum , maximum , fill_value , standard_name2 , path2 , attributes ) ! Workaround for gfortran if ( present ( long_name ) . and . allocated ( long_name2 )) long_name = long_name2 if ( present ( units ) . and . allocated ( units2 )) units = units2 if ( present ( standard_name ) . and . allocated ( standard_name2 )) standard_name = standard_name2 if ( present ( path ) . and . allocated ( path2 )) path = path2 if ( present ( attributes )) then select case ( self % method ) case ( time_method_mean ) call attributes % set ( 'cell_methods' , 'time: mean' ) case default call attributes % set ( 'cell_methods' , 'time: sum' ) end select end if end subroutine end module","tags":"","loc":"sourcefile/time_average.f90.html"},{"title":"interp.F90 – Fortran Program","text":"This file depends on sourcefile~~interp.f90~~EfferentGraph sourcefile~interp.f90 interp.F90 sourcefile~output_manager_core.f90 output_manager_core.F90 sourcefile~interp.f90->sourcefile~output_manager_core.f90 sourcefile~field_manager.f90 field_manager.F90 sourcefile~interp.f90->sourcefile~field_manager.f90 sourcefile~base.f90 base.F90 sourcefile~interp.f90->sourcefile~base.f90 sourcefile~output_manager_core.f90->sourcefile~field_manager.f90 sourcefile~base.f90->sourcefile~output_manager_core.f90 sourcefile~base.f90->sourcefile~field_manager.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~interp.f90~~AfferentGraph sourcefile~interp.f90 interp.F90 sourcefile~library.f90 library.F90 sourcefile~library.f90->sourcefile~interp.f90 sourcefile~output_manager.f90 output_manager.F90 sourcefile~output_manager.f90->sourcefile~library.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules output_operators_interp Source Code interp.F90 Source Code module output_operators_interp use output_manager_core use field_manager use yaml_settings use output_operators_base implicit none private public type_interp_operator type , extends ( type_base_operator ) :: type_interp_operator character ( len = string_length ) :: dimension character ( len = string_length ) :: target_dimension_name character ( len = string_length ) :: target_long_name character ( len = string_length ) :: target_standard_name real ( rk ), allocatable :: target_coordinates (:) type ( type_field ), pointer :: source_field => null () type ( type_field ), pointer :: offset_field => null () integer :: out_of_bounds_treatment = 1 real ( rk ) :: offset_scale = 1._rk type ( type_dimension ), pointer :: target_dimension => null () contains procedure :: configure procedure :: apply end type type , extends ( type_operator_result ) :: type_result integer :: idim = - 1 integer :: idatadim = - 1 class ( type_base_output_field ), pointer :: source_coordinate => null () class ( type_base_output_field ), pointer :: offset => null () integer :: out_of_bounds_treatment = 1 real ( rk ) :: out_of_bounds_value real ( rk ), allocatable :: target_coordinates (:) real ( rk ) :: offset_scale = 1._rk contains procedure :: flag_as_required procedure :: before_save procedure :: get_field end type type , extends ( type_list_populator ) :: type_coordinate_list_populator class ( type_interp_operator ), pointer :: operator => null () contains procedure :: set_length => coordinate_list_set_length procedure :: create => coordinate_list_create_element end type contains subroutine configure ( self , settings , field_manager ) class ( type_interp_operator ), target , intent ( inout ) :: self class ( type_settings ), intent ( inout ) :: settings type ( type_field_manager ), intent ( inout ) :: field_manager type ( type_dimension ), pointer :: dim character ( len = string_length ) :: variable_name class ( type_coordinate_list_populator ), pointer :: populator call settings % get ( self % dimension , 'dimension' , 'dimension to interpolate' ) ! Verify target dimension has been registered with field manager dim => field_manager % first_dimension do while ( associated ( dim )) if ( dim % name == self % dimension ) exit dim => dim % next end do if (. not . associated ( dim )) call host % fatal_error ( 'type_interp_operator%initialize' , & 'Dimension \"' // trim ( self % dimension ) // '\" has not been registered with the field manager.' ) call settings % get ( self % out_of_bounds_treatment , 'out_of_bounds_treatment' , 'out-of-bounds treatment' , options = ( / type_option ( 1 , 'mask' ), type_option ( 2 , 'nearest' ), type_option ( 3 , 'extrapolate' ) / ), default = 1 ) variable_name = settings % get_string ( 'offset' , 'variable to use as offset' , default = '' ) if ( variable_name /= '' ) then if ( variable_name ( 1 : 1 ) == '-' ) then self % offset_scale = - 1._rk variable_name = variable_name ( 2 :) end if self % offset_field => field_manager % select_for_output ( trim ( variable_name )) end if variable_name = settings % get_string ( 'source_coordinate' , 'variable with source coordinates' , default = '' ) if ( variable_name /= '' ) self % source_field => field_manager % select_for_output ( trim ( variable_name )) allocate ( populator ) populator % operator => self call settings % get_list ( 'coordinates' , populator ) call settings % get ( self % target_dimension_name , 'target_dimension' , 'name for new interpolated dimension' , default = trim ( self % dimension )) call settings % get ( self % target_long_name , 'target_long_name' , 'long name for new coordinate variable' , default = '' ) call settings % get ( self % target_standard_name , 'target_standard_name' , 'standard name for new coordinate variable' , default = '' ) end subroutine recursive subroutine coordinate_list_set_length ( self , n ) class ( type_coordinate_list_populator ), intent ( inout ) :: self integer , intent ( in ) :: n allocate ( self % operator % target_coordinates ( n )) end subroutine recursive subroutine coordinate_list_create_element ( self , index , item ) class ( type_coordinate_list_populator ), intent ( inout ) :: self integer , intent ( in ) :: index type ( type_list_item ), intent ( inout ) :: item character ( len = 4 ) :: strindex class ( type_real_setting ), pointer :: real_setting write ( strindex , '(i0)' ) index real_setting => type_real_setting_create ( item , self % operator % target_coordinates ( index ), 'value ' // trim ( strindex ), '' ) if ( index > 1 ) then if ( self % operator % target_coordinates ( index ) < self % operator % target_coordinates ( index - 1 )) call host % fatal_error ( 'type_interp_operator%configure' , trim ( item % value % parent % path ) // ' should be monotonically increasing.' ) end if end subroutine function apply ( self , source ) result ( output_field ) class ( type_interp_operator ), intent ( inout ), target :: self class ( type_base_output_field ), target :: source class ( type_base_output_field ), pointer :: output_field type ( type_dimension_pointer ), allocatable :: dimensions (:) real ( rk ) :: out_of_bounds_value integer :: idim , i class ( type_result ), pointer :: result character ( len = :), allocatable :: long_name , units , standard_name , long_name2 integer , allocatable :: extents (:) call source % get_metadata ( dimensions = dimensions , fill_value = out_of_bounds_value ) do idim = 1 , size ( dimensions ) if ( dimensions ( idim )% p % name == self % dimension ) exit end do if ( idim > size ( dimensions )) then output_field => source return end if if ( dimensions ( idim )% p % length == 1 ) call host % fatal_error ( 'type_interp_operator%initialize' , & 'Cannot use interp on dimension ' // trim ( self % dimension ) // ' because it has length 1.' ) if ( self % out_of_bounds_treatment == 1 . and . out_of_bounds_value == default_fill_value ) & call host % fatal_error ( 'type_interp_operator%initialize' , 'Cannot use out_of_bounds_value=1 because ' // trim ( source % output_name ) // ' does not have fill_value set.' ) allocate ( result ) result % operator => self result % source => source result % output_name = 'interp(' // trim ( result % source % output_name ) // ')' output_field => result result % idim = idim result % out_of_bounds_value = out_of_bounds_value result % out_of_bounds_treatment = self % out_of_bounds_treatment result % offset_scale = self % offset_scale allocate ( result % target_coordinates ( size ( self % target_coordinates ))) result % target_coordinates (:) = self % target_coordinates (:) ! Data dim is idim with singletons removed result % idatadim = 0 do i = 1 , result % idim if ( dimensions ( i )% p % length > 1 ) result % idatadim = result % idatadim + 1 end do if (. not . associated ( self % source_field )) then if (. not . associated ( dimensions ( idim )% p % coordinate )) call host % fatal_error ( 'type_interp_operator%initialize' , & 'Dimension ' // trim ( self % dimension ) // ' does not have a default coordinate. & &You need to explicitly specify the source coordinate with the source_coordinate attribute to the interp operator.' ) self % source_field => dimensions ( idim )% p % coordinate end if result % source_coordinate => result % source % get_field ( self % source_field ) if ( associated ( self % offset_field )) result % offset => result % source % get_field ( self % offset_field ) if (. not . associated ( self % target_dimension )) then allocate ( self % target_dimension ) self % target_dimension % name = trim ( self % target_dimension_name ) self % target_dimension % length = size ( self % target_coordinates ) self % target_dimension % global_length = self % target_dimension % length allocate ( self % target_dimension % coordinate ) call self % target_dimension % coordinate % data % set ( self % target_coordinates ) self % target_dimension % coordinate % status = status_registered_with_data self % target_dimension % coordinate % name = trim ( self % target_dimension_name ) call result % source_coordinate % get_metadata ( long_name = long_name , units = units , standard_name = standard_name ) if ( self % target_long_name /= '' ) then self % target_dimension % coordinate % long_name = trim ( self % target_long_name ) elseif (. not . associated ( result % offset )) then self % target_dimension % coordinate % long_name = long_name else call result % offset % get_metadata ( long_name = long_name2 ) self % target_dimension % coordinate % long_name = long_name // ' relative to ' // long_name2 end if if ( self % target_standard_name /= '' ) then self % target_dimension % coordinate % standard_name = trim ( self % target_standard_name ) elseif (. not . associated ( result % offset )) then self % target_dimension % coordinate % standard_name = standard_name end if self % target_dimension % coordinate % units = units allocate ( self % target_dimension % coordinate % dimensions ( 1 )) self % target_dimension % coordinate % dimensions ( 1 )% p => self % target_dimension end if allocate ( result % dimensions ( size ( dimensions ))) result % dimensions (:) = dimensions result % dimensions ( result % idim )% p => self % target_dimension call source % data % get_extents ( extents ) extents ( result % idatadim ) = size ( self % target_coordinates ) select case ( size ( extents )) case ( 3 ) if ( result % idatadim /= 3 ) call host % fatal_error ( 'type_interp_operator%initialize' , 'interp can currently only operate along 3rd dimension of 3D arrays.' ) allocate ( result % result_3d ( extents ( 1 ), extents ( 2 ), extents ( 3 ))) call result % data % set ( result % result_3d ) case ( 2 ) if ( result % idatadim /= 2 ) call host % fatal_error ( 'type_interp_operator%initialize' , 'interp can currently only operate along 2nd dimension of 2D arrays.' ) allocate ( result % result_2d ( extents ( 1 ), extents ( 2 ))) call result % data % set ( result % result_2d ) case ( 1 ) allocate ( result % result_1d ( size ( self % target_coordinates ))) call result % data % set ( result % result_1d ) end select call result % fill ( result % out_of_bounds_value ) end function recursive subroutine flag_as_required ( self , required ) class ( type_result ), intent ( inout ) :: self logical , intent ( in ) :: required call self % type_operator_result % flag_as_required ( required ) if ( associated ( self % source_coordinate )) call self % source_coordinate % flag_as_required ( required ) if ( associated ( self % offset )) call self % offset % flag_as_required ( required ) end subroutine recursive subroutine before_save ( self ) class ( type_result ), intent ( inout ) :: self integer :: i , j real ( rk ) :: offset real ( rk ), allocatable :: source_coordinate (:) call self % type_operator_result % before_save () if ( self % idim == - 1 ) return if ( associated ( self % source % data % p3d )) then allocate ( source_coordinate ( size ( self % source % data % p3d , self % idatadim ))) if ( associated ( self % source_coordinate % data % p1d )) source_coordinate (:) = self % source_coordinate % data % p1d do j = 1 , size ( self % source % data % p3d , 2 ) do i = 1 , size ( self % source % data % p3d , 1 ) offset = 0._rk if ( associated ( self % offset )) offset = self % offset_scale * self % offset % data % p2d ( i , j ) if ( associated ( self % source_coordinate % data % p3d )) source_coordinate (:) = self % source_coordinate % data % p3d ( i , j ,:) call interp ( self % target_coordinates (:) + offset , source_coordinate , self % source % data % p3d ( i , j ,:), self % result_3d ( i , j ,:), self % out_of_bounds_treatment , self % out_of_bounds_value ) end do end do elseif ( associated ( self % source % data % p2d )) then allocate ( source_coordinate ( size ( self % source % data % p2d , self % idatadim ))) if ( associated ( self % source_coordinate % data % p1d )) source_coordinate (:) = self % source_coordinate % data % p1d do i = 1 , size ( self % source % data % p2d , 1 ) offset = 0._rk if ( associated ( self % offset )) offset = self % offset_scale * self % offset % data % p1d ( i ) if ( associated ( self % source_coordinate % data % p2d )) source_coordinate (:) = self % source_coordinate % data % p2d ( i ,:) call interp ( self % target_coordinates (:) + offset , source_coordinate , self % source % data % p2d ( i ,:), self % result_2d ( i ,:), self % out_of_bounds_treatment , self % out_of_bounds_value ) end do elseif ( associated ( self % source % data % p1d )) then offset = 0._rk if ( associated ( self % offset )) offset = self % offset_scale * self % offset % data % p0d call interp ( self % target_coordinates (:) + offset , self % source_coordinate % data % p1d , self % source % data % p1d , self % result_1d , self % out_of_bounds_treatment , self % out_of_bounds_value ) end if end subroutine recursive function get_field ( self , field ) result ( output_field ) class ( type_result ), intent ( in ) :: self type ( type_field ), target :: field class ( type_base_output_field ), pointer :: output_field if ( associated ( self % dimensions ( self % idim )% p % coordinate , field )) then output_field => self % type_base_output_field % get_field ( field ) else output_field => self % type_operator_result % get_field ( field ) end if end function subroutine interp ( x , xp , fp , f , out_of_bounds_treatment , out_of_bounds_value ) real ( rk ), intent ( in ) :: x (:), xp (:), fp (:) real ( rk ), intent ( out ) :: f (:) integer , intent ( in ) :: out_of_bounds_treatment real ( rk ), intent ( in ) :: out_of_bounds_value integer :: i , j , istart , istop real ( rk ) :: slope ! Find first non-masked source value istart = 0 do i = 1 , size ( xp ) if ( fp ( i ) /= out_of_bounds_value ) then istart = i exit end if end do ! If all source values are masked, return missing value if ( istart == 0 ) then f (:) = out_of_bounds_value return end if ! Find last non-masked source value do istop = size ( xp ), istart , - 1 if ( fp ( istop ) /= out_of_bounds_value ) exit end do i = istart do j = 1 , size ( x ) if ( out_of_bounds_treatment /= 3 . and . ( x ( j ) < xp ( istart ) . or . x ( j ) > xp ( istop ))) then if ( out_of_bounds_treatment == 1 ) then ! Use missing value f ( j ) = out_of_bounds_value else ! Use nearest valid value if ( x ( j ) < xp ( istart )) then f ( j ) = fp ( istart ) else f ( j ) = fp ( istop ) end if end if else do while ( i + 1 < istop ) if ( xp ( i + 1 ) >= x ( j )) exit i = i + 1 end do slope = ( fp ( i + 1 ) - fp ( i )) / ( xp ( i + 1 ) - xp ( i )) f ( j ) = fp ( i ) + ( x ( j ) - xp ( i )) * slope end if end do end subroutine end module","tags":"","loc":"sourcefile/interp.f90.html"},{"title":"library.F90 – Fortran Program","text":"This file depends on sourcefile~~library.f90~~EfferentGraph sourcefile~library.f90 library.F90 sourcefile~interp.f90 interp.F90 sourcefile~library.f90->sourcefile~interp.f90 sourcefile~field_manager.f90 field_manager.F90 sourcefile~library.f90->sourcefile~field_manager.f90 sourcefile~base.f90 base.F90 sourcefile~library.f90->sourcefile~base.f90 sourcefile~slice.f90 slice.F90 sourcefile~library.f90->sourcefile~slice.f90 sourcefile~time_average.f90 time_average.F90 sourcefile~library.f90->sourcefile~time_average.f90 sourcefile~output_manager_core.f90 output_manager_core.F90 sourcefile~library.f90->sourcefile~output_manager_core.f90 sourcefile~interp.f90->sourcefile~field_manager.f90 sourcefile~interp.f90->sourcefile~base.f90 sourcefile~interp.f90->sourcefile~output_manager_core.f90 sourcefile~base.f90->sourcefile~field_manager.f90 sourcefile~base.f90->sourcefile~output_manager_core.f90 sourcefile~slice.f90->sourcefile~field_manager.f90 sourcefile~slice.f90->sourcefile~base.f90 sourcefile~slice.f90->sourcefile~output_manager_core.f90 sourcefile~time_average.f90->sourcefile~field_manager.f90 sourcefile~time_average.f90->sourcefile~base.f90 sourcefile~time_average.f90->sourcefile~output_manager_core.f90 sourcefile~output_manager_core.f90->sourcefile~field_manager.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~library.f90~~AfferentGraph sourcefile~library.f90 library.F90 sourcefile~output_manager.f90 output_manager.F90 sourcefile~output_manager.f90->sourcefile~library.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules output_operators_library Source Code library.F90 Source Code module output_operators_library use field_manager use yaml_settings use output_manager_core use output_operators_base use output_operators_interp use output_operators_time_average use output_operators_slice implicit none private public apply_operator contains subroutine apply_operator ( final_operator , settings , field_manager ) class ( type_base_operator ), pointer :: final_operator class ( type_settings ), intent ( inout ) :: settings type ( type_field_manager ), intent ( inout ) :: field_manager integer :: operator_type class ( type_base_operator ), pointer :: op operator_type = settings % get_integer ( 'type' , 'operator type' , options = ( / type_option ( 1 , 'interp' ) / )) select case ( operator_type ) case ( 1 ) allocate ( type_interp_operator :: op ) end select call op % configure ( settings , field_manager ) op % previous => final_operator final_operator => op end subroutine end module","tags":"","loc":"sourcefile/library.f90.html"},{"title":"slice.F90 – Fortran Program","text":"This file depends on sourcefile~~slice.f90~~EfferentGraph sourcefile~slice.f90 slice.F90 sourcefile~output_manager_core.f90 output_manager_core.F90 sourcefile~slice.f90->sourcefile~output_manager_core.f90 sourcefile~field_manager.f90 field_manager.F90 sourcefile~slice.f90->sourcefile~field_manager.f90 sourcefile~base.f90 base.F90 sourcefile~slice.f90->sourcefile~base.f90 sourcefile~output_manager_core.f90->sourcefile~field_manager.f90 sourcefile~base.f90->sourcefile~output_manager_core.f90 sourcefile~base.f90->sourcefile~field_manager.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~slice.f90~~AfferentGraph sourcefile~slice.f90 slice.F90 sourcefile~library.f90 library.F90 sourcefile~library.f90->sourcefile~slice.f90 sourcefile~output_manager.f90 output_manager.F90 sourcefile~output_manager.f90->sourcefile~slice.f90 sourcefile~output_manager.f90->sourcefile~library.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules output_operators_slice Source Code slice.F90 Source Code module output_operators_slice use output_manager_core use field_manager use output_operators_base implicit none private public type_slice_operator type type_single_dimension_slice character ( len = string_length ) :: dimension integer :: global_start = 1 integer :: global_stop = - 1 integer :: stride = 1 type ( type_single_dimension_slice ), pointer :: next => null () end type type , extends ( type_base_operator ) :: type_slice_operator type ( type_single_dimension_slice ), pointer :: first => null () contains procedure :: apply procedure :: add end type contains subroutine add ( self , dimension , start , stop , stride ) class ( type_slice_operator ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: dimension integer , intent ( in ) :: start , stop , stride type ( type_single_dimension_slice ), pointer :: single_dimension_slice if ( start < 0 ) call host % fatal_error ( 'type_slice_operator%initialize' , & 'Start index of dimension ' // dimension // ' must equal or exceed 0.' ) if ( stop < 1 ) call host % fatal_error ( 'type_slice_operator%initialize' , & 'Stop index of dimension ' // dimension // ' must equal or exceed 1.' ) allocate ( single_dimension_slice ) single_dimension_slice % dimension = dimension single_dimension_slice % global_start = start single_dimension_slice % global_stop = stop - mod ( stop - start , stride ) single_dimension_slice % stride = stride single_dimension_slice % next => self % first self % first => single_dimension_slice end subroutine function apply ( self , source ) result ( output_field ) class ( type_slice_operator ), intent ( inout ), target :: self class ( type_base_output_field ), target :: source class ( type_base_output_field ), pointer :: output_field class ( type_universal_operator_result ), pointer :: result type ( type_dimension_pointer ), allocatable :: dimensions (:) type ( type_dimension ), pointer :: new_dimension integer :: local_start , local_stop , stride integer , allocatable :: starts (:), stops (:), strides (:) type ( type_single_dimension_slice ), pointer :: single_dimension_slice integer :: i , j , global_start , global_stop output_field => null () call source % get_metadata ( dimensions = dimensions ) allocate ( starts ( 1 : size ( dimensions )), stops ( 1 : size ( dimensions )), strides ( 1 : size ( dimensions ))) starts (:) = 1 strides (:) = 1 j = 0 do i = 1 , size ( dimensions ) if ( dimensions ( i )% p % id == id_dim_time ) cycle global_start = 1 global_stop = dimensions ( i )% p % global_length stride = 1 single_dimension_slice => self % first do while ( associated ( single_dimension_slice )) if ( dimensions ( i )% p % name == single_dimension_slice % dimension ) exit single_dimension_slice => single_dimension_slice % next end do if ( associated ( single_dimension_slice )) then if ( single_dimension_slice % global_start > dimensions ( i )% p % global_length ) call host % fatal_error ( 'type_slice_operator%initialize' , & 'Start index of dimension ' // trim ( single_dimension_slice % dimension ) // ' exceeds length.' ) if ( single_dimension_slice % global_stop > dimensions ( i )% p % global_length ) call host % fatal_error ( 'type_slice_operator%initialize' , & 'Stop index of dimension ' // trim ( single_dimension_slice % dimension ) // ' exceeds length.' ) global_start = single_dimension_slice % global_start if ( single_dimension_slice % global_stop /= - 1 ) global_stop = single_dimension_slice % global_stop stride = single_dimension_slice % stride end if call find_local_range ( global_start , global_stop , dimensions ( i )% p % offset , dimensions ( i )% p % length , stride , local_start , local_stop ) if ( local_stop < local_start ) return if ( dimensions ( i )% p % length > 1 ) then j = j + 1 starts ( j ) = local_start stops ( j ) = local_stop strides ( j ) = stride end if if ( local_start /= 1 . or . local_stop /= dimensions ( i )% p % length . or . stride /= 1 ) then ! This dimension is being modified by the slicing allocate ( new_dimension ) new_dimension % name = dimensions ( i )% p % name new_dimension % length = 1 + ( local_stop - local_start ) / stride new_dimension % global_length = new_dimension % length new_dimension % coordinate => dimensions ( i )% p % coordinate dimensions ( i )% p => new_dimension end if end do allocate ( result ) result % operator => self result % source => source result % output_name = 'slice(' // trim ( result % source % output_name ) // ')' output_field => result allocate ( result % dimensions ( 1 : size ( dimensions ))) result % dimensions (:) = dimensions if ( associated ( result % source % data % p3d )) then if ( j /= 3 ) call host % fatal_error ( 'type_slice_operator%initialize' , 'BUG: data of ' // trim ( result % output_name ) // ' contains one or more singleton dimensions.' ) call result % data % set ( result % source % data % p3d ( starts ( 1 ): stops ( 1 ): strides ( 1 ), starts ( 2 ): stops ( 2 ): strides ( 2 ), starts ( 3 ): stops ( 3 ): strides ( 3 ))) elseif ( associated ( result % source % data % p2d )) then if ( j /= 2 ) call host % fatal_error ( 'type_slice_operator%initialize' , 'BUG: data of ' // trim ( result % output_name ) // ' contains one or more singleton dimensions.' ) call result % data % set ( result % source % data % p2d ( starts ( 1 ): stops ( 1 ): strides ( 1 ), starts ( 2 ): stops ( 2 ): strides ( 2 ))) elseif ( associated ( result % source % data % p1d )) then if ( j /= 1 ) call host % fatal_error ( 'type_slice_operator%initialize' , 'BUG: data of ' // trim ( result % output_name ) // ' contains one or more singleton dimensions.' ) call result % data % set ( result % source % data % p1d ( starts ( 1 ): stops ( 1 ): strides ( 1 ))) else if ( j /= 0 ) call host % fatal_error ( 'type_slice_operator%initialize' , 'BUG: data of ' // trim ( result % output_name ) // ' contains one or more singleton dimensions.' ) call result % data % set ( result % source % data % p0d ) end if end function subroutine find_local_range ( global_start , global_stop , local_offset , local_length , stride , local_start , local_stop ) integer , intent ( in ) :: global_start , global_stop , stride , local_offset , local_length integer , intent ( out ) :: local_start , local_stop integer :: distance ! Compute local [i.e., within-subdomain] start and stop positons from global positions and local offset. if ( global_start > local_offset + local_length ) then ! Start point lies beyond our subdomain local_start = 1 local_stop = local_start - stride else if ( global_start > local_offset ) then ! Starting point lies within our subdomain local_start = global_start - local_offset else ! Starting point lies before our subdomain: we start immediately but have to account for stride ! Determine distance between subdomain start and nearest included point outside the domain. distance = mod ( local_offset + 1 - global_start , stride ) ! Convert to distance to next point within the domain if ( distance > 0 ) distance = stride - distance local_start = 1 + distance end if ! Determine local stop by subtracting subdomain offset [maximum is subdomain length) local_stop = min ( global_stop - local_offset , local_length ) if ( local_stop < local_start ) then ! stop precedes start, so we have 0 length, i.e., ! length = (local_stop-local_start)/stride + 1 = 0 local_stop = local_start - stride else ! Reduce stop to last point that is actually included (due to stride>1) local_stop = local_stop - mod ( local_stop - local_start , stride ) end if end if end subroutine end module","tags":"","loc":"sourcefile/slice.f90.html"},{"title":"base.F90 – Fortran Program","text":"This file depends on sourcefile~~base.f90~~EfferentGraph sourcefile~base.f90 base.F90 sourcefile~output_manager_core.f90 output_manager_core.F90 sourcefile~base.f90->sourcefile~output_manager_core.f90 sourcefile~field_manager.f90 field_manager.F90 sourcefile~base.f90->sourcefile~field_manager.f90 sourcefile~output_manager_core.f90->sourcefile~field_manager.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~base.f90~~AfferentGraph sourcefile~base.f90 base.F90 sourcefile~interp.f90 interp.F90 sourcefile~interp.f90->sourcefile~base.f90 sourcefile~slice.f90 slice.F90 sourcefile~slice.f90->sourcefile~base.f90 sourcefile~library.f90 library.F90 sourcefile~library.f90->sourcefile~base.f90 sourcefile~library.f90->sourcefile~interp.f90 sourcefile~library.f90->sourcefile~slice.f90 sourcefile~time_average.f90 time_average.F90 sourcefile~library.f90->sourcefile~time_average.f90 sourcefile~time_average.f90->sourcefile~base.f90 sourcefile~output_manager.f90 output_manager.F90 sourcefile~output_manager.f90->sourcefile~slice.f90 sourcefile~output_manager.f90->sourcefile~library.f90 sourcefile~output_manager.f90->sourcefile~time_average.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules output_operators_base Source Code base.F90 Source Code module output_operators_base use output_manager_core use field_manager use yaml_types implicit none private public type_operator_result , type_universal_operator_result type , extends ( type_base_output_field ) :: type_operator_result class ( type_base_operator ), pointer :: operator => null () class ( type_base_output_field ), pointer :: source => null () real ( rk ) :: result_0d real ( rk ), allocatable :: result_1d (:) real ( rk ), allocatable :: result_2d (:,:) real ( rk ), allocatable :: result_3d (:,:,:) type ( type_dimension_pointer ), allocatable :: dimensions (:) contains procedure :: new_data procedure :: before_save procedure :: get_metadata procedure :: flag_as_required procedure :: fill procedure :: get_field end type type , extends ( type_operator_result ) :: type_universal_operator_result contains procedure :: get_field => universal_get_field end type contains recursive subroutine new_data ( self ) class ( type_operator_result ), intent ( inout ) :: self call self % source % new_data () end subroutine recursive subroutine before_save ( self ) class ( type_operator_result ), intent ( inout ) :: self call self % source % before_save () end subroutine recursive subroutine get_metadata ( self , long_name , units , dimensions , minimum , maximum , fill_value , standard_name , path , attributes ) class ( type_operator_result ), intent ( in ) :: self character ( len = :), allocatable , intent ( out ), optional :: long_name , units , standard_name , path type ( type_dimension_pointer ), allocatable , intent ( out ), optional :: dimensions (:) real ( rk ), intent ( out ), optional :: minimum , maximum , fill_value type ( type_attributes ), intent ( out ), optional :: attributes ! Workaround for gfortran BUG 88511 - passing optional allocatable deferred length character arguments to the next routine causes memory corruption character ( len = :), allocatable :: long_name2 , units2 , standard_name2 , path2 call self % source % get_metadata ( long_name2 , units2 , dimensions , minimum , maximum , fill_value , standard_name2 , path2 , attributes ) ! Workaround for gfortran if ( present ( long_name ) . and . allocated ( long_name2 )) long_name = long_name2 if ( present ( units ) . and . allocated ( units2 )) units = units2 if ( present ( standard_name ) . and . allocated ( standard_name2 )) standard_name = standard_name2 if ( present ( path ) . and . allocated ( path2 )) path = path2 if ( present ( dimensions ) . and . allocated ( self % dimensions )) dimensions (:) = self % dimensions (:) end subroutine recursive subroutine flag_as_required ( self , required ) class ( type_operator_result ), intent ( inout ) :: self logical , intent ( in ) :: required call self % source % flag_as_required ( required ) end subroutine subroutine fill ( self , value ) class ( type_operator_result ), intent ( inout ) :: self real ( rk ), intent ( in ) :: value if ( allocated ( self % result_3d )) then self % result_3d (:,:,:) = value elseif ( allocated ( self % result_2d )) then self % result_2d (:,:) = value elseif ( allocated ( self % result_1d )) then self % result_1d (:) = value else self % result_0d = value end if end subroutine recursive function get_field ( self , field ) result ( output_field ) class ( type_operator_result ), intent ( in ) :: self type ( type_field ), target :: field class ( type_base_output_field ), pointer :: output_field output_field => self % source % get_field ( field ) end function recursive function universal_get_field ( self , field ) result ( output_field ) class ( type_universal_operator_result ), intent ( in ) :: self type ( type_field ), target :: field class ( type_base_output_field ), pointer :: output_field output_field => self % type_operator_result % get_field ( field ) if ( associated ( output_field )) output_field => self % operator % apply ( output_field ) end function end module","tags":"","loc":"sourcefile/base.f90.html"},{"title":"type_dimension – Fortran Program ","text":"type, public :: type_dimension Inherits type~~type_dimension~~InheritsGraph type~type_dimension type_dimension type~type_dimension->type~type_dimension next type~type_field type_field type~type_dimension->type~type_field coordinate type~type_field->type~type_field next type~type_nd_data_pointer type_nd_data_pointer type~type_field->type~type_nd_data_pointer data type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_node type_node type~type_category_node->type~type_node type~type_dimension_pointer->type~type_dimension p type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute->type~type_attribute next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_dimension~~InheritedByGraph type~type_dimension type_dimension type~type_dimension->type~type_dimension next type~type_field type_field type~type_dimension->type~type_field coordinate type~type_field_manager type_field_manager type~type_field_manager->type~type_dimension first_dimension type~type_dimension_pointer type_dimension_pointer type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_dictionary_bin type_dictionary_bin type~type_field_manager->type~type_dictionary_bin field_table type~type_dimension_pointer->type~type_dimension p type~type_interp_operator type_interp_operator type~type_interp_operator->type~type_dimension target_dimension type~type_interp_operator->type~type_field source_field, offset_field type~type_single_text_file_with_1d_variable type_single_text_file_with_1d_variable type~type_single_text_file_with_1d_variable->type~type_dimension dimension type~type_coordinate_list_populator type_coordinate_list_populator type~type_coordinate_list_populator->type~type_interp_operator operator type~type_file type_file type~type_file->type~type_field_manager field_manager type~type_file->type~type_file next type~type_output_item type_output_item type~type_file->type~type_output_item first_item type~type_operator_result type_operator_result type~type_operator_result->type~type_dimension_pointer dimensions type~type_operator_populator type_operator_populator type~type_operator_populator->type~type_field_manager field_manager type~type_file_populator type_file_populator type~type_file_populator->type~type_field_manager fm type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_field next type~type_output_item->type~type_field field type~type_output_item->type~type_output_item next type~type_field_node type_field_node type~type_field_node->type~type_field field type~type_group_populator type_group_populator type~type_group_populator->type~type_file file type~type_dictionary_bin->type~type_field first_field type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_file file type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_field_set_member type_field_set_member type~type_field_set_member->type~type_field field type~type_field_set_member->type~type_field_set_member next type~type_universal_operator_result type_universal_operator_result type~type_universal_operator_result->type~type_operator_result type~type_output_field type_output_field type~type_output_field->type~type_field source type~type_result type_result type~type_result->type~type_operator_result type~type_text_file type_text_file type~type_text_file->type~type_file type~type_field_set type_field_set type~type_field_set->type~type_field_set_member first type~type_result~2 type_result type~type_result~2->type~type_universal_operator_result var pantypetype_dimensionInheritedByGraph = svgPanZoom('#typetype_dimensionInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables name iterator length global_length offset id coordinate next Components Type Visibility Attributes Name Initial character(len=string_length), public :: name = '' character(len=string_length), public :: iterator = '' integer, public :: length = -1 integer, public :: global_length = -1 integer, public :: offset = 0 integer, public :: id = -1 type( type_field ), public, pointer :: coordinate => null() type( type_dimension ), public, pointer :: next => null()","tags":"","loc":"type/type_dimension.html"},{"title":"type_dimension_pointer – Fortran Program ","text":"type, public :: type_dimension_pointer Inherits type~~type_dimension_pointer~~InheritsGraph type~type_dimension_pointer type_dimension_pointer type~type_dimension type_dimension type~type_dimension_pointer->type~type_dimension p type~type_dimension->type~type_dimension next type~type_field type_field type~type_dimension->type~type_field coordinate type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_field next type~type_nd_data_pointer type_nd_data_pointer type~type_field->type~type_nd_data_pointer data type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_node type_node type~type_category_node->type~type_node type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute->type~type_attribute next var pantypetype_dimension_pointerInheritsGraph = svgPanZoom('#typetype_dimension_pointerInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_dimension_pointer~~InheritedByGraph type~type_dimension_pointer type_dimension_pointer type~type_dimension type_dimension type~type_dimension_pointer->type~type_dimension p type~type_field_manager type_field_manager type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_field_manager->type~type_dimension first_dimension type~type_dictionary_bin type_dictionary_bin type~type_field_manager->type~type_dictionary_bin field_table type~type_field type_field type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_field next type~type_operator_result type_operator_result type~type_operator_result->type~type_dimension_pointer dimensions type~type_dimension->type~type_field coordinate type~type_dimension->type~type_dimension next type~type_output_item type_output_item type~type_output_item->type~type_field field type~type_output_item->type~type_output_item next type~type_interp_operator type_interp_operator type~type_interp_operator->type~type_field source_field, offset_field type~type_interp_operator->type~type_dimension target_dimension type~type_field_node type_field_node type~type_field_node->type~type_field field type~type_file type_file type~type_file->type~type_field_manager field_manager type~type_file->type~type_output_item first_item type~type_file->type~type_file next type~type_dictionary_bin->type~type_field first_field type~type_field_set_member type_field_set_member type~type_field_set_member->type~type_field field type~type_field_set_member->type~type_field_set_member next type~type_operator_populator type_operator_populator type~type_operator_populator->type~type_field_manager field_manager type~type_file_populator type_file_populator type~type_file_populator->type~type_field_manager fm type~type_universal_operator_result type_universal_operator_result type~type_universal_operator_result->type~type_operator_result type~type_output_field type_output_field type~type_output_field->type~type_field source type~type_result type_result type~type_result->type~type_operator_result type~type_text_file type_text_file type~type_text_file->type~type_file type~type_coordinate_list_populator type_coordinate_list_populator type~type_coordinate_list_populator->type~type_interp_operator operator type~type_single_text_file_with_1d_variable type_single_text_file_with_1d_variable type~type_single_text_file_with_1d_variable->type~type_dimension dimension type~type_group_populator type_group_populator type~type_group_populator->type~type_file file type~type_field_set type_field_set type~type_field_set->type~type_field_set_member first type~type_result~2 type_result type~type_result~2->type~type_universal_operator_result type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_file file var pantypetype_dimension_pointerInheritedByGraph = svgPanZoom('#typetype_dimension_pointerInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables p Components Type Visibility Attributes Name Initial type( type_dimension ), public, pointer :: p => null()","tags":"","loc":"type/type_dimension_pointer.html"},{"title":"type_attribute – Fortran Program ","text":"type, public :: type_attribute Inherited by type~~type_attribute~~InheritedByGraph type~type_attribute type_attribute type~type_attribute->type~type_attribute next type~type_attributes type_attributes type~type_attributes->type~type_attribute first type~type_real_attribute type_real_attribute type~type_real_attribute->type~type_attribute type~type_integer_attribute type_integer_attribute type~type_integer_attribute->type~type_attribute type~type_string_attribute type_string_attribute type~type_string_attribute->type~type_attribute type~type_field type_field type~type_field->type~type_attributes attributes type~type_field->type~type_field next type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_dimension type_dimension type~type_dimension->type~type_field coordinate type~type_dimension->type~type_dimension next type~type_output_item type_output_item type~type_output_item->type~type_field field type~type_output_item->type~type_output_item next type~type_interp_operator type_interp_operator type~type_interp_operator->type~type_field source_field, offset_field type~type_interp_operator->type~type_dimension target_dimension type~type_field_node type_field_node type~type_field_node->type~type_field field type~type_dictionary_bin type_dictionary_bin type~type_dictionary_bin->type~type_field first_field type~type_field_set_member type_field_set_member type~type_field_set_member->type~type_field field type~type_field_set_member->type~type_field_set_member next type~type_output_field type_output_field type~type_output_field->type~type_field source type~type_coordinate_list_populator type_coordinate_list_populator type~type_coordinate_list_populator->type~type_interp_operator operator type~type_single_text_file_with_1d_variable type_single_text_file_with_1d_variable type~type_single_text_file_with_1d_variable->type~type_dimension dimension type~type_file type_file type~type_file->type~type_output_item first_item type~type_file->type~type_file next type~type_field_manager type_field_manager type~type_file->type~type_field_manager field_manager type~type_field_set type_field_set type~type_field_set->type~type_field_set_member first type~type_dimension_pointer->type~type_dimension p type~type_field_manager->type~type_dimension first_dimension type~type_field_manager->type~type_dictionary_bin field_table type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_group_populator type_group_populator type~type_group_populator->type~type_file file type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_file file type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_operator_result type_operator_result type~type_operator_result->type~type_dimension_pointer dimensions type~type_file_populator type_file_populator type~type_file_populator->type~type_field_manager fm type~type_operator_populator type_operator_populator type~type_operator_populator->type~type_field_manager field_manager type~type_text_file type_text_file type~type_text_file->type~type_file type~type_universal_operator_result type_universal_operator_result type~type_universal_operator_result->type~type_operator_result type~type_result type_result type~type_result->type~type_operator_result type~type_result~2 type_result type~type_result~2->type~type_universal_operator_result var pantypetype_attributeInheritedByGraph = svgPanZoom('#typetype_attributeInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables name next Components Type Visibility Attributes Name Initial character(len=string_length), public :: name = '' class( type_attribute ), public, pointer :: next => null()","tags":"","loc":"type/type_attribute.html"},{"title":"type_real_attribute – Fortran Program ","text":"type, public, extends( type_attribute ) :: type_real_attribute Inherits type~~type_real_attribute~~InheritsGraph type~type_real_attribute type_real_attribute type~type_attribute type_attribute type~type_real_attribute->type~type_attribute type~type_attribute->type~type_attribute next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables name next value Components Type Visibility Attributes Name Initial character(len=string_length), public :: name = '' class( type_attribute ), public, pointer :: next => null() real(kind=rk), public :: value = 0.0_rk","tags":"","loc":"type/type_real_attribute.html"},{"title":"type_integer_attribute – Fortran Program ","text":"type, public, extends( type_attribute ) :: type_integer_attribute Inherits type~~type_integer_attribute~~InheritsGraph type~type_integer_attribute type_integer_attribute type~type_attribute type_attribute type~type_integer_attribute->type~type_attribute type~type_attribute->type~type_attribute next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables name next value Components Type Visibility Attributes Name Initial character(len=string_length), public :: name = '' class( type_attribute ), public, pointer :: next => null() integer, public :: value = 0","tags":"","loc":"type/type_integer_attribute.html"},{"title":"type_string_attribute – Fortran Program ","text":"type, public, extends( type_attribute ) :: type_string_attribute Inherits type~~type_string_attribute~~InheritsGraph type~type_string_attribute type_string_attribute type~type_attribute type_attribute type~type_string_attribute->type~type_attribute type~type_attribute->type~type_attribute next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables name next value Components Type Visibility Attributes Name Initial character(len=string_length), public :: name = '' class( type_attribute ), public, pointer :: next => null() character(len=string_length), public :: value = ''","tags":"","loc":"type/type_string_attribute.html"},{"title":"type_attributes – Fortran Program ","text":"type, public :: type_attributes Inherits type~~type_attributes~~InheritsGraph type~type_attributes type_attributes type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_attribute->type~type_attribute next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_attributes~~InheritedByGraph type~type_attributes type_attributes type~type_field type_field type~type_field->type~type_attributes attributes type~type_field->type~type_field next type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_dimension type_dimension type~type_dimension->type~type_field coordinate type~type_dimension->type~type_dimension next type~type_output_item type_output_item type~type_output_item->type~type_field field type~type_output_item->type~type_output_item next type~type_interp_operator type_interp_operator type~type_interp_operator->type~type_field source_field, offset_field type~type_interp_operator->type~type_dimension target_dimension type~type_field_node type_field_node type~type_field_node->type~type_field field type~type_dictionary_bin type_dictionary_bin type~type_dictionary_bin->type~type_field first_field type~type_field_set_member type_field_set_member type~type_field_set_member->type~type_field field type~type_field_set_member->type~type_field_set_member next type~type_output_field type_output_field type~type_output_field->type~type_field source type~type_coordinate_list_populator type_coordinate_list_populator type~type_coordinate_list_populator->type~type_interp_operator operator type~type_single_text_file_with_1d_variable type_single_text_file_with_1d_variable type~type_single_text_file_with_1d_variable->type~type_dimension dimension type~type_file type_file type~type_file->type~type_output_item first_item type~type_file->type~type_file next type~type_field_manager type_field_manager type~type_file->type~type_field_manager field_manager type~type_field_set type_field_set type~type_field_set->type~type_field_set_member first type~type_dimension_pointer->type~type_dimension p type~type_field_manager->type~type_dimension first_dimension type~type_field_manager->type~type_dictionary_bin field_table type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_group_populator type_group_populator type~type_group_populator->type~type_file file type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_file file type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_operator_result type_operator_result type~type_operator_result->type~type_dimension_pointer dimensions type~type_file_populator type_file_populator type~type_file_populator->type~type_field_manager fm type~type_operator_populator type_operator_populator type~type_operator_populator->type~type_field_manager field_manager type~type_text_file type_text_file type~type_text_file->type~type_file type~type_universal_operator_result type_universal_operator_result type~type_universal_operator_result->type~type_operator_result type~type_result type_result type~type_result->type~type_operator_result type~type_result~2 type_result type~type_result~2->type~type_universal_operator_result var pantypetype_attributesInheritedByGraph = svgPanZoom('#typetype_attributesInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables first Type-Bound Procedures set_object delete set_real set_integer set_string set update Components Type Visibility Attributes Name Initial class( type_attribute ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: set_object => attributes_set_object private subroutine attributes_set_object (self, name, attribute) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name class( type_attribute ), intent(inout), target :: attribute procedure, public :: delete => attributes_delete private subroutine attributes_delete (self, name) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name procedure, public :: set_real => attributes_set_real private subroutine attributes_set_real (self, name, value) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), intent(in) :: value procedure, public :: set_integer => attributes_set_integer private subroutine attributes_set_integer (self, name, value) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(in) :: value procedure, public :: set_string => attributes_set_string private subroutine attributes_set_string (self, name, value) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: value generic, public :: set => set_real , set_integer , set_string , set_object private subroutine attributes_set_real (self, name, value) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), intent(in) :: value private subroutine attributes_set_integer (self, name, value) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(in) :: value private subroutine attributes_set_string (self, name, value) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: value private subroutine attributes_set_object (self, name, attribute) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name class( type_attribute ), intent(inout), target :: attribute procedure, public :: update => attributes_update private subroutine attributes_update (self, other) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self class( type_attributes ), intent(in) :: other","tags":"","loc":"type/type_attributes.html"},{"title":"type_nd_data_pointer – Fortran Program ","text":"type, public :: type_nd_data_pointer Inherited by type~~type_nd_data_pointer~~InheritedByGraph type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field type_base_output_field type~type_base_output_field->type~type_nd_data_pointer data type~type_base_output_field->type~type_base_output_field next type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_field type_field type~type_field->type~type_nd_data_pointer data type~type_field->type~type_field next type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_dimension type_dimension type~type_dimension->type~type_field coordinate type~type_dimension->type~type_dimension next type~type_output_field_pointer->type~type_base_output_field p type~type_output_item type_output_item type~type_output_item->type~type_field field type~type_output_item->type~type_output_item next type~type_interp_operator type_interp_operator type~type_interp_operator->type~type_field source_field, offset_field type~type_interp_operator->type~type_dimension target_dimension type~type_single_text_file_with_1d_variable type_single_text_file_with_1d_variable type~type_single_text_file_with_1d_variable->type~type_base_output_field field, coordinate type~type_single_text_file_with_1d_variable->type~type_dimension dimension type~type_field_node type_field_node type~type_field_node->type~type_field field type~type_file type_file type~type_file->type~type_base_output_field first_field type~type_file->type~type_output_item first_item type~type_file->type~type_file next type~type_field_manager type_field_manager type~type_file->type~type_field_manager field_manager type~type_scalar type_scalar type~type_scalar->type~type_base_output_field field type~type_dictionary_bin type_dictionary_bin type~type_dictionary_bin->type~type_field first_field type~type_field_set_member type_field_set_member type~type_field_set_member->type~type_field field type~type_field_set_member->type~type_field_set_member next type~type_operator_result type_operator_result type~type_operator_result->type~type_base_output_field source type~type_operator_result->type~type_base_output_field type~type_operator_result->type~type_dimension_pointer dimensions type~type_output_field type_output_field type~type_output_field->type~type_base_output_field type~type_output_field->type~type_field source type~type_result type_result type~type_result->type~type_base_output_field source_coordinate, offset type~type_result->type~type_operator_result type~type_text_file type_text_file type~type_text_file->type~type_file type~type_coordinate_list_populator type_coordinate_list_populator type~type_coordinate_list_populator->type~type_interp_operator operator type~type_group_populator type_group_populator type~type_group_populator->type~type_file file type~type_field_set type_field_set type~type_field_set->type~type_field_set_member first type~type_dimension_pointer->type~type_dimension p type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_single_text_file_with_scalars type_single_text_file_with_scalars type~type_single_text_file_with_scalars->type~type_scalar variables, constants type~type_field_manager->type~type_dimension first_dimension type~type_field_manager->type~type_dictionary_bin field_table type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_universal_operator_result type_universal_operator_result type~type_universal_operator_result->type~type_operator_result type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_file file type~type_result~2 type_result type~type_result~2->type~type_universal_operator_result type~type_operator_populator type_operator_populator type~type_operator_populator->type~type_field_manager field_manager type~type_file_populator type_file_populator type~type_file_populator->type~type_field_manager fm var pantypetype_nd_data_pointerInheritedByGraph = svgPanZoom('#typetype_nd_data_pointerInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables p0d p1d p2d p3d Type-Bound Procedures set_0d set_1d set_2d set_3d set get_extents is_empty Components Type Visibility Attributes Name Initial real(kind=rk), public, pointer :: p0d => null() real(kind=rk), public, pointer :: p1d (:) => null() real(kind=rk), public, pointer :: p2d (:,:) => null() real(kind=rk), public, pointer :: p3d (:,:,:) => null() Type-Bound Procedures procedure, public :: set_0d => data_set_0d private subroutine data_set_0d (self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data procedure, public :: set_1d => data_set_1d private subroutine data_set_1d (self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data (:) procedure, public :: set_2d => data_set_2d private subroutine data_set_2d (self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data (:,:) procedure, public :: set_3d => data_set_3d private subroutine data_set_3d (self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data (:,:,:) generic, public :: set => set_0d , set_1d , set_2d , set_3d private subroutine data_set_0d (self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data private subroutine data_set_1d (self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data (:) private subroutine data_set_2d (self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data (:,:) private subroutine data_set_3d (self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data (:,:,:) procedure, public :: get_extents => data_get_extents private subroutine data_get_extents (self, extents) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(in) :: self integer, intent(out), allocatable :: extents (:) procedure, public :: is_empty => data_is_empty private function data_is_empty (self) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(in) :: self Return Value logical","tags":"","loc":"type/type_nd_data_pointer.html"},{"title":"type_field – Fortran Program ","text":"type, public :: type_field Inherits type~~type_field~~InheritsGraph type~type_field type_field type~type_field->type~type_field next type~type_nd_data_pointer type_nd_data_pointer type~type_field->type~type_nd_data_pointer data type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_node type_node type~type_category_node->type~type_node type~type_dimension type_dimension type~type_dimension_pointer->type~type_dimension p type~type_dimension->type~type_field coordinate type~type_dimension->type~type_dimension next type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute->type~type_attribute next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_field~~InheritedByGraph type~type_field type_field type~type_field->type~type_field next type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_dimension type_dimension type~type_dimension->type~type_field coordinate type~type_dimension->type~type_dimension next type~type_output_item type_output_item type~type_output_item->type~type_field field type~type_output_item->type~type_output_item next type~type_interp_operator type_interp_operator type~type_interp_operator->type~type_field source_field, offset_field type~type_interp_operator->type~type_dimension target_dimension type~type_field_node type_field_node type~type_field_node->type~type_field field type~type_dictionary_bin type_dictionary_bin type~type_dictionary_bin->type~type_field first_field type~type_field_set_member type_field_set_member type~type_field_set_member->type~type_field field type~type_field_set_member->type~type_field_set_member next type~type_output_field type_output_field type~type_output_field->type~type_field source type~type_coordinate_list_populator type_coordinate_list_populator type~type_coordinate_list_populator->type~type_interp_operator operator type~type_single_text_file_with_1d_variable type_single_text_file_with_1d_variable type~type_single_text_file_with_1d_variable->type~type_dimension dimension type~type_file type_file type~type_file->type~type_output_item first_item type~type_file->type~type_file next type~type_field_manager type_field_manager type~type_file->type~type_field_manager field_manager type~type_field_set type_field_set type~type_field_set->type~type_field_set_member first type~type_dimension_pointer->type~type_dimension p type~type_field_manager->type~type_dimension first_dimension type~type_field_manager->type~type_dictionary_bin field_table type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_group_populator type_group_populator type~type_group_populator->type~type_file file type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_file file type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_operator_result type_operator_result type~type_operator_result->type~type_dimension_pointer dimensions type~type_file_populator type_file_populator type~type_file_populator->type~type_field_manager fm type~type_operator_populator type_operator_populator type~type_operator_populator->type~type_field_manager field_manager type~type_text_file type_text_file type~type_text_file->type~type_file type~type_universal_operator_result type_universal_operator_result type~type_universal_operator_result->type~type_operator_result type~type_result type_result type~type_result->type~type_operator_result type~type_result~2 type_result type~type_result~2->type~type_universal_operator_result var pantypetype_fieldInheritedByGraph = svgPanZoom('#typetype_fieldInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables id name units long_name standard_name fill_value minimum maximum output_level in_output used_now status dimensions attributes extents data category next Type-Bound Procedures has_dimension finalize field_set_real_attribute set_attribute Components Type Visibility Attributes Name Initial integer, public :: id = 0 character(len=string_length), public :: name = '' character(len=string_length), public :: units = '' character(len=string_length), public :: long_name = '' character(len=string_length), public :: standard_name = '' real(kind=rk), public :: fill_value = default_fill_value real(kind=rk), public :: minimum = default_minimum real(kind=rk), public :: maximum = default_maximum integer, public :: output_level = output_level_default logical, public :: in_output = .false. logical, public, pointer :: used_now => null() integer, public :: status = status_not_registered type( type_dimension_pointer ), public, allocatable :: dimensions (:) type( type_attributes ), public :: attributes integer, public, allocatable :: extents (:) type( type_nd_data_pointer ), public :: data class( type_category_node ), public, pointer :: category => null() type( type_field ), public, pointer :: next => null() Type-Bound Procedures procedure, public :: has_dimension => field_has_dimension private function field_has_dimension (self, id) Arguments Type Intent Optional Attributes Name class( type_field ), intent(in) :: self integer, intent(in) :: id Return Value logical procedure, public :: finalize => field_finalize private subroutine field_finalize (self) Arguments Type Intent Optional Attributes Name class( type_field ), intent(inout) :: self procedure, public :: field_set_real_attribute private subroutine field_set_real_attribute (self, name, value) Arguments Type Intent Optional Attributes Name class( type_field ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), intent(in) :: value generic, public :: set_attribute => field_set_real_attribute private subroutine field_set_real_attribute (self, name, value) Arguments Type Intent Optional Attributes Name class( type_field ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), intent(in) :: value","tags":"","loc":"type/type_field.html"},{"title":"type_node – Fortran Program ","text":"type, private, abstract :: type_node Inherited by type~~type_node~~InheritedByGraph type~type_node type_node type~type_node->type~type_node parent, first_child, next_sibling type~type_category_node type_category_node type~type_category_node->type~type_node type~type_field_node type_field_node type~type_field_node->type~type_node type~type_field type_field type~type_field_node->type~type_field field type~type_field_manager type_field_manager type~type_field_manager->type~type_category_node root type~type_dimension type_dimension type~type_field_manager->type~type_dimension first_dimension type~type_dictionary_bin type_dictionary_bin type~type_field_manager->type~type_dictionary_bin field_table type~type_dimension_pointer type_dimension_pointer type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_field->type~type_category_node category type~type_field->type~type_field next type~type_field->type~type_dimension_pointer dimensions type~type_output_item type_output_item type~type_output_item->type~type_category_node category type~type_output_item->type~type_field field type~type_output_item->type~type_output_item next type~type_dimension->type~type_field coordinate type~type_dimension->type~type_dimension next type~type_interp_operator type_interp_operator type~type_interp_operator->type~type_field source_field, offset_field type~type_interp_operator->type~type_dimension target_dimension type~type_file type_file type~type_file->type~type_field_manager field_manager type~type_file->type~type_output_item first_item type~type_file->type~type_file next type~type_dictionary_bin->type~type_field first_field type~type_field_set_member type_field_set_member type~type_field_set_member->type~type_field field type~type_field_set_member->type~type_field_set_member next type~type_operator_populator type_operator_populator type~type_operator_populator->type~type_field_manager field_manager type~type_file_populator type_file_populator type~type_file_populator->type~type_field_manager fm type~type_output_field type_output_field type~type_output_field->type~type_field source type~type_text_file type_text_file type~type_text_file->type~type_file type~type_coordinate_list_populator type_coordinate_list_populator type~type_coordinate_list_populator->type~type_interp_operator operator type~type_single_text_file_with_1d_variable type_single_text_file_with_1d_variable type~type_single_text_file_with_1d_variable->type~type_dimension dimension type~type_group_populator type_group_populator type~type_group_populator->type~type_file file type~type_field_set type_field_set type~type_field_set->type~type_field_set_member first type~type_dimension_pointer->type~type_dimension p type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_file file type~type_operator_result type_operator_result type~type_operator_result->type~type_dimension_pointer dimensions type~type_universal_operator_result type_universal_operator_result type~type_universal_operator_result->type~type_operator_result type~type_result type_result type~type_result->type~type_operator_result type~type_result~2 type_result type~type_result~2->type~type_universal_operator_result var pantypetype_nodeInheritedByGraph = svgPanZoom('#typetype_nodeInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables parent first_child next_sibling Type-Bound Procedures finalize Components Type Visibility Attributes Name Initial class( type_node ), public, pointer :: parent => null() class( type_node ), public, pointer :: first_child => null() class( type_node ), public, pointer :: next_sibling => null() Type-Bound Procedures procedure, public :: finalize => node_finalize private recursive subroutine node_finalize (self) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self","tags":"","loc":"type/type_node.html"},{"title":"type_field_node – Fortran Program ","text":"type, private, extends( type_node ) :: type_field_node Inherits type~~type_field_node~~InheritsGraph type~type_field_node type_field_node type~type_node type_node type~type_field_node->type~type_node type~type_field type_field type~type_field_node->type~type_field field type~type_node->type~type_node parent, first_child, next_sibling type~type_field->type~type_field next type~type_nd_data_pointer type_nd_data_pointer type~type_field->type~type_nd_data_pointer data type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_category_node->type~type_node type~type_dimension type_dimension type~type_dimension_pointer->type~type_dimension p type~type_dimension->type~type_field coordinate type~type_dimension->type~type_dimension next type~type_attribute->type~type_attribute next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables parent first_child next_sibling field Type-Bound Procedures finalize Components Type Visibility Attributes Name Initial class( type_node ), public, pointer :: parent => null() class( type_node ), public, pointer :: first_child => null() class( type_node ), public, pointer :: next_sibling => null() type( type_field ), public, pointer :: field => null() Type-Bound Procedures procedure, public :: finalize => node_finalize private recursive subroutine node_finalize (self) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self","tags":"","loc":"type/type_field_node.html"},{"title":"type_category_node – Fortran Program ","text":"type, public, extends( type_node ) :: type_category_node Inherits type~~type_category_node~~InheritsGraph type~type_category_node type_category_node type~type_node type_node type~type_category_node->type~type_node type~type_node->type~type_node parent, first_child, next_sibling Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_category_node~~InheritedByGraph type~type_category_node type_category_node type~type_field_manager type_field_manager type~type_field_manager->type~type_category_node root type~type_dimension type_dimension type~type_field_manager->type~type_dimension first_dimension type~type_dictionary_bin type_dictionary_bin type~type_field_manager->type~type_dictionary_bin field_table type~type_dimension_pointer type_dimension_pointer type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_field type_field type~type_field->type~type_category_node category type~type_field->type~type_field next type~type_field->type~type_dimension_pointer dimensions type~type_output_item type_output_item type~type_output_item->type~type_category_node category type~type_output_item->type~type_field field type~type_output_item->type~type_output_item next type~type_dimension->type~type_field coordinate type~type_dimension->type~type_dimension next type~type_interp_operator type_interp_operator type~type_interp_operator->type~type_field source_field, offset_field type~type_interp_operator->type~type_dimension target_dimension type~type_field_node type_field_node type~type_field_node->type~type_field field type~type_file type_file type~type_file->type~type_field_manager field_manager type~type_file->type~type_output_item first_item type~type_file->type~type_file next type~type_dictionary_bin->type~type_field first_field type~type_field_set_member type_field_set_member type~type_field_set_member->type~type_field field type~type_field_set_member->type~type_field_set_member next type~type_operator_populator type_operator_populator type~type_operator_populator->type~type_field_manager field_manager type~type_file_populator type_file_populator type~type_file_populator->type~type_field_manager fm type~type_output_field type_output_field type~type_output_field->type~type_field source type~type_text_file type_text_file type~type_text_file->type~type_file type~type_coordinate_list_populator type_coordinate_list_populator type~type_coordinate_list_populator->type~type_interp_operator operator type~type_single_text_file_with_1d_variable type_single_text_file_with_1d_variable type~type_single_text_file_with_1d_variable->type~type_dimension dimension type~type_group_populator type_group_populator type~type_group_populator->type~type_file file type~type_field_set type_field_set type~type_field_set->type~type_field_set_member first type~type_dimension_pointer->type~type_dimension p type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_file file type~type_operator_result type_operator_result type~type_operator_result->type~type_dimension_pointer dimensions type~type_universal_operator_result type_universal_operator_result type~type_universal_operator_result->type~type_operator_result type~type_result type_result type~type_result->type~type_operator_result type~type_result~2 type_result type~type_result~2->type~type_universal_operator_result var pantypetype_category_nodeInheritedByGraph = svgPanZoom('#typetype_category_nodeInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables parent first_child next_sibling name output_level Type-Bound Procedures finalize get_all_fields has_fields get_path Components Type Visibility Attributes Name Initial class( type_node ), public, pointer :: parent => null() class( type_node ), public, pointer :: first_child => null() class( type_node ), public, pointer :: next_sibling => null() character(len=string_length), public :: name = '' integer, public :: output_level = output_level_none Type-Bound Procedures procedure, public :: finalize => node_finalize private recursive subroutine node_finalize (self) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self procedure, public :: get_all_fields private recursive subroutine get_all_fields (self, set, output_level) Arguments Type Intent Optional Attributes Name class( type_category_node ), intent(inout) :: self type( type_field_set ), intent(inout) :: set integer, intent(in) :: output_level procedure, public :: has_fields private recursive function has_fields (self) Arguments Type Intent Optional Attributes Name class( type_category_node ), intent(inout) :: self Return Value logical procedure, public :: get_path => category_get_path private function category_get_path (self) result(path) Arguments Type Intent Optional Attributes Name class( type_category_node ), intent(in), target :: self Return Value character(len=256)","tags":"","loc":"type/type_category_node.html"},{"title":"type_dictionary_bin – Fortran Program ","text":"type, private :: type_dictionary_bin Inherits type~~type_dictionary_bin~~InheritsGraph type~type_dictionary_bin type_dictionary_bin type~type_field type_field type~type_dictionary_bin->type~type_field first_field type~type_field->type~type_field next type~type_nd_data_pointer type_nd_data_pointer type~type_field->type~type_nd_data_pointer data type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_node type_node type~type_category_node->type~type_node type~type_dimension type_dimension type~type_dimension_pointer->type~type_dimension p type~type_dimension->type~type_field coordinate type~type_dimension->type~type_dimension next type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute->type~type_attribute next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_dictionary_bin~~InheritedByGraph type~type_dictionary_bin type_dictionary_bin type~type_field_manager type_field_manager type~type_field_manager->type~type_dictionary_bin field_table type~type_file type_file type~type_file->type~type_field_manager field_manager type~type_file->type~type_file next type~type_operator_populator type_operator_populator type~type_operator_populator->type~type_field_manager field_manager type~type_file_populator type_file_populator type~type_file_populator->type~type_field_manager fm type~type_text_file type_text_file type~type_text_file->type~type_file type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_file file type~type_group_populator type_group_populator type~type_group_populator->type~type_file file var pantypetype_dictionary_binInheritedByGraph = svgPanZoom('#typetype_dictionary_binInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables first_field Components Type Visibility Attributes Name Initial type( type_field ), public, pointer :: first_field => null()","tags":"","loc":"type/type_dictionary_bin.html"},{"title":"type_field_set_member – Fortran Program ","text":"type, public :: type_field_set_member Inherits type~~type_field_set_member~~InheritsGraph type~type_field_set_member type_field_set_member type~type_field_set_member->type~type_field_set_member next type~type_field type_field type~type_field_set_member->type~type_field field type~type_field->type~type_field next type~type_nd_data_pointer type_nd_data_pointer type~type_field->type~type_nd_data_pointer data type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_node type_node type~type_category_node->type~type_node type~type_dimension type_dimension type~type_dimension_pointer->type~type_dimension p type~type_dimension->type~type_field coordinate type~type_dimension->type~type_dimension next type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute->type~type_attribute next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_field_set_member~~InheritedByGraph type~type_field_set_member type_field_set_member type~type_field_set_member->type~type_field_set_member next type~type_field_set type_field_set type~type_field_set->type~type_field_set_member first Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables field next Components Type Visibility Attributes Name Initial type( type_field ), public, pointer :: field => null() type( type_field_set_member ), public, pointer :: next => null()","tags":"","loc":"type/type_field_set_member.html"},{"title":"type_field_set – Fortran Program ","text":"type, public :: type_field_set Inherits type~~type_field_set~~InheritsGraph type~type_field_set type_field_set type~type_field_set_member type_field_set_member type~type_field_set->type~type_field_set_member first type~type_field_set_member->type~type_field_set_member next type~type_field type_field type~type_field_set_member->type~type_field field type~type_field->type~type_field next type~type_nd_data_pointer type_nd_data_pointer type~type_field->type~type_nd_data_pointer data type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_node type_node type~type_category_node->type~type_node type~type_dimension type_dimension type~type_dimension_pointer->type~type_dimension p type~type_dimension->type~type_field coordinate type~type_dimension->type~type_dimension next type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute->type~type_attribute next var pantypetype_field_setInheritsGraph = svgPanZoom('#typetype_field_setInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables first Type-Bound Procedures add finalize Components Type Visibility Attributes Name Initial type( type_field_set_member ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: add => field_set_add private subroutine field_set_add (self, field) Arguments Type Intent Optional Attributes Name class( type_field_set ), intent(inout) :: self type( type_field ), target :: field procedure, public :: finalize => field_set_finalize private subroutine field_set_finalize (self) Arguments Type Intent Optional Attributes Name class( type_field_set ), intent(inout) :: self","tags":"","loc":"type/type_field_set.html"},{"title":"type_field_manager – Fortran Program ","text":"type, public :: type_field_manager Inherits type~~type_field_manager~~InheritsGraph type~type_field_manager type_field_manager type~type_dimension type_dimension type~type_field_manager->type~type_dimension first_dimension type~type_category_node type_category_node type~type_field_manager->type~type_category_node root type~type_dictionary_bin type_dictionary_bin type~type_field_manager->type~type_dictionary_bin field_table type~type_dimension_pointer type_dimension_pointer type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_dimension->type~type_dimension next type~type_field type_field type~type_dimension->type~type_field coordinate type~type_node type_node type~type_category_node->type~type_node type~type_dictionary_bin->type~type_field first_field type~type_dimension_pointer->type~type_dimension p type~type_node->type~type_node parent, first_child, next_sibling type~type_field->type~type_category_node category type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_field next type~type_nd_data_pointer type_nd_data_pointer type~type_field->type~type_nd_data_pointer data type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_attribute->type~type_attribute next var pantypetype_field_managerInheritsGraph = svgPanZoom('#typetype_field_managerInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_field_manager~~InheritedByGraph type~type_field_manager type_field_manager type~type_file type_file type~type_file->type~type_field_manager field_manager type~type_file->type~type_file next type~type_operator_populator type_operator_populator type~type_operator_populator->type~type_field_manager field_manager type~type_file_populator type_file_populator type~type_file_populator->type~type_field_manager fm type~type_text_file type_text_file type~type_text_file->type~type_file type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_file file type~type_group_populator type_group_populator type~type_group_populator->type~type_file file Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables first_dimension prepend_dimensions append_dimensions field_table root nregistered Type-Bound Procedures initialize finalize register find list send_data_0d send_data_1d send_data_2d send_data_3d send_data_by_name_0d send_data_by_name_1d send_data_by_name_2d send_data_by_name_3d select_for_output select_category_for_output register_dimension find_dimension find_category get_state reset_used send_data Components Type Visibility Attributes Name Initial type( type_dimension ), public, pointer :: first_dimension => null() type( type_dimension_pointer ), public, allocatable :: prepend_dimensions (:) type( type_dimension_pointer ), public, allocatable :: append_dimensions (:) type( type_dictionary_bin ), public :: field_table (hash_table_size) type( type_category_node ), public :: root integer, public :: nregistered = 0 Type-Bound Procedures procedure, public :: initialize private subroutine initialize (self, prepend_by_default, append_by_default) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self integer, intent(in), optional :: prepend_by_default (:) integer, intent(in), optional :: append_by_default (:) procedure, public :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self procedure, public :: register private subroutine register (self, name, units, long_name, standard_name, fill_value, minimum, maximum, dimensions, data0d, data1d, data2d, data3d, no_default_dimensions, category, output_level, coordinate_dimension, part_of_state, used, used_now, field) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: units character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: standard_name real(kind=rk), intent(in), optional :: fill_value real(kind=rk), intent(in), optional :: minimum real(kind=rk), intent(in), optional :: maximum integer, intent(in), optional :: dimensions (:) real(kind=rk), optional target :: data0d real(kind=rk), optional target :: data1d (:) real(kind=rk), optional target :: data2d (:,:) real(kind=rk), optional target :: data3d (:,:,:) logical, intent(in), optional :: no_default_dimensions character(len=*), intent(in), optional :: category integer, intent(in), optional :: output_level integer, intent(in), optional :: coordinate_dimension logical, intent(in), optional :: part_of_state logical, intent(out), optional :: used logical, optional target :: used_now type( type_field ), optional pointer :: field procedure, public :: find private function find (self, name, create) result(field) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name logical, intent(in), optional :: create Return Value type( type_field ),\n  pointer procedure, public :: list private subroutine list (self) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(in) :: self procedure, public :: send_data_0d private subroutine send_data_0d (self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data procedure, public :: send_data_1d private subroutine send_data_1d (self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data (:) procedure, public :: send_data_2d private subroutine send_data_2d (self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data (:,:) procedure, public :: send_data_3d private subroutine send_data_3d (self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data (:,:,:) procedure, public :: send_data_by_name_0d private subroutine send_data_by_name_0d (self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data procedure, public :: send_data_by_name_1d private subroutine send_data_by_name_1d (self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data (:) procedure, public :: send_data_by_name_2d private subroutine send_data_by_name_2d (self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data (:,:) procedure, public :: send_data_by_name_3d private subroutine send_data_by_name_3d (self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data (:,:,:) procedure, public :: select_for_output private function select_for_output (self, name) result(field) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name Return Value type( type_field ),\n  pointer procedure, public :: select_category_for_output private function select_category_for_output (self, name, output_level) result(category) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(in) :: output_level Return Value class( type_category_node ),\n  pointer procedure, public :: register_dimension private subroutine register_dimension (self, name, length, global_length, offset, id, newid) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(in), optional :: length integer, intent(in), optional :: global_length integer, intent(in), optional :: offset integer, intent(in), optional :: id integer, intent(out), optional :: newid procedure, public :: find_dimension private function find_dimension (self, dimid) result(dim) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(in) :: self integer, intent(in) :: dimid Return Value type( type_dimension ),\n  pointer procedure, public :: find_category private function find_category (self, name, create) result(category) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout), target :: self character(len=*), intent(in) :: name logical, intent(in), optional :: create Return Value class( type_category_node ),\n  pointer procedure, public :: get_state private function get_state (self) result(field_set) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self Return Value type( type_field_set ) procedure, public :: reset_used private subroutine reset_used (self) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self generic, public :: send_data => send_data_0d , send_data_1d , send_data_2d , send_data_3d , send_data_by_name_0d , send_data_by_name_1d , send_data_by_name_2d , send_data_by_name_3d private subroutine send_data_0d (self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data private subroutine send_data_1d (self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data (:) private subroutine send_data_2d (self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data (:,:) private subroutine send_data_3d (self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data (:,:,:) private subroutine send_data_by_name_0d (self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data private subroutine send_data_by_name_1d (self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data (:) private subroutine send_data_by_name_2d (self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data (:,:) private subroutine send_data_by_name_3d (self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data (:,:,:)","tags":"","loc":"type/type_field_manager.html"},{"title":"type_host – Fortran Program ","text":"type, public, abstract :: type_host Contents Type-Bound Procedures julian_day calendar_date fatal_error log_message Type-Bound Procedures procedure( host_julian_day ), public, deferred :: julian_day subroutine host_julian_day(self, yyyy, mm, dd, julian) Prototype Arguments Type Intent Optional Attributes Name class( type_host ), intent(in) :: self integer, intent(in) :: yyyy integer, intent(in) :: mm integer, intent(in) :: dd integer, intent(out) :: julian procedure( host_calendar_date ), public, deferred :: calendar_date subroutine host_calendar_date(self, julian, yyyy, mm, dd) Prototype Arguments Type Intent Optional Attributes Name class( type_host ), intent(in) :: self integer, intent(in) :: julian integer, intent(out) :: yyyy integer, intent(out) :: mm integer, intent(out) :: dd procedure, public :: fatal_error => host_fatal_error private subroutine host_fatal_error (self, location, error) Arguments Type Intent Optional Attributes Name class( type_host ), intent(in) :: self character(len=*), intent(in) :: location character(len=*), intent(in) :: error procedure, public :: log_message => host_log_message private subroutine host_log_message (self, message) Arguments Type Intent Optional Attributes Name class( type_host ), intent(in) :: self character(len=*), intent(in) :: message","tags":"","loc":"type/type_host.html"},{"title":"type_output_variable_settings – Fortran Program ","text":"type, public :: type_output_variable_settings Inherits type~~type_output_variable_settings~~InheritsGraph type~type_output_variable_settings type_output_variable_settings type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_base_operator->type~type_base_operator previous Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_output_variable_settings~~InheritedByGraph type~type_output_variable_settings type_output_variable_settings type~type_base_output_field type_base_output_field type~type_base_output_field->type~type_output_variable_settings settings type~type_base_output_field->type~type_base_output_field next type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_item type_output_item type~type_output_item->type~type_output_variable_settings settings type~type_output_item->type~type_output_item next type~type_group_populator type_group_populator type~type_group_populator->type~type_output_variable_settings variable_settings type~type_file type_file type~type_group_populator->type~type_file file type~type_netcdf_variable_settings type_netcdf_variable_settings type~type_netcdf_variable_settings->type~type_output_variable_settings type~type_operator_populator type_operator_populator type~type_operator_populator->type~type_output_variable_settings variable_settings type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_output_variable_settings variable_settings type~type_variable_populator->type~type_file file type~type_output_field_pointer->type~type_base_output_field p type~type_single_text_file_with_1d_variable type_single_text_file_with_1d_variable type~type_single_text_file_with_1d_variable->type~type_base_output_field field, coordinate type~type_file->type~type_base_output_field first_field type~type_file->type~type_output_item first_item type~type_file->type~type_file next type~type_scalar type_scalar type~type_scalar->type~type_base_output_field field type~type_operator_result type_operator_result type~type_operator_result->type~type_base_output_field source type~type_operator_result->type~type_base_output_field type~type_output_field type_output_field type~type_output_field->type~type_base_output_field type~type_result type_result type~type_result->type~type_base_output_field source_coordinate, offset type~type_result->type~type_operator_result type~type_universal_operator_result type_universal_operator_result type~type_universal_operator_result->type~type_operator_result type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_text_file type_text_file type~type_text_file->type~type_file type~type_single_text_file_with_scalars type_single_text_file_with_scalars type~type_single_text_file_with_scalars->type~type_scalar variables, constants type~type_result~2 type_result type~type_result~2->type~type_universal_operator_result var pantypetype_output_variable_settingsInheritedByGraph = svgPanZoom('#typetype_output_variable_settingsInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables time_method final_operator Type-Bound Procedures initialize Components Type Visibility Attributes Name Initial integer, public :: time_method = time_method_instantaneous class( type_base_operator ), public, pointer :: final_operator => null() Type-Bound Procedures procedure, public :: initialize => output_variable_settings_initialize private subroutine output_variable_settings_initialize (self, settings, parent) Arguments Type Intent Optional Attributes Name class( type_output_variable_settings ), intent(inout) :: self class(type_settings), intent(inout) :: settings class( type_output_variable_settings ), intent(in), optional :: parent","tags":"","loc":"type/type_output_variable_settings.html"},{"title":"type_output_item – Fortran Program ","text":"type, public :: type_output_item Inherits type~~type_output_item~~InheritsGraph type~type_output_item type_output_item type~type_output_item->type~type_output_item next type~type_category_node type_category_node type~type_output_item->type~type_category_node category type~type_field type_field type~type_output_item->type~type_field field type~type_output_variable_settings type_output_variable_settings type~type_output_item->type~type_output_variable_settings settings type~type_node type_node type~type_category_node->type~type_node type~type_field->type~type_category_node category type~type_field->type~type_field next type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_nd_data_pointer type_nd_data_pointer type~type_field->type~type_nd_data_pointer data type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_base_operator->type~type_base_operator previous type~type_dimension type_dimension type~type_dimension_pointer->type~type_dimension p type~type_dimension->type~type_field coordinate type~type_dimension->type~type_dimension next type~type_attribute->type~type_attribute next var pantypetype_output_itemInheritsGraph = svgPanZoom('#typetype_output_itemInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_output_item~~InheritedByGraph type~type_output_item type_output_item type~type_output_item->type~type_output_item next type~type_file type_file type~type_file->type~type_output_item first_item type~type_file->type~type_file next type~type_text_file type_text_file type~type_text_file->type~type_file type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_file file type~type_group_populator type_group_populator type~type_group_populator->type~type_file file Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables settings name prefix postfix output_level category field next Components Type Visibility Attributes Name Initial class( type_output_variable_settings ), public, pointer :: settings => null() character(len=string_length), public :: name = '' character(len=string_length), public :: prefix = '' character(len=string_length), public :: postfix = '' integer, public :: output_level = output_level_default class( type_category_node ), public, pointer :: category => null() type( type_field ), public, pointer :: field => null() type( type_output_item ), public, pointer :: next => null()","tags":"","loc":"type/type_output_item.html"},{"title":"type_output_field_pointer – Fortran Program ","text":"type, private :: type_output_field_pointer Inherits type~~type_output_field_pointer~~InheritsGraph type~type_output_field_pointer type_output_field_pointer type~type_base_output_field type_base_output_field type~type_output_field_pointer->type~type_base_output_field p type~type_base_output_field->type~type_output_field_pointer coordinates type~type_base_output_field->type~type_base_output_field next type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_output_variable_settings type_output_variable_settings type~type_base_output_field->type~type_output_variable_settings settings type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_base_operator->type~type_base_operator previous var pantypetype_output_field_pointerInheritsGraph = svgPanZoom('#typetype_output_field_pointerInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_output_field_pointer~~InheritedByGraph type~type_output_field_pointer type_output_field_pointer type~type_base_output_field type_base_output_field type~type_output_field_pointer->type~type_base_output_field p type~type_base_output_field->type~type_output_field_pointer coordinates type~type_base_output_field->type~type_base_output_field next type~type_single_text_file_with_1d_variable type_single_text_file_with_1d_variable type~type_single_text_file_with_1d_variable->type~type_base_output_field field, coordinate type~type_file type_file type~type_file->type~type_base_output_field first_field type~type_file->type~type_file next type~type_scalar type_scalar type~type_scalar->type~type_base_output_field field type~type_operator_result type_operator_result type~type_operator_result->type~type_base_output_field source type~type_operator_result->type~type_base_output_field type~type_output_field type_output_field type~type_output_field->type~type_base_output_field type~type_result type_result type~type_result->type~type_base_output_field source_coordinate, offset type~type_result->type~type_operator_result type~type_group_populator type_group_populator type~type_group_populator->type~type_file file type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_file file type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_single_text_file_with_scalars type_single_text_file_with_scalars type~type_single_text_file_with_scalars->type~type_scalar variables, constants type~type_universal_operator_result type_universal_operator_result type~type_universal_operator_result->type~type_operator_result type~type_text_file type_text_file type~type_text_file->type~type_file type~type_result~2 type_result type~type_result~2->type~type_universal_operator_result var pantypetype_output_field_pointerInheritedByGraph = svgPanZoom('#typetype_output_field_pointerInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables p Components Type Visibility Attributes Name Initial class( type_base_output_field ), public, pointer :: p => null()","tags":"","loc":"type/type_output_field_pointer.html"},{"title":"type_base_output_field – Fortran Program ","text":"type, public :: type_base_output_field Inherits type~~type_base_output_field~~InheritsGraph type~type_base_output_field type_base_output_field type~type_base_output_field->type~type_base_output_field next type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_variable_settings type_output_variable_settings type~type_base_output_field->type~type_output_variable_settings settings type~type_output_field_pointer->type~type_base_output_field p type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_base_operator->type~type_base_operator previous Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_base_output_field~~InheritedByGraph type~type_base_output_field type_base_output_field type~type_base_output_field->type~type_base_output_field next type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_field_pointer->type~type_base_output_field p type~type_single_text_file_with_1d_variable type_single_text_file_with_1d_variable type~type_single_text_file_with_1d_variable->type~type_base_output_field field, coordinate type~type_file type_file type~type_file->type~type_base_output_field first_field type~type_file->type~type_file next type~type_scalar type_scalar type~type_scalar->type~type_base_output_field field type~type_operator_result type_operator_result type~type_operator_result->type~type_base_output_field source type~type_operator_result->type~type_base_output_field type~type_output_field type_output_field type~type_output_field->type~type_base_output_field type~type_result type_result type~type_result->type~type_base_output_field source_coordinate, offset type~type_result->type~type_operator_result type~type_group_populator type_group_populator type~type_group_populator->type~type_file file type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_file file type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_single_text_file_with_scalars type_single_text_file_with_scalars type~type_single_text_file_with_scalars->type~type_scalar variables, constants type~type_universal_operator_result type_universal_operator_result type~type_universal_operator_result->type~type_operator_result type~type_text_file type_text_file type~type_text_file->type~type_file type~type_result~2 type_result type~type_result~2->type~type_universal_operator_result var pantypetype_base_output_fieldInheritedByGraph = svgPanZoom('#typetype_base_output_fieldInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables settings output_name is_coordinate data coordinates next Type-Bound Procedures new_data before_save flag_as_required get_metadata get_field Components Type Visibility Attributes Name Initial class( type_output_variable_settings ), public, pointer :: settings => null() character(len=string_length), public :: output_name = '' logical, public :: is_coordinate = .false. type( type_nd_data_pointer ), public :: data type( type_output_field_pointer ), public, allocatable :: coordinates (:) class( type_base_output_field ), public, pointer :: next => null() Type-Bound Procedures procedure, public :: new_data => base_field_new_data private recursive subroutine base_field_new_data (self) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(inout) :: self procedure, public :: before_save => base_field_before_save private recursive subroutine base_field_before_save (self) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(inout) :: self procedure, public :: flag_as_required => base_field_flag_as_required private recursive subroutine base_field_flag_as_required (self, required) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(inout) :: self logical, intent(in) :: required procedure, public :: get_metadata => base_field_get_metadata private recursive subroutine base_field_get_metadata (self, long_name, units, dimensions, minimum, maximum, fill_value, standard_name, path, attributes) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(in) :: self character(len=:), intent(out), optional allocatable :: long_name character(len=:), intent(out), optional allocatable :: units type( type_dimension_pointer ), intent(out), optional allocatable :: dimensions (:) real(kind=rk), intent(out), optional :: minimum real(kind=rk), intent(out), optional :: maximum real(kind=rk), intent(out), optional :: fill_value character(len=:), intent(out), optional allocatable :: standard_name character(len=:), intent(out), optional allocatable :: path type( type_attributes ), intent(out), optional :: attributes procedure, public :: get_field => base_field_get_field private recursive function base_field_get_field (self, field) result(output_field) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(in) :: self type( type_field ), target :: field Return Value class( type_base_output_field ),\n  pointer","tags":"","loc":"type/type_base_output_field.html"},{"title":"type_output_field – Fortran Program ","text":"type, public, extends( type_base_output_field ) :: type_output_field Inherits type~~type_output_field~~InheritsGraph type~type_output_field type_output_field type~type_base_output_field type_base_output_field type~type_output_field->type~type_base_output_field type~type_field type_field type~type_output_field->type~type_field source type~type_base_output_field->type~type_base_output_field next type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_variable_settings type_output_variable_settings type~type_base_output_field->type~type_output_variable_settings settings type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_field->type~type_field next type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_nd_data_pointer data type~type_output_field_pointer->type~type_base_output_field p type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_node type_node type~type_category_node->type~type_node type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_dimension type_dimension type~type_dimension_pointer->type~type_dimension p type~type_dimension->type~type_field coordinate type~type_dimension->type~type_dimension next type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute->type~type_attribute next type~type_base_operator->type~type_base_operator previous var pantypetype_output_fieldInheritsGraph = svgPanZoom('#typetype_output_fieldInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables settings output_name is_coordinate data coordinates next source Type-Bound Procedures new_data before_save get_field flag_as_required get_metadata Components Type Visibility Attributes Name Initial class( type_output_variable_settings ), public, pointer :: settings => null() character(len=string_length), public :: output_name = '' logical, public :: is_coordinate = .false. type( type_nd_data_pointer ), public :: data type( type_output_field_pointer ), public, allocatable :: coordinates (:) class( type_base_output_field ), public, pointer :: next => null() type( type_field ), public, pointer :: source => null() Type-Bound Procedures procedure, public :: new_data => base_field_new_data private recursive subroutine base_field_new_data (self) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(inout) :: self procedure, public :: before_save => base_field_before_save private recursive subroutine base_field_before_save (self) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(inout) :: self procedure, public :: get_field => base_field_get_field private recursive function base_field_get_field (self, field) result(output_field) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(in) :: self type( type_field ), target :: field Return Value class( type_base_output_field ),\n  pointer procedure, public :: flag_as_required => field_flag_as_required private recursive subroutine field_flag_as_required (self, required) Arguments Type Intent Optional Attributes Name class( type_output_field ), intent(inout) :: self logical, intent(in) :: required procedure, public :: get_metadata => field_get_metadata private recursive subroutine field_get_metadata (self, long_name, units, dimensions, minimum, maximum, fill_value, standard_name, path, attributes) Arguments Type Intent Optional Attributes Name class( type_output_field ), intent(in) :: self character(len=:), intent(out), optional allocatable :: long_name character(len=:), intent(out), optional allocatable :: units type( type_dimension_pointer ), intent(out), optional allocatable :: dimensions (:) real(kind=rk), intent(out), optional :: minimum real(kind=rk), intent(out), optional :: maximum real(kind=rk), intent(out), optional :: fill_value character(len=:), intent(out), optional allocatable :: standard_name character(len=:), intent(out), optional allocatable :: path type( type_attributes ), intent(out), optional :: attributes","tags":"","loc":"type/type_output_field.html"},{"title":"type_file – Fortran Program ","text":"type, public :: type_file Inherits type~~type_file~~InheritsGraph type~type_file type_file type~type_file->type~type_file next type~type_field_manager type_field_manager type~type_file->type~type_field_manager field_manager type~type_base_output_field type_base_output_field type~type_file->type~type_base_output_field first_field type~type_output_item type_output_item type~type_file->type~type_output_item first_item type~type_dimension type_dimension type~type_field_manager->type~type_dimension first_dimension type~type_dictionary_bin type_dictionary_bin type~type_field_manager->type~type_dictionary_bin field_table type~type_dimension_pointer type_dimension_pointer type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_category_node type_category_node type~type_field_manager->type~type_category_node root type~type_base_output_field->type~type_base_output_field next type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_variable_settings type_output_variable_settings type~type_base_output_field->type~type_output_variable_settings settings type~type_output_item->type~type_output_item next type~type_output_item->type~type_output_variable_settings settings type~type_output_item->type~type_category_node category type~type_field type_field type~type_output_item->type~type_field field type~type_dimension->type~type_dimension next type~type_dimension->type~type_field coordinate type~type_output_field_pointer->type~type_base_output_field p type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_dictionary_bin->type~type_field first_field type~type_dimension_pointer->type~type_dimension p type~type_node type_node type~type_category_node->type~type_node type~type_field->type~type_nd_data_pointer data type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_category_node category type~type_field->type~type_field next type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_base_operator->type~type_base_operator previous type~type_attribute->type~type_attribute next var pantypetype_fileInheritsGraph = svgPanZoom('#typetype_fileInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_file~~InheritedByGraph type~type_file type_file type~type_file->type~type_file next type~type_text_file type_text_file type~type_text_file->type~type_file type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_file file type~type_group_populator type_group_populator type~type_group_populator->type~type_file file Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables field_manager path postfix title time_unit time_step first_index next_julian next_seconds first_julian first_seconds last_julian last_seconds first_item first_field next Type-Bound Procedures configure initialize save finalize create_settings is_dimension_used append_item Components Type Visibility Attributes Name Initial type( type_field_manager ), public, pointer :: field_manager => null() character(len=max_path), public :: path = '' character(len=max_path), public :: postfix = '' character(len=string_length), public :: title = '' integer, public :: time_unit = time_unit_none integer, public :: time_step = 0 integer, public :: first_index = 0 integer, public :: next_julian = -1 integer, public :: next_seconds = -1 integer, public :: first_julian = -1 integer, public :: first_seconds = -1 integer, public :: last_julian = huge(1) integer, public :: last_seconds = 0 type( type_output_item ), public, pointer :: first_item => null() class( type_base_output_field ), public, pointer :: first_field => null() class( type_file ), public, pointer :: next => null() Type-Bound Procedures procedure, public :: configure private subroutine configure (self, settings) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self class(type_settings), intent(inout) :: settings procedure, public :: initialize private subroutine initialize (self) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self procedure, public :: save private subroutine save (self, julianday, secondsofday, microseconds) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds procedure, public :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self procedure, public :: create_settings private function create_settings (self) result(settings) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self Return Value class( type_output_variable_settings ),\n  pointer procedure, public :: is_dimension_used private function is_dimension_used (self, dim) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self type( type_dimension ), target :: dim Return Value logical procedure, public :: append_item private subroutine append_item (self, item) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self type( type_output_item ), target :: item","tags":"","loc":"type/type_file.html"},{"title":"type_base_operator – Fortran Program ","text":"type, public :: type_base_operator Inherited by type~~type_base_operator~~InheritedByGraph type~type_base_operator type_base_operator type~type_base_operator->type~type_base_operator previous type~type_slice_operator type_slice_operator type~type_slice_operator->type~type_base_operator type~type_interp_operator type_interp_operator type~type_interp_operator->type~type_base_operator type~type_output_variable_settings type_output_variable_settings type~type_output_variable_settings->type~type_base_operator final_operator type~type_time_average_operator type_time_average_operator type~type_time_average_operator->type~type_base_operator type~type_operator_result type_operator_result type~type_operator_result->type~type_base_operator operator type~type_base_output_field type_base_output_field type~type_operator_result->type~type_base_output_field source type~type_operator_result->type~type_base_output_field type~type_base_output_field->type~type_output_variable_settings settings type~type_base_output_field->type~type_base_output_field next type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_coordinate_list_populator type_coordinate_list_populator type~type_coordinate_list_populator->type~type_interp_operator operator type~type_output_item type_output_item type~type_output_item->type~type_output_variable_settings settings type~type_output_item->type~type_output_item next type~type_group_populator type_group_populator type~type_group_populator->type~type_output_variable_settings variable_settings type~type_file type_file type~type_group_populator->type~type_file file type~type_netcdf_variable_settings type_netcdf_variable_settings type~type_netcdf_variable_settings->type~type_output_variable_settings type~type_operator_populator type_operator_populator type~type_operator_populator->type~type_output_variable_settings variable_settings type~type_universal_operator_result type_universal_operator_result type~type_universal_operator_result->type~type_operator_result type~type_result type_result type~type_result->type~type_operator_result type~type_result->type~type_base_output_field source_coordinate, offset type~type_variable_populator type_variable_populator type~type_variable_populator->type~type_output_variable_settings variable_settings type~type_variable_populator->type~type_file file type~type_output_field_pointer->type~type_base_output_field p type~type_single_text_file_with_1d_variable type_single_text_file_with_1d_variable type~type_single_text_file_with_1d_variable->type~type_base_output_field field, coordinate type~type_file->type~type_base_output_field first_field type~type_file->type~type_output_item first_item type~type_file->type~type_file next type~type_scalar type_scalar type~type_scalar->type~type_base_output_field field type~type_result~2 type_result type~type_result~2->type~type_universal_operator_result type~type_output_field type_output_field type~type_output_field->type~type_base_output_field type~type_netcdf_file type_netcdf_file type~type_netcdf_file->type~type_file type~type_text_file type_text_file type~type_text_file->type~type_file type~type_single_text_file_with_scalars type_single_text_file_with_scalars type~type_single_text_file_with_scalars->type~type_scalar variables, constants var pantypetype_base_operatorInheritedByGraph = svgPanZoom('#typetype_base_operatorInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables previous Type-Bound Procedures configure apply apply_all Components Type Visibility Attributes Name Initial class( type_base_operator ), public, pointer :: previous => null() Type-Bound Procedures procedure, public :: configure => operator_configure private subroutine operator_configure (self, settings, field_manager) Arguments Type Intent Optional Attributes Name class( type_base_operator ), intent(inout), target :: self class(type_settings), intent(inout) :: settings type( type_field_manager ), intent(inout) :: field_manager procedure, public :: apply => operator_apply private function operator_apply (self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_base_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer procedure, public :: apply_all => operator_apply_all private recursive function operator_apply_all (self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_base_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer","tags":"","loc":"type/type_base_operator.html"},{"title":"type_file_populator – Fortran Program ","text":"type, private, extends(type_dictionary_populator) :: type_file_populator Inherits type~~type_file_populator~~InheritsGraph type~type_file_populator type_file_populator type~type_field_manager type_field_manager type~type_file_populator->type~type_field_manager fm type_dictionary_populator type_dictionary_populator type~type_file_populator->type_dictionary_populator type~type_dimension type_dimension type~type_field_manager->type~type_dimension first_dimension type~type_category_node type_category_node type~type_field_manager->type~type_category_node root type~type_dictionary_bin type_dictionary_bin type~type_field_manager->type~type_dictionary_bin field_table type~type_dimension_pointer type_dimension_pointer type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_dimension->type~type_dimension next type~type_field type_field type~type_dimension->type~type_field coordinate type~type_node type_node type~type_category_node->type~type_node type~type_dictionary_bin->type~type_field first_field type~type_dimension_pointer->type~type_dimension p type~type_node->type~type_node parent, first_child, next_sibling type~type_field->type~type_category_node category type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_field next type~type_nd_data_pointer type_nd_data_pointer type~type_field->type~type_nd_data_pointer data type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_attribute->type~type_attribute next var pantypetype_file_populatorInheritsGraph = svgPanZoom('#typetype_file_populatorInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables fm title postfix Type-Bound Procedures create Components Type Visibility Attributes Name Initial type( type_field_manager ), public, pointer :: fm => null() character(len=:), public, allocatable :: title character(len=:), public, allocatable :: postfix Type-Bound Procedures procedure, public :: create => process_file private subroutine process_file (self, pair) Arguments Type Intent Optional Attributes Name class( type_file_populator ), intent(inout) :: self type(type_key_value_pair), intent(inout) :: pair","tags":"","loc":"type/type_file_populator.html"},{"title":"type_operator_populator – Fortran Program ","text":"type, private, extends(type_list_populator) :: type_operator_populator Inherits type~~type_operator_populator~~InheritsGraph type~type_operator_populator type_operator_populator type~type_field_manager type_field_manager type~type_operator_populator->type~type_field_manager field_manager type_list_populator type_list_populator type~type_operator_populator->type_list_populator type~type_output_variable_settings type_output_variable_settings type~type_operator_populator->type~type_output_variable_settings variable_settings type~type_dimension type_dimension type~type_field_manager->type~type_dimension first_dimension type~type_dictionary_bin type_dictionary_bin type~type_field_manager->type~type_dictionary_bin field_table type~type_dimension_pointer type_dimension_pointer type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_category_node type_category_node type~type_field_manager->type~type_category_node root type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_dimension->type~type_dimension next type~type_field type_field type~type_dimension->type~type_field coordinate type~type_base_operator->type~type_base_operator previous type~type_dictionary_bin->type~type_field first_field type~type_dimension_pointer->type~type_dimension p type~type_node type_node type~type_category_node->type~type_node type~type_node->type~type_node parent, first_child, next_sibling type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_category_node category type~type_field->type~type_field next type~type_nd_data_pointer type_nd_data_pointer type~type_field->type~type_nd_data_pointer data type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_attribute->type~type_attribute next var pantypetype_operator_populatorInheritsGraph = svgPanZoom('#typetype_operator_populatorInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables field_manager variable_settings Type-Bound Procedures create Components Type Visibility Attributes Name Initial type( type_field_manager ), public, pointer :: field_manager => null() class( type_output_variable_settings ), public, pointer :: variable_settings => null() Type-Bound Procedures procedure, public :: create => create_operator_settings private recursive subroutine create_operator_settings (self, index, item) Arguments Type Intent Optional Attributes Name class( type_operator_populator ), intent(inout) :: self integer, intent(in) :: index type(type_list_item), intent(inout) :: item","tags":"","loc":"type/type_operator_populator.html"},{"title":"type_group_populator – Fortran Program ","text":"type, private, extends(type_list_populator) :: type_group_populator Inherits type~~type_group_populator~~InheritsGraph type~type_group_populator type_group_populator type~type_file type_file type~type_group_populator->type~type_file file type_list_populator type_list_populator type~type_group_populator->type_list_populator type~type_output_variable_settings type_output_variable_settings type~type_group_populator->type~type_output_variable_settings variable_settings type~type_file->type~type_file next type~type_field_manager type_field_manager type~type_file->type~type_field_manager field_manager type~type_base_output_field type_base_output_field type~type_file->type~type_base_output_field first_field type~type_output_item type_output_item type~type_file->type~type_output_item first_item type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_dimension type_dimension type~type_field_manager->type~type_dimension first_dimension type~type_dictionary_bin type_dictionary_bin type~type_field_manager->type~type_dictionary_bin field_table type~type_dimension_pointer type_dimension_pointer type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_category_node type_category_node type~type_field_manager->type~type_category_node root type~type_base_output_field->type~type_output_variable_settings settings type~type_base_output_field->type~type_base_output_field next type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_item->type~type_output_variable_settings settings type~type_output_item->type~type_output_item next type~type_output_item->type~type_category_node category type~type_field type_field type~type_output_item->type~type_field field type~type_base_operator->type~type_base_operator previous type~type_dimension->type~type_dimension next type~type_dimension->type~type_field coordinate type~type_output_field_pointer->type~type_base_output_field p type~type_dictionary_bin->type~type_field first_field type~type_dimension_pointer->type~type_dimension p type~type_node type_node type~type_category_node->type~type_node type~type_field->type~type_nd_data_pointer data type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_category_node category type~type_field->type~type_field next type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_attribute->type~type_attribute next var pantypetype_group_populatorInheritsGraph = svgPanZoom('#typetype_group_populatorInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables file variable_settings Type-Bound Procedures create Components Type Visibility Attributes Name Initial class( type_file ), public, pointer :: file class( type_output_variable_settings ), public, pointer :: variable_settings => null() Type-Bound Procedures procedure, public :: create => create_group_settings private recursive subroutine create_group_settings (self, index, item) Arguments Type Intent Optional Attributes Name class( type_group_populator ), intent(inout) :: self integer, intent(in) :: index type(type_list_item), intent(inout) :: item","tags":"","loc":"type/type_group_populator.html"},{"title":"type_variable_populator – Fortran Program ","text":"type, private, extends(type_list_populator) :: type_variable_populator Inherits type~~type_variable_populator~~InheritsGraph type~type_variable_populator type_variable_populator type~type_file type_file type~type_variable_populator->type~type_file file type_list_populator type_list_populator type~type_variable_populator->type_list_populator type~type_output_variable_settings type_output_variable_settings type~type_variable_populator->type~type_output_variable_settings variable_settings type~type_file->type~type_file next type~type_field_manager type_field_manager type~type_file->type~type_field_manager field_manager type~type_base_output_field type_base_output_field type~type_file->type~type_base_output_field first_field type~type_output_item type_output_item type~type_file->type~type_output_item first_item type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_dimension type_dimension type~type_field_manager->type~type_dimension first_dimension type~type_dictionary_bin type_dictionary_bin type~type_field_manager->type~type_dictionary_bin field_table type~type_dimension_pointer type_dimension_pointer type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_category_node type_category_node type~type_field_manager->type~type_category_node root type~type_base_output_field->type~type_output_variable_settings settings type~type_base_output_field->type~type_base_output_field next type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_item->type~type_output_variable_settings settings type~type_output_item->type~type_output_item next type~type_output_item->type~type_category_node category type~type_field type_field type~type_output_item->type~type_field field type~type_base_operator->type~type_base_operator previous type~type_dimension->type~type_dimension next type~type_dimension->type~type_field coordinate type~type_output_field_pointer->type~type_base_output_field p type~type_dictionary_bin->type~type_field first_field type~type_dimension_pointer->type~type_dimension p type~type_node type_node type~type_category_node->type~type_node type~type_field->type~type_nd_data_pointer data type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_category_node category type~type_field->type~type_field next type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_attribute->type~type_attribute next var pantypetype_variable_populatorInheritsGraph = svgPanZoom('#typetype_variable_populatorInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables file variable_settings Type-Bound Procedures create Components Type Visibility Attributes Name Initial class( type_file ), public, pointer :: file => null() class( type_output_variable_settings ), public, pointer :: variable_settings => null() Type-Bound Procedures procedure, public :: create => create_variable_settings private recursive subroutine create_variable_settings (self, index, item) Arguments Type Intent Optional Attributes Name class( type_variable_populator ), intent(inout) :: self integer, intent(in) :: index type(type_list_item), intent(inout) :: item","tags":"","loc":"type/type_variable_populator.html"},{"title":"type_netcdf_file – Fortran Program ","text":"type, public, extends( type_file ) :: type_netcdf_file Inherits type~~type_netcdf_file~~InheritsGraph type~type_netcdf_file type_netcdf_file type~type_file type_file type~type_netcdf_file->type~type_file type~type_file->type~type_file next type~type_field_manager type_field_manager type~type_file->type~type_field_manager field_manager type~type_base_output_field type_base_output_field type~type_file->type~type_base_output_field first_field type~type_output_item type_output_item type~type_file->type~type_output_item first_item type~type_dimension type_dimension type~type_field_manager->type~type_dimension first_dimension type~type_dictionary_bin type_dictionary_bin type~type_field_manager->type~type_dictionary_bin field_table type~type_dimension_pointer type_dimension_pointer type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_category_node type_category_node type~type_field_manager->type~type_category_node root type~type_base_output_field->type~type_base_output_field next type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_variable_settings type_output_variable_settings type~type_base_output_field->type~type_output_variable_settings settings type~type_output_item->type~type_output_item next type~type_output_item->type~type_output_variable_settings settings type~type_output_item->type~type_category_node category type~type_field type_field type~type_output_item->type~type_field field type~type_dimension->type~type_dimension next type~type_dimension->type~type_field coordinate type~type_output_field_pointer->type~type_base_output_field p type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_dictionary_bin->type~type_field first_field type~type_dimension_pointer->type~type_dimension p type~type_node type_node type~type_category_node->type~type_node type~type_field->type~type_nd_data_pointer data type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_category_node category type~type_field->type~type_field next type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_base_operator->type~type_base_operator previous type~type_attribute->type~type_attribute next var pantypetype_netcdf_fileInheritsGraph = svgPanZoom('#typetype_netcdf_fileInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables field_manager path postfix title time_unit time_step first_index next_julian next_seconds first_julian first_seconds last_julian last_seconds first_item first_field next itime ncid time_id reference_julian reference_seconds sync_interval Type-Bound Procedures is_dimension_used append_item configure initialize save finalize create_settings Components Type Visibility Attributes Name Initial type( type_field_manager ), public, pointer :: field_manager => null() character(len=max_path), public :: path = '' character(len=max_path), public :: postfix = '' character(len=string_length), public :: title = '' integer, public :: time_unit = time_unit_none integer, public :: time_step = 0 integer, public :: first_index = 0 integer, public :: next_julian = -1 integer, public :: next_seconds = -1 integer, public :: first_julian = -1 integer, public :: first_seconds = -1 integer, public :: last_julian = huge(1) integer, public :: last_seconds = 0 type( type_output_item ), public, pointer :: first_item => null() class( type_base_output_field ), public, pointer :: first_field => null() class( type_file ), public, pointer :: next => null() integer, public :: itime = 0 integer, public :: ncid = -1 integer, public :: time_id = -1 integer, public :: reference_julian = -1 integer, public :: reference_seconds = -1 integer, public :: sync_interval = 1 Type-Bound Procedures procedure, public :: is_dimension_used private function is_dimension_used (self, dim) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self type( type_dimension ), target :: dim Return Value logical procedure, public :: append_item private subroutine append_item (self, item) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self type( type_output_item ), target :: item procedure, public :: configure private subroutine configure (self, settings) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self class(type_settings), intent(inout) :: settings procedure, public :: initialize private subroutine initialize (self) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self procedure, public :: save private subroutine save (self, julianday, secondsofday, microseconds) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds procedure, public :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self procedure, public :: create_settings private function create_settings (self) result(settings) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self Return Value class( type_output_variable_settings ),\n  pointer","tags":"","loc":"type/type_netcdf_file.html"},{"title":"type_netcdf_variable_settings – Fortran Program ","text":"type, public, extends( type_output_variable_settings ) :: type_netcdf_variable_settings Inherits type~~type_netcdf_variable_settings~~InheritsGraph type~type_netcdf_variable_settings type_netcdf_variable_settings type~type_output_variable_settings type_output_variable_settings type~type_netcdf_variable_settings->type~type_output_variable_settings type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_base_operator->type~type_base_operator previous Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables time_method final_operator varid start edges itimedim xtype Type-Bound Procedures initialize Components Type Visibility Attributes Name Initial integer, public :: time_method = time_method_instantaneous class( type_base_operator ), public, pointer :: final_operator => null() integer, public :: varid = -1 integer, public, allocatable :: start (:) integer, public, allocatable :: edges (:) integer, public :: itimedim = -1 integer, public :: xtype = -1 Type-Bound Procedures procedure, public :: initialize => netcdf_variable_settings_initialize private subroutine netcdf_variable_settings_initialize (self, settings, parent) Arguments Type Intent Optional Attributes Name class( type_netcdf_variable_settings ), intent(inout) :: self class(type_settings), intent(inout) :: settings class( type_output_variable_settings ), intent(in), optional :: parent","tags":"","loc":"type/type_netcdf_variable_settings.html"},{"title":"type_single_text_file – Fortran Program ","text":"type, private, abstract :: type_single_text_file Inherited by type~~type_single_text_file~~InheritedByGraph type~type_single_text_file type_single_text_file type~type_single_text_file->type~type_single_text_file next type~type_single_text_file_with_scalars type_single_text_file_with_scalars type~type_single_text_file_with_scalars->type~type_single_text_file type~type_text_file type_text_file type~type_text_file->type~type_single_text_file first_file type~type_single_text_file_with_1d_variable type_single_text_file_with_1d_variable type~type_single_text_file_with_1d_variable->type~type_single_text_file Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables path title unit next Type-Bound Procedures write_header write_data Components Type Visibility Attributes Name Initial character(len=max_path), public :: path = '' character(len=max_path), public :: title = '' integer, public :: unit = -1 class( type_single_text_file ), public, pointer :: next => null() Type-Bound Procedures procedure( host_write_header ), public, deferred :: write_header subroutine host_write_header(self) Prototype Arguments Type Intent Optional Attributes Name class( type_single_text_file ), intent(in) :: self procedure( host_write_data ), public, deferred :: write_data subroutine host_write_data(self, timestr) Prototype Arguments Type Intent Optional Attributes Name class( type_single_text_file ), intent(in) :: self character(len=*), intent(in) :: timestr","tags":"","loc":"type/type_single_text_file.html"},{"title":"type_scalar – Fortran Program ","text":"type, private :: type_scalar Inherits type~~type_scalar~~InheritsGraph type~type_scalar type_scalar type~type_base_output_field type_base_output_field type~type_scalar->type~type_base_output_field field type~type_base_output_field->type~type_base_output_field next type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_variable_settings type_output_variable_settings type~type_base_output_field->type~type_output_variable_settings settings type~type_output_field_pointer->type~type_base_output_field p type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_base_operator->type~type_base_operator previous var pantypetype_scalarInheritsGraph = svgPanZoom('#typetype_scalarInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_scalar~~InheritedByGraph type~type_scalar type_scalar type~type_single_text_file_with_scalars type_single_text_file_with_scalars type~type_single_text_file_with_scalars->type~type_scalar variables, constants Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables field value Components Type Visibility Attributes Name Initial class( type_base_output_field ), public, pointer :: field => null() real(kind=rk), public, pointer :: value => null()","tags":"","loc":"type/type_scalar.html"},{"title":"type_single_text_file_with_scalars – Fortran Program ","text":"type, private, extends( type_single_text_file ) :: type_single_text_file_with_scalars Inherits type~~type_single_text_file_with_scalars~~InheritsGraph type~type_single_text_file_with_scalars type_single_text_file_with_scalars type~type_single_text_file type_single_text_file type~type_single_text_file_with_scalars->type~type_single_text_file type~type_scalar type_scalar type~type_single_text_file_with_scalars->type~type_scalar variables, constants type~type_single_text_file->type~type_single_text_file next type~type_base_output_field type_base_output_field type~type_scalar->type~type_base_output_field field type~type_base_output_field->type~type_base_output_field next type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_variable_settings type_output_variable_settings type~type_base_output_field->type~type_output_variable_settings settings type~type_output_field_pointer->type~type_base_output_field p type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_base_operator->type~type_base_operator previous var pantypetype_single_text_file_with_scalarsInheritsGraph = svgPanZoom('#typetype_single_text_file_with_scalarsInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables path title unit next variables constants Type-Bound Procedures write_header write_data Components Type Visibility Attributes Name Initial character(len=max_path), public :: path = '' character(len=max_path), public :: title = '' integer, public :: unit = -1 class( type_single_text_file ), public, pointer :: next => null() type( type_scalar ), public, allocatable :: variables (:) type( type_scalar ), public, allocatable :: constants (:) Type-Bound Procedures procedure, public :: write_header => single_text_file_with_scalars_write_header private subroutine single_text_file_with_scalars_write_header (self) Arguments Type Intent Optional Attributes Name class( type_single_text_file_with_scalars ), intent(in) :: self procedure, public :: write_data => single_text_file_with_scalars_write_data private subroutine single_text_file_with_scalars_write_data (self, timestr) Arguments Type Intent Optional Attributes Name class( type_single_text_file_with_scalars ), intent(in) :: self character(len=*), intent(in) :: timestr","tags":"","loc":"type/type_single_text_file_with_scalars.html"},{"title":"type_single_text_file_with_1d_variable – Fortran Program ","text":"type, private, extends( type_single_text_file ) :: type_single_text_file_with_1d_variable Inherits type~~type_single_text_file_with_1d_variable~~InheritsGraph type~type_single_text_file_with_1d_variable type_single_text_file_with_1d_variable type~type_dimension type_dimension type~type_single_text_file_with_1d_variable->type~type_dimension dimension type~type_base_output_field type_base_output_field type~type_single_text_file_with_1d_variable->type~type_base_output_field field, coordinate type~type_single_text_file type_single_text_file type~type_single_text_file_with_1d_variable->type~type_single_text_file type~type_dimension->type~type_dimension next type~type_field type_field type~type_dimension->type~type_field coordinate type~type_base_output_field->type~type_base_output_field next type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_variable_settings type_output_variable_settings type~type_base_output_field->type~type_output_variable_settings settings type~type_single_text_file->type~type_single_text_file next type~type_field->type~type_nd_data_pointer data type~type_field->type~type_field next type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_output_field_pointer->type~type_base_output_field p type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_node type_node type~type_category_node->type~type_node type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_dimension_pointer->type~type_dimension p type~type_base_operator->type~type_base_operator previous type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute->type~type_attribute next var pantypetype_single_text_file_with_1d_variableInheritsGraph = svgPanZoom('#typetype_single_text_file_with_1d_variableInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables path title unit next field dimension coordinate values Type-Bound Procedures write_header write_data Components Type Visibility Attributes Name Initial character(len=max_path), public :: path = '' character(len=max_path), public :: title = '' integer, public :: unit = -1 class( type_single_text_file ), public, pointer :: next => null() class( type_base_output_field ), public, pointer :: field => null() type( type_dimension ), public, pointer :: dimension => null() class( type_base_output_field ), public, pointer :: coordinate => null() real(kind=rk), public, pointer :: values (:) => null() Type-Bound Procedures procedure, public :: write_header => single_text_file_with_1d_variable_write_header private subroutine single_text_file_with_1d_variable_write_header (self) Arguments Type Intent Optional Attributes Name class( type_single_text_file_with_1d_variable ), intent(in) :: self procedure, public :: write_data => single_text_file_with_1d_variable_write_data private subroutine single_text_file_with_1d_variable_write_data (self, timestr) Arguments Type Intent Optional Attributes Name class( type_single_text_file_with_1d_variable ), intent(in) :: self character(len=*), intent(in) :: timestr","tags":"","loc":"type/type_single_text_file_with_1d_variable.html"},{"title":"type_text_file – Fortran Program ","text":"type, public, extends( type_file ) :: type_text_file Inherits type~~type_text_file~~InheritsGraph type~type_text_file type_text_file type~type_file type_file type~type_text_file->type~type_file type~type_single_text_file type_single_text_file type~type_text_file->type~type_single_text_file first_file type~type_file->type~type_file next type~type_field_manager type_field_manager type~type_file->type~type_field_manager field_manager type~type_base_output_field type_base_output_field type~type_file->type~type_base_output_field first_field type~type_output_item type_output_item type~type_file->type~type_output_item first_item type~type_single_text_file->type~type_single_text_file next type~type_dimension type_dimension type~type_field_manager->type~type_dimension first_dimension type~type_dictionary_bin type_dictionary_bin type~type_field_manager->type~type_dictionary_bin field_table type~type_dimension_pointer type_dimension_pointer type~type_field_manager->type~type_dimension_pointer prepend_dimensions, append_dimensions type~type_category_node type_category_node type~type_field_manager->type~type_category_node root type~type_base_output_field->type~type_base_output_field next type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_variable_settings type_output_variable_settings type~type_base_output_field->type~type_output_variable_settings settings type~type_output_item->type~type_output_item next type~type_output_item->type~type_output_variable_settings settings type~type_output_item->type~type_category_node category type~type_field type_field type~type_output_item->type~type_field field type~type_dimension->type~type_dimension next type~type_dimension->type~type_field coordinate type~type_output_field_pointer->type~type_base_output_field p type~type_base_operator type_base_operator type~type_output_variable_settings->type~type_base_operator final_operator type~type_dictionary_bin->type~type_field first_field type~type_dimension_pointer->type~type_dimension p type~type_node type_node type~type_category_node->type~type_node type~type_field->type~type_nd_data_pointer data type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_category_node category type~type_field->type~type_field next type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_base_operator->type~type_base_operator previous type~type_attribute->type~type_attribute next var pantypetype_text_fileInheritsGraph = svgPanZoom('#typetype_text_fileInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables field_manager path postfix title time_unit time_step first_index next_julian next_seconds first_julian first_seconds last_julian last_seconds first_item first_field next first_file Type-Bound Procedures configure create_settings is_dimension_used append_item initialize save finalize Components Type Visibility Attributes Name Initial type( type_field_manager ), public, pointer :: field_manager => null() character(len=max_path), public :: path = '' character(len=max_path), public :: postfix = '' character(len=string_length), public :: title = '' integer, public :: time_unit = time_unit_none integer, public :: time_step = 0 integer, public :: first_index = 0 integer, public :: next_julian = -1 integer, public :: next_seconds = -1 integer, public :: first_julian = -1 integer, public :: first_seconds = -1 integer, public :: last_julian = huge(1) integer, public :: last_seconds = 0 type( type_output_item ), public, pointer :: first_item => null() class( type_base_output_field ), public, pointer :: first_field => null() class( type_file ), public, pointer :: next => null() class( type_single_text_file ), public, pointer :: first_file => null() Type-Bound Procedures procedure, public :: configure private subroutine configure (self, settings) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self class(type_settings), intent(inout) :: settings procedure, public :: create_settings private function create_settings (self) result(settings) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self Return Value class( type_output_variable_settings ),\n  pointer procedure, public :: is_dimension_used private function is_dimension_used (self, dim) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self type( type_dimension ), target :: dim Return Value logical procedure, public :: append_item private subroutine append_item (self, item) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self type( type_output_item ), target :: item procedure, public :: initialize private subroutine initialize (self) Arguments Type Intent Optional Attributes Name class( type_text_file ), intent(inout) :: self procedure, public :: save private subroutine save (self, julianday, secondsofday, microseconds) Arguments Type Intent Optional Attributes Name class( type_text_file ), intent(inout) :: self integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds procedure, public :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name class( type_text_file ), intent(inout) :: self","tags":"","loc":"type/type_text_file.html"},{"title":"type_time_average_operator – Fortran Program ","text":"type, public, extends( type_base_operator ) :: type_time_average_operator Inherits type~~type_time_average_operator~~InheritsGraph type~type_time_average_operator type_time_average_operator type~type_base_operator type_base_operator type~type_time_average_operator->type~type_base_operator type~type_base_operator->type~type_base_operator previous Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables previous method Type-Bound Procedures configure apply_all apply Components Type Visibility Attributes Name Initial class( type_base_operator ), public, pointer :: previous => null() integer, public :: method = time_method_mean Type-Bound Procedures procedure, public :: configure => operator_configure private subroutine operator_configure (self, settings, field_manager) Arguments Type Intent Optional Attributes Name class( type_base_operator ), intent(inout), target :: self class(type_settings), intent(inout) :: settings type( type_field_manager ), intent(inout) :: field_manager procedure, public :: apply_all => operator_apply_all private recursive function operator_apply_all (self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_base_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer procedure, public :: apply private function apply (self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_time_average_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer","tags":"","loc":"type/type_time_average_operator.html"},{"title":"type_result – Fortran Program ","text":"type, private, extends( type_universal_operator_result ) :: type_result Inherits type~~type_result~2~~InheritsGraph type~type_result~2 type_result type~type_universal_operator_result type_universal_operator_result type~type_result~2->type~type_universal_operator_result type~type_operator_result type_operator_result type~type_universal_operator_result->type~type_operator_result type~type_base_output_field type_base_output_field type~type_operator_result->type~type_base_output_field source type~type_operator_result->type~type_base_output_field type~type_dimension_pointer type_dimension_pointer type~type_operator_result->type~type_dimension_pointer dimensions type~type_base_operator type_base_operator type~type_operator_result->type~type_base_operator operator type~type_base_output_field->type~type_base_output_field next type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_variable_settings type_output_variable_settings type~type_base_output_field->type~type_output_variable_settings settings type~type_dimension type_dimension type~type_dimension_pointer->type~type_dimension p type~type_base_operator->type~type_base_operator previous type~type_dimension->type~type_dimension next type~type_field type_field type~type_dimension->type~type_field coordinate type~type_output_field_pointer->type~type_base_output_field p type~type_output_variable_settings->type~type_base_operator final_operator type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_nd_data_pointer data type~type_field->type~type_field next type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_node type_node type~type_category_node->type~type_node type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute->type~type_attribute next var pantypetype_result2InheritsGraph = svgPanZoom('#typetype_result2InheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables settings output_name is_coordinate data coordinates next operator source result_0d result_1d result_2d result_3d dimensions method n Type-Bound Procedures fill get_field flag_as_required new_data before_save get_metadata Components Type Visibility Attributes Name Initial class( type_output_variable_settings ), public, pointer :: settings => null() character(len=string_length), public :: output_name = '' logical, public :: is_coordinate = .false. type( type_nd_data_pointer ), public :: data type( type_output_field_pointer ), public, allocatable :: coordinates (:) class( type_base_output_field ), public, pointer :: next => null() class( type_base_operator ), public, pointer :: operator => null() class( type_base_output_field ), public, pointer :: source => null() real(kind=rk), public :: result_0d real(kind=rk), public, allocatable :: result_1d (:) real(kind=rk), public, allocatable :: result_2d (:,:) real(kind=rk), public, allocatable :: result_3d (:,:,:) type( type_dimension_pointer ), public, allocatable :: dimensions (:) integer, public :: method = time_method_mean integer, public :: n = 0 Type-Bound Procedures procedure, public :: fill private subroutine fill (self, value) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self real(kind=rk), intent(in) :: value procedure, public :: get_field => universal_get_field private recursive function universal_get_field (self, field) result(output_field) Arguments Type Intent Optional Attributes Name class( type_universal_operator_result ), intent(in) :: self type( type_field ), target :: field Return Value class( type_base_output_field ),\n  pointer procedure, public :: flag_as_required private recursive subroutine flag_as_required (self, required) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self logical, intent(in) :: required procedure, public :: new_data private recursive subroutine new_data (self) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self procedure, public :: before_save private recursive subroutine before_save (self) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self procedure, public :: get_metadata private recursive subroutine get_metadata (self, long_name, units, dimensions, minimum, maximum, fill_value, standard_name, path, attributes) Arguments Type Intent Optional Attributes Name class( type_result ), intent(in) :: self character(len=:), intent(out), optional allocatable :: long_name character(len=:), intent(out), optional allocatable :: units type( type_dimension_pointer ), intent(out), optional allocatable :: dimensions (:) real(kind=rk), intent(out), optional :: minimum real(kind=rk), intent(out), optional :: maximum real(kind=rk), intent(out), optional :: fill_value character(len=:), intent(out), optional allocatable :: standard_name character(len=:), intent(out), optional allocatable :: path type( type_attributes ), intent(out), optional :: attributes","tags":"","loc":"type/type_result~2.html"},{"title":"type_interp_operator – Fortran Program ","text":"type, public, extends( type_base_operator ) :: type_interp_operator Inherits type~~type_interp_operator~~InheritsGraph type~type_interp_operator type_interp_operator type~type_dimension type_dimension type~type_interp_operator->type~type_dimension target_dimension type~type_field type_field type~type_interp_operator->type~type_field source_field, offset_field type~type_base_operator type_base_operator type~type_interp_operator->type~type_base_operator type~type_dimension->type~type_dimension next type~type_dimension->type~type_field coordinate type~type_field->type~type_field next type~type_nd_data_pointer type_nd_data_pointer type~type_field->type~type_nd_data_pointer data type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_base_operator->type~type_base_operator previous type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_node type_node type~type_category_node->type~type_node type~type_dimension_pointer->type~type_dimension p type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute->type~type_attribute next var pantypetype_interp_operatorInheritsGraph = svgPanZoom('#typetype_interp_operatorInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_interp_operator~~InheritedByGraph type~type_interp_operator type_interp_operator type~type_coordinate_list_populator type_coordinate_list_populator type~type_coordinate_list_populator->type~type_interp_operator operator Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables previous dimension target_dimension_name target_long_name target_standard_name target_coordinates source_field offset_field out_of_bounds_treatment offset_scale target_dimension Type-Bound Procedures apply_all configure apply Components Type Visibility Attributes Name Initial class( type_base_operator ), public, pointer :: previous => null() character(len=string_length), public :: dimension character(len=string_length), public :: target_dimension_name character(len=string_length), public :: target_long_name character(len=string_length), public :: target_standard_name real(kind=rk), public, allocatable :: target_coordinates (:) type( type_field ), public, pointer :: source_field => null() type( type_field ), public, pointer :: offset_field => null() integer, public :: out_of_bounds_treatment = 1 real(kind=rk), public :: offset_scale = 1._rk type( type_dimension ), public, pointer :: target_dimension => null() Type-Bound Procedures procedure, public :: apply_all => operator_apply_all private recursive function operator_apply_all (self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_base_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer procedure, public :: configure private subroutine configure (self, settings, field_manager) Arguments Type Intent Optional Attributes Name class( type_interp_operator ), intent(inout), target :: self class(type_settings), intent(inout) :: settings type( type_field_manager ), intent(inout) :: field_manager procedure, public :: apply private function apply (self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_interp_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer","tags":"","loc":"type/type_interp_operator.html"},{"title":"type_result – Fortran Program ","text":"type, private, extends( type_operator_result ) :: type_result Inherits type~~type_result~~InheritsGraph type~type_result type_result type~type_base_output_field type_base_output_field type~type_result->type~type_base_output_field source_coordinate, offset type~type_operator_result type_operator_result type~type_result->type~type_operator_result type~type_base_output_field->type~type_base_output_field next type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_variable_settings type_output_variable_settings type~type_base_output_field->type~type_output_variable_settings settings type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_operator_result->type~type_base_output_field source type~type_operator_result->type~type_base_output_field type~type_base_operator type_base_operator type~type_operator_result->type~type_base_operator operator type~type_dimension_pointer type_dimension_pointer type~type_operator_result->type~type_dimension_pointer dimensions type~type_output_field_pointer->type~type_base_output_field p type~type_output_variable_settings->type~type_base_operator final_operator type~type_base_operator->type~type_base_operator previous type~type_dimension type_dimension type~type_dimension_pointer->type~type_dimension p type~type_dimension->type~type_dimension next type~type_field type_field type~type_dimension->type~type_field coordinate type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_nd_data_pointer data type~type_field->type~type_field next type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_node type_node type~type_category_node->type~type_node type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute->type~type_attribute next var pantypetype_resultInheritsGraph = svgPanZoom('#typetype_resultInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables settings output_name is_coordinate data coordinates next operator source result_0d result_1d result_2d result_3d dimensions idim idatadim source_coordinate offset out_of_bounds_treatment out_of_bounds_value target_coordinates offset_scale Type-Bound Procedures new_data get_metadata fill flag_as_required before_save get_field Components Type Visibility Attributes Name Initial class( type_output_variable_settings ), public, pointer :: settings => null() character(len=string_length), public :: output_name = '' logical, public :: is_coordinate = .false. type( type_nd_data_pointer ), public :: data type( type_output_field_pointer ), public, allocatable :: coordinates (:) class( type_base_output_field ), public, pointer :: next => null() class( type_base_operator ), public, pointer :: operator => null() class( type_base_output_field ), public, pointer :: source => null() real(kind=rk), public :: result_0d real(kind=rk), public, allocatable :: result_1d (:) real(kind=rk), public, allocatable :: result_2d (:,:) real(kind=rk), public, allocatable :: result_3d (:,:,:) type( type_dimension_pointer ), public, allocatable :: dimensions (:) integer, public :: idim = -1 integer, public :: idatadim = -1 class( type_base_output_field ), public, pointer :: source_coordinate => null() class( type_base_output_field ), public, pointer :: offset => null() integer, public :: out_of_bounds_treatment = 1 real(kind=rk), public :: out_of_bounds_value real(kind=rk), public, allocatable :: target_coordinates (:) real(kind=rk), public :: offset_scale = 1._rk Type-Bound Procedures procedure, public :: new_data private recursive subroutine new_data (self) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self procedure, public :: get_metadata private recursive subroutine get_metadata (self, long_name, units, dimensions, minimum, maximum, fill_value, standard_name, path, attributes) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(in) :: self character(len=:), intent(out), optional allocatable :: long_name character(len=:), intent(out), optional allocatable :: units type( type_dimension_pointer ), intent(out), optional allocatable :: dimensions (:) real(kind=rk), intent(out), optional :: minimum real(kind=rk), intent(out), optional :: maximum real(kind=rk), intent(out), optional :: fill_value character(len=:), intent(out), optional allocatable :: standard_name character(len=:), intent(out), optional allocatable :: path type( type_attributes ), intent(out), optional :: attributes procedure, public :: fill private subroutine fill (self, value) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self real(kind=rk), intent(in) :: value procedure, public :: flag_as_required private recursive subroutine flag_as_required (self, required) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self logical, intent(in) :: required procedure, public :: before_save private recursive subroutine before_save (self) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self procedure, public :: get_field private recursive function get_field (self, field) result(output_field) Arguments Type Intent Optional Attributes Name class( type_result ), intent(in) :: self type( type_field ), target :: field Return Value class( type_base_output_field ),\n  pointer","tags":"","loc":"type/type_result.html"},{"title":"type_coordinate_list_populator – Fortran Program ","text":"type, private, extends(type_list_populator) :: type_coordinate_list_populator Inherits type~~type_coordinate_list_populator~~InheritsGraph type~type_coordinate_list_populator type_coordinate_list_populator type_list_populator type_list_populator type~type_coordinate_list_populator->type_list_populator type~type_interp_operator type_interp_operator type~type_coordinate_list_populator->type~type_interp_operator operator type~type_dimension type_dimension type~type_interp_operator->type~type_dimension target_dimension type~type_field type_field type~type_interp_operator->type~type_field source_field, offset_field type~type_base_operator type_base_operator type~type_interp_operator->type~type_base_operator type~type_dimension->type~type_dimension next type~type_dimension->type~type_field coordinate type~type_field->type~type_field next type~type_nd_data_pointer type_nd_data_pointer type~type_field->type~type_nd_data_pointer data type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_dimension_pointer type_dimension_pointer type~type_field->type~type_dimension_pointer dimensions type~type_base_operator->type~type_base_operator previous type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_node type_node type~type_category_node->type~type_node type~type_dimension_pointer->type~type_dimension p type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute->type~type_attribute next var pantypetype_coordinate_list_populatorInheritsGraph = svgPanZoom('#typetype_coordinate_list_populatorInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables operator Type-Bound Procedures set_length create Components Type Visibility Attributes Name Initial class( type_interp_operator ), public, pointer :: operator => null() Type-Bound Procedures procedure, public :: set_length => coordinate_list_set_length private recursive subroutine coordinate_list_set_length (self, n) Arguments Type Intent Optional Attributes Name class( type_coordinate_list_populator ), intent(inout) :: self integer, intent(in) :: n procedure, public :: create => coordinate_list_create_element private recursive subroutine coordinate_list_create_element (self, index, item) Arguments Type Intent Optional Attributes Name class( type_coordinate_list_populator ), intent(inout) :: self integer, intent(in) :: index type(type_list_item), intent(inout) :: item","tags":"","loc":"type/type_coordinate_list_populator.html"},{"title":"type_single_dimension_slice – Fortran Program ","text":"type, private :: type_single_dimension_slice Inherited by type~~type_single_dimension_slice~~InheritedByGraph type~type_single_dimension_slice type_single_dimension_slice type~type_single_dimension_slice->type~type_single_dimension_slice next type~type_slice_operator type_slice_operator type~type_slice_operator->type~type_single_dimension_slice first Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables dimension global_start global_stop stride next Components Type Visibility Attributes Name Initial character(len=string_length), public :: dimension integer, public :: global_start = 1 integer, public :: global_stop = -1 integer, public :: stride = 1 type( type_single_dimension_slice ), public, pointer :: next => null()","tags":"","loc":"type/type_single_dimension_slice.html"},{"title":"type_slice_operator – Fortran Program ","text":"type, public, extends( type_base_operator ) :: type_slice_operator Inherits type~~type_slice_operator~~InheritsGraph type~type_slice_operator type_slice_operator type~type_single_dimension_slice type_single_dimension_slice type~type_slice_operator->type~type_single_dimension_slice first type~type_base_operator type_base_operator type~type_slice_operator->type~type_base_operator type~type_single_dimension_slice->type~type_single_dimension_slice next type~type_base_operator->type~type_base_operator previous Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables previous first Type-Bound Procedures configure apply_all apply add Components Type Visibility Attributes Name Initial class( type_base_operator ), public, pointer :: previous => null() type( type_single_dimension_slice ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: configure => operator_configure private subroutine operator_configure (self, settings, field_manager) Arguments Type Intent Optional Attributes Name class( type_base_operator ), intent(inout), target :: self class(type_settings), intent(inout) :: settings type( type_field_manager ), intent(inout) :: field_manager procedure, public :: apply_all => operator_apply_all private recursive function operator_apply_all (self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_base_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer procedure, public :: apply private function apply (self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_slice_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer procedure, public :: add private subroutine add (self, dimension, start, stop, stride) Arguments Type Intent Optional Attributes Name class( type_slice_operator ), intent(inout) :: self character(len=*), intent(in) :: dimension integer, intent(in) :: start integer, intent(in) :: stop integer, intent(in) :: stride","tags":"","loc":"type/type_slice_operator.html"},{"title":"type_operator_result – Fortran Program ","text":"type, public, extends( type_base_output_field ) :: type_operator_result Inherits type~~type_operator_result~~InheritsGraph type~type_operator_result type_operator_result type~type_base_output_field type_base_output_field type~type_operator_result->type~type_base_output_field source type~type_operator_result->type~type_base_output_field type~type_dimension_pointer type_dimension_pointer type~type_operator_result->type~type_dimension_pointer dimensions type~type_base_operator type_base_operator type~type_operator_result->type~type_base_operator operator type~type_base_output_field->type~type_base_output_field next type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_variable_settings type_output_variable_settings type~type_base_output_field->type~type_output_variable_settings settings type~type_dimension type_dimension type~type_dimension_pointer->type~type_dimension p type~type_base_operator->type~type_base_operator previous type~type_dimension->type~type_dimension next type~type_field type_field type~type_dimension->type~type_field coordinate type~type_output_field_pointer->type~type_base_output_field p type~type_output_variable_settings->type~type_base_operator final_operator type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_nd_data_pointer data type~type_field->type~type_field next type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_node type_node type~type_category_node->type~type_node type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute->type~type_attribute next var pantypetype_operator_resultInheritsGraph = svgPanZoom('#typetype_operator_resultInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_operator_result~~InheritedByGraph type~type_operator_result type_operator_result type~type_universal_operator_result type_universal_operator_result type~type_universal_operator_result->type~type_operator_result type~type_result type_result type~type_result->type~type_operator_result type~type_result~2 type_result type~type_result~2->type~type_universal_operator_result Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables settings output_name is_coordinate data coordinates next operator source result_0d result_1d result_2d result_3d dimensions Type-Bound Procedures new_data before_save get_metadata flag_as_required fill get_field Components Type Visibility Attributes Name Initial class( type_output_variable_settings ), public, pointer :: settings => null() character(len=string_length), public :: output_name = '' logical, public :: is_coordinate = .false. type( type_nd_data_pointer ), public :: data type( type_output_field_pointer ), public, allocatable :: coordinates (:) class( type_base_output_field ), public, pointer :: next => null() class( type_base_operator ), public, pointer :: operator => null() class( type_base_output_field ), public, pointer :: source => null() real(kind=rk), public :: result_0d real(kind=rk), public, allocatable :: result_1d (:) real(kind=rk), public, allocatable :: result_2d (:,:) real(kind=rk), public, allocatable :: result_3d (:,:,:) type( type_dimension_pointer ), public, allocatable :: dimensions (:) Type-Bound Procedures procedure, public :: new_data private recursive subroutine new_data (self) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self procedure, public :: before_save private recursive subroutine before_save (self) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self procedure, public :: get_metadata private recursive subroutine get_metadata (self, long_name, units, dimensions, minimum, maximum, fill_value, standard_name, path, attributes) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(in) :: self character(len=:), intent(out), optional allocatable :: long_name character(len=:), intent(out), optional allocatable :: units type( type_dimension_pointer ), intent(out), optional allocatable :: dimensions (:) real(kind=rk), intent(out), optional :: minimum real(kind=rk), intent(out), optional :: maximum real(kind=rk), intent(out), optional :: fill_value character(len=:), intent(out), optional allocatable :: standard_name character(len=:), intent(out), optional allocatable :: path type( type_attributes ), intent(out), optional :: attributes procedure, public :: flag_as_required private recursive subroutine flag_as_required (self, required) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self logical, intent(in) :: required procedure, public :: fill private subroutine fill (self, value) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self real(kind=rk), intent(in) :: value procedure, public :: get_field private recursive function get_field (self, field) result(output_field) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(in) :: self type( type_field ), target :: field Return Value class( type_base_output_field ),\n  pointer","tags":"","loc":"type/type_operator_result.html"},{"title":"type_universal_operator_result – Fortran Program ","text":"type, public, extends( type_operator_result ) :: type_universal_operator_result Inherits type~~type_universal_operator_result~~InheritsGraph type~type_universal_operator_result type_universal_operator_result type~type_operator_result type_operator_result type~type_universal_operator_result->type~type_operator_result type~type_base_output_field type_base_output_field type~type_operator_result->type~type_base_output_field source type~type_operator_result->type~type_base_output_field type~type_dimension_pointer type_dimension_pointer type~type_operator_result->type~type_dimension_pointer dimensions type~type_base_operator type_base_operator type~type_operator_result->type~type_base_operator operator type~type_base_output_field->type~type_base_output_field next type~type_nd_data_pointer type_nd_data_pointer type~type_base_output_field->type~type_nd_data_pointer data type~type_output_field_pointer type_output_field_pointer type~type_base_output_field->type~type_output_field_pointer coordinates type~type_output_variable_settings type_output_variable_settings type~type_base_output_field->type~type_output_variable_settings settings type~type_dimension type_dimension type~type_dimension_pointer->type~type_dimension p type~type_base_operator->type~type_base_operator previous type~type_dimension->type~type_dimension next type~type_field type_field type~type_dimension->type~type_field coordinate type~type_output_field_pointer->type~type_base_output_field p type~type_output_variable_settings->type~type_base_operator final_operator type~type_field->type~type_dimension_pointer dimensions type~type_field->type~type_nd_data_pointer data type~type_field->type~type_field next type~type_category_node type_category_node type~type_field->type~type_category_node category type~type_attributes type_attributes type~type_field->type~type_attributes attributes type~type_node type_node type~type_category_node->type~type_node type~type_attribute type_attribute type~type_attributes->type~type_attribute first type~type_node->type~type_node parent, first_child, next_sibling type~type_attribute->type~type_attribute next var pantypetype_universal_operator_resultInheritsGraph = svgPanZoom('#typetype_universal_operator_resultInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_universal_operator_result~~InheritedByGraph type~type_universal_operator_result type_universal_operator_result type~type_result~2 type_result type~type_result~2->type~type_universal_operator_result Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables settings output_name is_coordinate data coordinates next operator source result_0d result_1d result_2d result_3d dimensions Type-Bound Procedures new_data before_save get_metadata flag_as_required fill get_field Components Type Visibility Attributes Name Initial class( type_output_variable_settings ), public, pointer :: settings => null() character(len=string_length), public :: output_name = '' logical, public :: is_coordinate = .false. type( type_nd_data_pointer ), public :: data type( type_output_field_pointer ), public, allocatable :: coordinates (:) class( type_base_output_field ), public, pointer :: next => null() class( type_base_operator ), public, pointer :: operator => null() class( type_base_output_field ), public, pointer :: source => null() real(kind=rk), public :: result_0d real(kind=rk), public, allocatable :: result_1d (:) real(kind=rk), public, allocatable :: result_2d (:,:) real(kind=rk), public, allocatable :: result_3d (:,:,:) type( type_dimension_pointer ), public, allocatable :: dimensions (:) Type-Bound Procedures procedure, public :: new_data private recursive subroutine new_data (self) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self procedure, public :: before_save private recursive subroutine before_save (self) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self procedure, public :: get_metadata private recursive subroutine get_metadata (self, long_name, units, dimensions, minimum, maximum, fill_value, standard_name, path, attributes) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(in) :: self character(len=:), intent(out), optional allocatable :: long_name character(len=:), intent(out), optional allocatable :: units type( type_dimension_pointer ), intent(out), optional allocatable :: dimensions (:) real(kind=rk), intent(out), optional :: minimum real(kind=rk), intent(out), optional :: maximum real(kind=rk), intent(out), optional :: fill_value character(len=:), intent(out), optional allocatable :: standard_name character(len=:), intent(out), optional allocatable :: path type( type_attributes ), intent(out), optional :: attributes procedure, public :: flag_as_required private recursive subroutine flag_as_required (self, required) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self logical, intent(in) :: required procedure, public :: fill private subroutine fill (self, value) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self real(kind=rk), intent(in) :: value procedure, public :: get_field => universal_get_field private recursive function universal_get_field (self, field) result(output_field) Arguments Type Intent Optional Attributes Name class( type_universal_operator_result ), intent(in) :: self type( type_field ), target :: field Return Value class( type_base_output_field ),\n  pointer","tags":"","loc":"type/type_universal_operator_result.html"},{"title":"host_julian_day – Fortran Program","text":"abstract interface private subroutine host_julian_day(self, yyyy, mm, dd, julian) Arguments Type Intent Optional Attributes Name class( type_host ), intent(in) :: self integer, intent(in) :: yyyy integer, intent(in) :: mm integer, intent(in) :: dd integer, intent(out) :: julian","tags":"","loc":"interface/host_julian_day.html"},{"title":"host_calendar_date – Fortran Program","text":"abstract interface private subroutine host_calendar_date(self, julian, yyyy, mm, dd) Arguments Type Intent Optional Attributes Name class( type_host ), intent(in) :: self integer, intent(in) :: julian integer, intent(out) :: yyyy integer, intent(out) :: mm integer, intent(out) :: dd","tags":"","loc":"interface/host_calendar_date.html"},{"title":"host_write_header – Fortran Program","text":"abstract interface private subroutine host_write_header(self) Arguments Type Intent Optional Attributes Name class( type_single_text_file ), intent(in) :: self","tags":"","loc":"interface/host_write_header.html"},{"title":"host_write_data – Fortran Program","text":"abstract interface private subroutine host_write_data(self, timestr) Arguments Type Intent Optional Attributes Name class( type_single_text_file ), intent(in) :: self character(len=*), intent(in) :: timestr","tags":"","loc":"interface/host_write_data.html"},{"title":"next_free_dimension_id – Fortran Program","text":"private function next_free_dimension_id(self) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(in) :: self Return Value integer Called by proc~~next_free_dimension_id~~CalledByGraph proc~next_free_dimension_id next_free_dimension_id proc~register_dimension register_dimension proc~register_dimension->proc~next_free_dimension_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/next_free_dimension_id.html"},{"title":"find_dimension – Fortran Program","text":"private function find_dimension(self, dimid) result(dim) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(in) :: self integer, intent(in) :: dimid Return Value type( type_dimension ),\n  pointer Called by proc~~find_dimension~~CalledByGraph proc~find_dimension find_dimension proc~initialize initialize proc~initialize->proc~find_dimension proc~register register proc~register->proc~find_dimension Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_dimension.html"},{"title":"select_for_output – Fortran Program","text":"private function select_for_output(self, name) result(field) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name Return Value type( type_field ),\n  pointer Contents None","tags":"","loc":"proc/select_for_output.html"},{"title":"select_category_for_output – Fortran Program","text":"private function select_category_for_output(self, name, output_level) result(category) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(in) :: output_level Return Value class( type_category_node ),\n  pointer Contents None","tags":"","loc":"proc/select_category_for_output.html"},{"title":"has_fields – Fortran Program","text":"private recursive function has_fields(self) Arguments Type Intent Optional Attributes Name class( type_category_node ), intent(inout) :: self Return Value logical Contents None","tags":"","loc":"proc/has_fields.html"},{"title":"find – Fortran Program","text":"private function find(self, name, create) result(field) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name logical, intent(in), optional :: create Return Value type( type_field ),\n  pointer Calls proc~~find~~CallsGraph proc~find find proc~hash hash proc~find->proc~hash Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find.html"},{"title":"has_dimension – Fortran Program","text":"public function has_dimension(dimensions, id) Arguments Type Intent Optional Attributes Name type( type_dimension_pointer ), intent(in) :: dimensions (:) integer, intent(in) :: id Return Value logical Called by proc~~has_dimension~~CalledByGraph proc~has_dimension has_dimension proc~field_has_dimension field_has_dimension proc~field_has_dimension->proc~has_dimension proc~initialize~4 initialize proc~initialize~4->proc~has_dimension proc~single_text_file_with_1d_variable_write_header single_text_file_with_1d_variable_write_header proc~single_text_file_with_1d_variable_write_header->proc~has_dimension Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/has_dimension.html"},{"title":"field_has_dimension – Fortran Program","text":"private function field_has_dimension(self, id) Arguments Type Intent Optional Attributes Name class( type_field ), intent(in) :: self integer, intent(in) :: id Return Value logical Calls proc~~field_has_dimension~~CallsGraph proc~field_has_dimension field_has_dimension proc~has_dimension has_dimension proc~field_has_dimension->proc~has_dimension Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/field_has_dimension.html"},{"title":"find_category – Fortran Program","text":"private function find_category(self, name, create) result(category) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout), target :: self character(len=*), intent(in) :: name logical, intent(in), optional :: create Return Value class( type_category_node ),\n  pointer Calls proc~~find_category~~CallsGraph proc~find_category find_category proc~add_to_category add_to_category proc~find_category->proc~add_to_category Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_category.html"},{"title":"data_is_empty – Fortran Program","text":"private function data_is_empty(self) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(in) :: self Return Value logical Contents None","tags":"","loc":"proc/data_is_empty.html"},{"title":"get_state – Fortran Program","text":"private function get_state(self) result(field_set) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self Return Value type( type_field_set ) Contents None","tags":"","loc":"proc/get_state.html"},{"title":"category_get_path – Fortran Program","text":"private function category_get_path(self) result(path) Arguments Type Intent Optional Attributes Name class( type_category_node ), intent(in), target :: self Return Value character(len=256) Contents None","tags":"","loc":"proc/category_get_path.html"},{"title":"hash – Fortran Program","text":"private function hash(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer Called by proc~~hash~~CalledByGraph proc~hash hash proc~find find proc~find->proc~hash Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/hash.html"},{"title":"register_dimension – Fortran Program","text":"private subroutine register_dimension(self, name, length, global_length, offset, id, newid) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(in), optional :: length integer, intent(in), optional :: global_length integer, intent(in), optional :: offset integer, intent(in), optional :: id integer, intent(out), optional :: newid Calls proc~~register_dimension~~CallsGraph proc~register_dimension register_dimension proc~next_free_dimension_id next_free_dimension_id proc~register_dimension->proc~next_free_dimension_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/register_dimension.html"},{"title":"initialize – Fortran Program","text":"private subroutine initialize(self, prepend_by_default, append_by_default) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self integer, intent(in), optional :: prepend_by_default (:) integer, intent(in), optional :: append_by_default (:) Calls proc~~initialize~~CallsGraph proc~initialize initialize proc~find_dimension find_dimension proc~initialize->proc~find_dimension Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize.html"},{"title":"list – Fortran Program","text":"private subroutine list(self) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(in) :: self Calls proc~~list~~CallsGraph proc~list list proc~list_node list_node proc~list->proc~list_node proc~list_node->proc~list_node Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/list.html"},{"title":"list_node – Fortran Program","text":"private recursive subroutine list_node(category, depth) Arguments Type Intent Optional Attributes Name type( type_category_node ), intent(in) :: category integer, intent(in) :: depth Called by proc~~list_node~~CalledByGraph proc~list_node list_node proc~list_node->proc~list_node proc~list list proc~list->proc~list_node Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/list_node.html"},{"title":"finalize – Fortran Program","text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self Contents None","tags":"","loc":"proc/finalize.html"},{"title":"reset_used – Fortran Program","text":"private subroutine reset_used(self) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self Contents None","tags":"","loc":"proc/reset_used.html"},{"title":"field_set_add – Fortran Program","text":"private subroutine field_set_add(self, field) Arguments Type Intent Optional Attributes Name class( type_field_set ), intent(inout) :: self type( type_field ), target :: field Contents None","tags":"","loc":"proc/field_set_add.html"},{"title":"field_set_finalize – Fortran Program","text":"private subroutine field_set_finalize(self) Arguments Type Intent Optional Attributes Name class( type_field_set ), intent(inout) :: self Contents None","tags":"","loc":"proc/field_set_finalize.html"},{"title":"get_all_fields – Fortran Program","text":"private recursive subroutine get_all_fields(self, set, output_level) Arguments Type Intent Optional Attributes Name class( type_category_node ), intent(inout) :: self type( type_field_set ), intent(inout) :: set integer, intent(in) :: output_level Contents None","tags":"","loc":"proc/get_all_fields.html"},{"title":"register – Fortran Program","text":"private subroutine register(self, name, units, long_name, standard_name, fill_value, minimum, maximum, dimensions, data0d, data1d, data2d, data3d, no_default_dimensions, category, output_level, coordinate_dimension, part_of_state, used, used_now, field) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: units character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: standard_name real(kind=rk), intent(in), optional :: fill_value real(kind=rk), intent(in), optional :: minimum real(kind=rk), intent(in), optional :: maximum integer, intent(in), optional :: dimensions (:) real(kind=rk), optional target :: data0d real(kind=rk), optional target :: data1d (:) real(kind=rk), optional target :: data2d (:,:) real(kind=rk), optional target :: data3d (:,:,:) logical, intent(in), optional :: no_default_dimensions character(len=*), intent(in), optional :: category integer, intent(in), optional :: output_level integer, intent(in), optional :: coordinate_dimension logical, intent(in), optional :: part_of_state logical, intent(out), optional :: used logical, optional target :: used_now type( type_field ), optional pointer :: field Calls proc~~register~~CallsGraph proc~register register proc~find_dimension find_dimension proc~register->proc~find_dimension proc~add_field_to_tree add_field_to_tree proc~register->proc~add_field_to_tree proc~add_to_category add_to_category proc~add_field_to_tree->proc~add_to_category Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/register.html"},{"title":"attributes_delete – Fortran Program","text":"private subroutine attributes_delete(self, name) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name Contents None","tags":"","loc":"proc/attributes_delete.html"},{"title":"attributes_set_object – Fortran Program","text":"private subroutine attributes_set_object(self, name, attribute) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name class( type_attribute ), intent(inout), target :: attribute Contents None","tags":"","loc":"proc/attributes_set_object.html"},{"title":"attributes_set_real – Fortran Program","text":"private subroutine attributes_set_real(self, name, value) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), intent(in) :: value Contents None","tags":"","loc":"proc/attributes_set_real.html"},{"title":"attributes_set_integer – Fortran Program","text":"private subroutine attributes_set_integer(self, name, value) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(in) :: value Contents None","tags":"","loc":"proc/attributes_set_integer.html"},{"title":"attributes_set_string – Fortran Program","text":"private subroutine attributes_set_string(self, name, value) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: value Contents None","tags":"","loc":"proc/attributes_set_string.html"},{"title":"attributes_update – Fortran Program","text":"private subroutine attributes_update(self, other) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self class( type_attributes ), intent(in) :: other Contents None","tags":"","loc":"proc/attributes_update.html"},{"title":"field_finalize – Fortran Program","text":"private subroutine field_finalize(self) Arguments Type Intent Optional Attributes Name class( type_field ), intent(inout) :: self Contents None","tags":"","loc":"proc/field_finalize.html"},{"title":"add_field_to_tree – Fortran Program","text":"private subroutine add_field_to_tree(self, field, category) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout), target :: self type( type_field ), target :: field character(len=*), intent(in), optional :: category Calls proc~~add_field_to_tree~~CallsGraph proc~add_field_to_tree add_field_to_tree proc~add_to_category add_to_category proc~add_field_to_tree->proc~add_to_category Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~add_field_to_tree~~CalledByGraph proc~add_field_to_tree add_field_to_tree proc~register register proc~register->proc~add_field_to_tree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/add_field_to_tree.html"},{"title":"add_to_category – Fortran Program","text":"private subroutine add_to_category(parent, node) Arguments Type Intent Optional Attributes Name type( type_category_node ), intent(inout), target :: parent class( type_node ), target :: node Called by proc~~add_to_category~~CalledByGraph proc~add_to_category add_to_category proc~find_category find_category proc~find_category->proc~add_to_category proc~add_field_to_tree add_field_to_tree proc~add_field_to_tree->proc~add_to_category proc~register register proc~register->proc~add_field_to_tree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/add_to_category.html"},{"title":"send_data_by_name_0d – Fortran Program","text":"private subroutine send_data_by_name_0d(self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data Contents None","tags":"","loc":"proc/send_data_by_name_0d.html"},{"title":"send_data_by_name_1d – Fortran Program","text":"private subroutine send_data_by_name_1d(self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data (:) Contents None","tags":"","loc":"proc/send_data_by_name_1d.html"},{"title":"send_data_by_name_2d – Fortran Program","text":"private subroutine send_data_by_name_2d(self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data (:,:) Contents None","tags":"","loc":"proc/send_data_by_name_2d.html"},{"title":"send_data_by_name_3d – Fortran Program","text":"private subroutine send_data_by_name_3d(self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data (:,:,:) Contents None","tags":"","loc":"proc/send_data_by_name_3d.html"},{"title":"check_sent_data – Fortran Program","text":"private subroutine check_sent_data(field) Arguments Type Intent Optional Attributes Name type( type_field ), intent(inout) :: field Called by proc~~check_sent_data~~CalledByGraph proc~check_sent_data check_sent_data proc~send_data_0d send_data_0d proc~send_data_0d->proc~check_sent_data proc~send_data_2d send_data_2d proc~send_data_2d->proc~check_sent_data proc~send_data_3d send_data_3d proc~send_data_3d->proc~check_sent_data proc~send_data_1d send_data_1d proc~send_data_1d->proc~check_sent_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check_sent_data.html"},{"title":"send_data_0d – Fortran Program","text":"private subroutine send_data_0d(self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data Calls proc~~send_data_0d~~CallsGraph proc~send_data_0d send_data_0d proc~check_sent_data check_sent_data proc~send_data_0d->proc~check_sent_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/send_data_0d.html"},{"title":"send_data_1d – Fortran Program","text":"private subroutine send_data_1d(self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data (:) Calls proc~~send_data_1d~~CallsGraph proc~send_data_1d send_data_1d proc~check_sent_data check_sent_data proc~send_data_1d->proc~check_sent_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/send_data_1d.html"},{"title":"send_data_2d – Fortran Program","text":"private subroutine send_data_2d(self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data (:,:) Calls proc~~send_data_2d~~CallsGraph proc~send_data_2d send_data_2d proc~check_sent_data check_sent_data proc~send_data_2d->proc~check_sent_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/send_data_2d.html"},{"title":"send_data_3d – Fortran Program","text":"private subroutine send_data_3d(self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data (:,:,:) Calls proc~~send_data_3d~~CallsGraph proc~send_data_3d send_data_3d proc~check_sent_data check_sent_data proc~send_data_3d->proc~check_sent_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/send_data_3d.html"},{"title":"data_set_0d – Fortran Program","text":"private subroutine data_set_0d(self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data Contents None","tags":"","loc":"proc/data_set_0d.html"},{"title":"data_set_1d – Fortran Program","text":"private subroutine data_set_1d(self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data (:) Contents None","tags":"","loc":"proc/data_set_1d.html"},{"title":"data_set_2d – Fortran Program","text":"private subroutine data_set_2d(self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data (:,:) Contents None","tags":"","loc":"proc/data_set_2d.html"},{"title":"data_set_3d – Fortran Program","text":"private subroutine data_set_3d(self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data (:,:,:) Contents None","tags":"","loc":"proc/data_set_3d.html"},{"title":"data_get_extents – Fortran Program","text":"private subroutine data_get_extents(self, extents) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(in) :: self integer, intent(out), allocatable :: extents (:) Contents None","tags":"","loc":"proc/data_get_extents.html"},{"title":"fatal_error – Fortran Program","text":"private subroutine fatal_error(location, error) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: location character(len=*), intent(in) :: error Contents None","tags":"","loc":"proc/fatal_error.html"},{"title":"node_finalize – Fortran Program","text":"private recursive subroutine node_finalize(self) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self Contents None","tags":"","loc":"proc/node_finalize.html"},{"title":"field_set_real_attribute – Fortran Program","text":"private subroutine field_set_real_attribute(self, name, value) Arguments Type Intent Optional Attributes Name class( type_field ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), intent(in) :: value Contents None","tags":"","loc":"proc/field_set_real_attribute.html"},{"title":"base_field_get_field – Fortran Program","text":"private recursive function base_field_get_field(self, field) result(output_field) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(in) :: self type( type_field ), target :: field Return Value class( type_base_output_field ),\n  pointer Calls proc~~base_field_get_field~~CallsGraph proc~base_field_get_field base_field_get_field proc~wrap_field wrap_field proc~base_field_get_field->proc~wrap_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/base_field_get_field.html"},{"title":"wrap_field – Fortran Program","text":"public function wrap_field(field, allow_unregistered) result(output_field) Arguments Type Intent Optional Attributes Name type( type_field ), target :: field logical, intent(in) :: allow_unregistered Return Value class( type_output_field ),\n  pointer Called by proc~~wrap_field~~CalledByGraph proc~wrap_field wrap_field proc~base_field_get_field base_field_get_field proc~base_field_get_field->proc~wrap_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wrap_field.html"},{"title":"create_settings – Fortran Program","text":"private function create_settings(self) result(settings) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self Return Value class( type_output_variable_settings ),\n  pointer Contents None","tags":"","loc":"proc/create_settings.html"},{"title":"is_dimension_used – Fortran Program","text":"private function is_dimension_used(self, dim) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self type( type_dimension ), target :: dim Return Value logical Contents None","tags":"","loc":"proc/is_dimension_used.html"},{"title":"operator_apply – Fortran Program","text":"private function operator_apply(self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_base_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer Contents None","tags":"","loc":"proc/operator_apply.html"},{"title":"operator_apply_all – Fortran Program","text":"private recursive function operator_apply_all(self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_base_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer Contents None","tags":"","loc":"proc/operator_apply_all.html"},{"title":"base_field_flag_as_required – Fortran Program","text":"private recursive subroutine base_field_flag_as_required(self, required) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(inout) :: self logical, intent(in) :: required Contents None","tags":"","loc":"proc/base_field_flag_as_required.html"},{"title":"base_field_get_metadata – Fortran Program","text":"private recursive subroutine base_field_get_metadata(self, long_name, units, dimensions, minimum, maximum, fill_value, standard_name, path, attributes) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(in) :: self character(len=:), intent(out), optional allocatable :: long_name character(len=:), intent(out), optional allocatable :: units type( type_dimension_pointer ), intent(out), optional allocatable :: dimensions (:) real(kind=rk), intent(out), optional :: minimum real(kind=rk), intent(out), optional :: maximum real(kind=rk), intent(out), optional :: fill_value character(len=:), intent(out), optional allocatable :: standard_name character(len=:), intent(out), optional allocatable :: path type( type_attributes ), intent(out), optional :: attributes Contents None","tags":"","loc":"proc/base_field_get_metadata.html"},{"title":"base_field_new_data – Fortran Program","text":"private recursive subroutine base_field_new_data(self) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(inout) :: self Contents None","tags":"","loc":"proc/base_field_new_data.html"},{"title":"base_field_before_save – Fortran Program","text":"private recursive subroutine base_field_before_save(self) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(inout) :: self Contents None","tags":"","loc":"proc/base_field_before_save.html"},{"title":"field_flag_as_required – Fortran Program","text":"private recursive subroutine field_flag_as_required(self, required) Arguments Type Intent Optional Attributes Name class( type_output_field ), intent(inout) :: self logical, intent(in) :: required Contents None","tags":"","loc":"proc/field_flag_as_required.html"},{"title":"field_get_metadata – Fortran Program","text":"private recursive subroutine field_get_metadata(self, long_name, units, dimensions, minimum, maximum, fill_value, standard_name, path, attributes) Arguments Type Intent Optional Attributes Name class( type_output_field ), intent(in) :: self character(len=:), intent(out), optional allocatable :: long_name character(len=:), intent(out), optional allocatable :: units type( type_dimension_pointer ), intent(out), optional allocatable :: dimensions (:) real(kind=rk), intent(out), optional :: minimum real(kind=rk), intent(out), optional :: maximum real(kind=rk), intent(out), optional :: fill_value character(len=:), intent(out), optional allocatable :: standard_name character(len=:), intent(out), optional allocatable :: path type( type_attributes ), intent(out), optional :: attributes Contents None","tags":"","loc":"proc/field_get_metadata.html"},{"title":"configure – Fortran Program","text":"private subroutine configure(self, settings) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self class(type_settings), intent(inout) :: settings Contents None","tags":"","loc":"proc/configure.html"},{"title":"initialize – Fortran Program","text":"private subroutine initialize(self) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self Contents None","tags":"","loc":"proc/initialize~2.html"},{"title":"save – Fortran Program","text":"private subroutine save(self, julianday, secondsofday, microseconds) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds Contents None","tags":"","loc":"proc/save.html"},{"title":"finalize – Fortran Program","text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self Contents None","tags":"","loc":"proc/finalize~2.html"},{"title":"write_time_string – Fortran Program","text":"public subroutine write_time_string(jul, secs, timestr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: jul integer, intent(in) :: secs character(len=*), intent(out) :: timestr Called by proc~~write_time_string~~CalledByGraph proc~write_time_string write_time_string proc~save~3 save proc~save~3->proc~write_time_string proc~initialize~3 initialize proc~initialize~3->proc~write_time_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_time_string.html"},{"title":"read_time_string – Fortran Program","text":"public subroutine read_time_string(timestr, jul, secs, success) Arguments Type Intent Optional Attributes Name character(len=19) :: timestr integer, intent(out) :: jul integer, intent(out) :: secs logical, intent(out) :: success Called by proc~~read_time_string~~CalledByGraph proc~read_time_string read_time_string proc~configure~2 configure proc~configure~2->proc~read_time_string proc~process_file process_file proc~process_file->proc~read_time_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_time_string.html"},{"title":"host_fatal_error – Fortran Program","text":"private subroutine host_fatal_error(self, location, error) Arguments Type Intent Optional Attributes Name class( type_host ), intent(in) :: self character(len=*), intent(in) :: location character(len=*), intent(in) :: error Contents None","tags":"","loc":"proc/host_fatal_error.html"},{"title":"host_log_message – Fortran Program","text":"private subroutine host_log_message(self, message) Arguments Type Intent Optional Attributes Name class( type_host ), intent(in) :: self character(len=*), intent(in) :: message Contents None","tags":"","loc":"proc/host_log_message.html"},{"title":"append_item – Fortran Program","text":"private subroutine append_item(self, item) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self type( type_output_item ), target :: item Contents None","tags":"","loc":"proc/append_item.html"},{"title":"output_variable_settings_initialize – Fortran Program","text":"private subroutine output_variable_settings_initialize(self, settings, parent) Arguments Type Intent Optional Attributes Name class( type_output_variable_settings ), intent(inout) :: self class(type_settings), intent(inout) :: settings class( type_output_variable_settings ), intent(in), optional :: parent Calls proc~~output_variable_settings_initialize~~CallsGraph proc~output_variable_settings_initialize output_variable_settings_initialize type_option type_option proc~output_variable_settings_initialize->type_option Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output_variable_settings_initialize.html"},{"title":"operator_configure – Fortran Program","text":"private subroutine operator_configure(self, settings, field_manager) Arguments Type Intent Optional Attributes Name class( type_base_operator ), intent(inout), target :: self class(type_settings), intent(inout) :: settings type( type_field_manager ), intent(inout) :: field_manager Contents None","tags":"","loc":"proc/operator_configure.html"},{"title":"in_window – Fortran Program","text":"private function in_window(self, julianday, secondsofday, microseconds, n) Arguments Type Intent Optional Attributes Name class( type_file ), intent(in) :: self integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds integer, intent(in) :: n Return Value logical Called by proc~~in_window~~CalledByGraph proc~in_window in_window proc~output_manager_save2 output_manager_save2 proc~output_manager_save2->proc~in_window proc~output_manager_prepare_save output_manager_prepare_save proc~output_manager_prepare_save->proc~in_window proc~output_manager_save1 output_manager_save1 proc~output_manager_save1->proc~output_manager_save2 interface~output_manager_save output_manager_save interface~output_manager_save->proc~output_manager_save2 interface~output_manager_save->proc~output_manager_save1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/in_window.html"},{"title":"output_manager_init – Fortran Program","text":"public subroutine output_manager_init(field_manager, title, postfix, settings) Arguments Type Intent Optional Attributes Name type( type_field_manager ), target :: field_manager character(len=*), intent(in) :: title character(len=*), intent(in), optional :: postfix class(type_settings), optional pointer :: settings Calls proc~~output_manager_init~~CallsGraph proc~output_manager_init output_manager_init proc~configure_from_yaml configure_from_yaml proc~output_manager_init->proc~configure_from_yaml type_settings_create type_settings_create proc~configure_from_yaml->type_settings_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output_manager_init.html"},{"title":"output_manager_clean – Fortran Program","text":"public subroutine output_manager_clean() Arguments None Contents None","tags":"","loc":"proc/output_manager_clean.html"},{"title":"populate – Fortran Program","text":"private subroutine populate(file) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: file Called by proc~~populate~~CalledByGraph proc~populate populate proc~output_manager_start output_manager_start proc~output_manager_start->proc~populate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/populate.html"},{"title":"output_manager_start – Fortran Program","text":"public subroutine output_manager_start(julianday, secondsofday, microseconds, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds integer, intent(in) :: n Calls proc~~output_manager_start~~CallsGraph proc~output_manager_start output_manager_start proc~populate populate proc~output_manager_start->proc~populate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output_manager_start.html"},{"title":"set_next_output – Fortran Program","text":"private subroutine set_next_output(self, julianday, secondsofday, microseconds, n) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds integer, intent(in) :: n Contents None","tags":"","loc":"proc/set_next_output.html"},{"title":"output_manager_save1 – Fortran Program","text":"private subroutine output_manager_save1(julianday, secondsofday, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: n Calls proc~~output_manager_save1~~CallsGraph proc~output_manager_save1 output_manager_save1 proc~output_manager_save2 output_manager_save2 proc~output_manager_save1->proc~output_manager_save2 proc~in_window in_window proc~output_manager_save2->proc~in_window Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~output_manager_save1~~CalledByGraph proc~output_manager_save1 output_manager_save1 interface~output_manager_save output_manager_save interface~output_manager_save->proc~output_manager_save1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output_manager_save1.html"},{"title":"output_manager_prepare_save – Fortran Program","text":"public subroutine output_manager_prepare_save(julianday, secondsofday, microseconds, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds integer, intent(in) :: n Calls proc~~output_manager_prepare_save~~CallsGraph proc~output_manager_prepare_save output_manager_prepare_save proc~in_window in_window proc~output_manager_prepare_save->proc~in_window Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output_manager_prepare_save.html"},{"title":"output_manager_save2 – Fortran Program","text":"private subroutine output_manager_save2(julianday, secondsofday, microseconds, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds integer, intent(in) :: n Calls proc~~output_manager_save2~~CallsGraph proc~output_manager_save2 output_manager_save2 proc~in_window in_window proc~output_manager_save2->proc~in_window Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~output_manager_save2~~CalledByGraph proc~output_manager_save2 output_manager_save2 proc~output_manager_save1 output_manager_save1 proc~output_manager_save1->proc~output_manager_save2 interface~output_manager_save output_manager_save interface~output_manager_save->proc~output_manager_save2 interface~output_manager_save->proc~output_manager_save1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output_manager_save2.html"},{"title":"configure_from_yaml – Fortran Program","text":"private subroutine configure_from_yaml(field_manager, title, postfix, settings) Arguments Type Intent Optional Attributes Name type( type_field_manager ), target :: field_manager character(len=*), intent(in) :: title character(len=*), intent(in), optional :: postfix class(type_settings), optional pointer :: settings Calls proc~~configure_from_yaml~~CallsGraph proc~configure_from_yaml configure_from_yaml type_settings_create type_settings_create proc~configure_from_yaml->type_settings_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~configure_from_yaml~~CalledByGraph proc~configure_from_yaml configure_from_yaml proc~output_manager_init output_manager_init proc~output_manager_init->proc~configure_from_yaml Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/configure_from_yaml.html"},{"title":"output_manager_add_file – Fortran Program","text":"public subroutine output_manager_add_file(field_manager, file) Arguments Type Intent Optional Attributes Name type( type_field_manager ), target :: field_manager class( type_file ), target :: file Called by proc~~output_manager_add_file~~CalledByGraph proc~output_manager_add_file output_manager_add_file proc~process_file process_file proc~process_file->proc~output_manager_add_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output_manager_add_file.html"},{"title":"process_file – Fortran Program","text":"private subroutine process_file(self, pair) Arguments Type Intent Optional Attributes Name class( type_file_populator ), intent(inout) :: self type(type_key_value_pair), intent(inout) :: pair Calls proc~~process_file~~CallsGraph proc~process_file process_file proc~read_time_string read_time_string proc~process_file->proc~read_time_string type_logical_setting_create type_logical_setting_create proc~process_file->type_logical_setting_create type_option type_option proc~process_file->type_option type_settings_create type_settings_create proc~process_file->type_settings_create proc~configure_group configure_group proc~process_file->proc~configure_group proc~output_manager_add_file output_manager_add_file proc~process_file->proc~output_manager_add_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/process_file.html"},{"title":"configure_group – Fortran Program","text":"private recursive subroutine configure_group(file, settings, default_variable_settings) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout), target :: file class(type_settings), intent(inout) :: settings class( type_output_variable_settings ), intent(in), optional :: default_variable_settings Called by proc~~configure_group~~CalledByGraph proc~configure_group configure_group proc~process_file process_file proc~process_file->proc~configure_group proc~create_group_settings create_group_settings proc~create_group_settings->proc~configure_group Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/configure_group.html"},{"title":"create_group_settings – Fortran Program","text":"private recursive subroutine create_group_settings(self, index, item) Arguments Type Intent Optional Attributes Name class( type_group_populator ), intent(inout) :: self integer, intent(in) :: index type(type_list_item), intent(inout) :: item Calls proc~~create_group_settings~~CallsGraph proc~create_group_settings create_group_settings type_settings_create type_settings_create proc~create_group_settings->type_settings_create proc~configure_group configure_group proc~create_group_settings->proc~configure_group Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/create_group_settings.html"},{"title":"create_operator_settings – Fortran Program","text":"private recursive subroutine create_operator_settings(self, index, item) Arguments Type Intent Optional Attributes Name class( type_operator_populator ), intent(inout) :: self integer, intent(in) :: index type(type_list_item), intent(inout) :: item Calls proc~~create_operator_settings~~CallsGraph proc~create_operator_settings create_operator_settings proc~apply_operator apply_operator proc~create_operator_settings->proc~apply_operator type_settings_create type_settings_create proc~create_operator_settings->type_settings_create type_option type_option proc~apply_operator->type_option Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/create_operator_settings.html"},{"title":"create_variable_settings – Fortran Program","text":"private recursive subroutine create_variable_settings(self, index, item) Arguments Type Intent Optional Attributes Name class( type_variable_populator ), intent(inout) :: self integer, intent(in) :: index type(type_list_item), intent(inout) :: item Calls proc~~create_variable_settings~~CallsGraph proc~create_variable_settings create_variable_settings type_settings_create type_settings_create proc~create_variable_settings->type_settings_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/create_variable_settings.html"},{"title":"output_manager_save – Fortran Program","text":"public interface output_manager_save Calls interface~~output_manager_save~~CallsGraph interface~output_manager_save output_manager_save proc~output_manager_save2 output_manager_save2 interface~output_manager_save->proc~output_manager_save2 proc~output_manager_save1 output_manager_save1 interface~output_manager_save->proc~output_manager_save1 proc~in_window in_window proc~output_manager_save2->proc~in_window proc~output_manager_save1->proc~output_manager_save2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures output_manager_save1 output_manager_save2 Module Procedures private subroutine output_manager_save1 (julianday, secondsofday, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: n private subroutine output_manager_save2 (julianday, secondsofday, microseconds, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds integer, intent(in) :: n","tags":"","loc":"interface/output_manager_save.html"},{"title":"put_att_typed_real – Fortran Program","text":"private function put_att_typed_real(ncid, varid, name, value, data_type) result(iret) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: varid character(len=*), intent(in) :: name real(kind=rk), intent(in) :: value integer, intent(in) :: data_type Return Value integer Calls proc~~put_att_typed_real~~CallsGraph proc~put_att_typed_real put_att_typed_real nf90_put_att nf90_put_att proc~put_att_typed_real->nf90_put_att Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~put_att_typed_real~~CalledByGraph proc~put_att_typed_real put_att_typed_real proc~initialize~3 initialize proc~initialize~3->proc~put_att_typed_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/put_att_typed_real.html"},{"title":"create_settings – Fortran Program","text":"private function create_settings(self) result(settings) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self Return Value class( type_output_variable_settings ),\n  pointer Contents None","tags":"","loc":"proc/create_settings~2.html"},{"title":"configure – Fortran Program","text":"private subroutine configure(self, settings) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self class(type_settings), intent(inout) :: settings Calls proc~~configure~2~~CallsGraph proc~configure~2 configure proc~read_time_string read_time_string proc~configure~2->proc~read_time_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/configure~2.html"},{"title":"initialize – Fortran Program","text":"private subroutine initialize(self) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self Calls proc~~initialize~3~~CallsGraph proc~initialize~3 initialize proc~put_att_typed_real put_att_typed_real proc~initialize~3->proc~put_att_typed_real nf90_put_att nf90_put_att proc~initialize~3->nf90_put_att proc~check_err check_err proc~initialize~3->proc~check_err nf90_enddef nf90_enddef proc~initialize~3->nf90_enddef proc~write_time_string write_time_string proc~initialize~3->proc~write_time_string nf90_create nf90_create proc~initialize~3->nf90_create nf90_def_var nf90_def_var proc~initialize~3->nf90_def_var proc~put_att_typed_real->nf90_put_att nf90_strerror nf90_strerror proc~check_err->nf90_strerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize~3.html"},{"title":"save – Fortran Program","text":"private subroutine save(self, julianday, secondsofday, microseconds) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds Calls proc~~save~2~~CallsGraph proc~save~2 save nf90_sync nf90_sync proc~save~2->nf90_sync nf90_put_var nf90_put_var proc~save~2->nf90_put_var nf90_strerror nf90_strerror proc~save~2->nf90_strerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/save~2.html"},{"title":"finalize – Fortran Program","text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self Calls proc~~finalize~3~~CallsGraph proc~finalize~3 finalize nf90_close nf90_close proc~finalize~3->nf90_close proc~check_err check_err proc~finalize~3->proc~check_err nf90_strerror nf90_strerror proc~check_err->nf90_strerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/finalize~3.html"},{"title":"check_err – Fortran Program","text":"private subroutine check_err(iret) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iret Calls proc~~check_err~~CallsGraph proc~check_err check_err nf90_strerror nf90_strerror proc~check_err->nf90_strerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~check_err~~CalledByGraph proc~check_err check_err proc~finalize~3 finalize proc~finalize~3->proc~check_err proc~initialize~3 initialize proc~initialize~3->proc~check_err Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check_err.html"},{"title":"netcdf_variable_settings_initialize – Fortran Program","text":"private subroutine netcdf_variable_settings_initialize(self, settings, parent) Arguments Type Intent Optional Attributes Name class( type_netcdf_variable_settings ), intent(inout) :: self class(type_settings), intent(inout) :: settings class( type_output_variable_settings ), intent(in), optional :: parent Calls proc~~netcdf_variable_settings_initialize~~CallsGraph proc~netcdf_variable_settings_initialize netcdf_variable_settings_initialize type_option type_option proc~netcdf_variable_settings_initialize->type_option Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/netcdf_variable_settings_initialize.html"},{"title":"get_free_unit – Fortran Program","text":"private function get_free_unit(start, stop) result(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: stop Return Value integer Called by proc~~get_free_unit~~CalledByGraph proc~get_free_unit get_free_unit proc~initialize~4 initialize proc~initialize~4->proc~get_free_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_free_unit.html"},{"title":"initialize – Fortran Program","text":"private subroutine initialize(self) Arguments Type Intent Optional Attributes Name class( type_text_file ), intent(inout) :: self Calls proc~~initialize~4~~CallsGraph proc~initialize~4 initialize proc~get_free_unit get_free_unit proc~initialize~4->proc~get_free_unit proc~has_dimension has_dimension proc~initialize~4->proc~has_dimension Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize~4.html"},{"title":"save – Fortran Program","text":"private subroutine save(self, julianday, secondsofday, microseconds) Arguments Type Intent Optional Attributes Name class( type_text_file ), intent(inout) :: self integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds Calls proc~~save~3~~CallsGraph proc~save~3 save proc~write_time_string write_time_string proc~save~3->proc~write_time_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/save~3.html"},{"title":"finalize – Fortran Program","text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name class( type_text_file ), intent(inout) :: self Contents None","tags":"","loc":"proc/finalize~4.html"},{"title":"single_text_file_with_scalars_write_header – Fortran Program","text":"private subroutine single_text_file_with_scalars_write_header(self) Arguments Type Intent Optional Attributes Name class( type_single_text_file_with_scalars ), intent(in) :: self Contents None","tags":"","loc":"proc/single_text_file_with_scalars_write_header.html"},{"title":"single_text_file_with_scalars_write_data – Fortran Program","text":"private subroutine single_text_file_with_scalars_write_data(self, timestr) Arguments Type Intent Optional Attributes Name class( type_single_text_file_with_scalars ), intent(in) :: self character(len=*), intent(in) :: timestr Contents None","tags":"","loc":"proc/single_text_file_with_scalars_write_data.html"},{"title":"single_text_file_with_1d_variable_write_header – Fortran Program","text":"private subroutine single_text_file_with_1d_variable_write_header(self) Arguments Type Intent Optional Attributes Name class( type_single_text_file_with_1d_variable ), intent(in) :: self Calls proc~~single_text_file_with_1d_variable_write_header~~CallsGraph proc~single_text_file_with_1d_variable_write_header single_text_file_with_1d_variable_write_header proc~has_dimension has_dimension proc~single_text_file_with_1d_variable_write_header->proc~has_dimension Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/single_text_file_with_1d_variable_write_header.html"},{"title":"single_text_file_with_1d_variable_write_data – Fortran Program","text":"private subroutine single_text_file_with_1d_variable_write_data(self, timestr) Arguments Type Intent Optional Attributes Name class( type_single_text_file_with_1d_variable ), intent(in) :: self character(len=*), intent(in) :: timestr Contents None","tags":"","loc":"proc/single_text_file_with_1d_variable_write_data.html"},{"title":"apply – Fortran Program","text":"private function apply(self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_time_average_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer Contents None","tags":"","loc":"proc/apply.html"},{"title":"flag_as_required – Fortran Program","text":"private recursive subroutine flag_as_required(self, required) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self logical, intent(in) :: required Contents None","tags":"","loc":"proc/flag_as_required.html"},{"title":"new_data – Fortran Program","text":"private recursive subroutine new_data(self) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self Contents None","tags":"","loc":"proc/new_data.html"},{"title":"before_save – Fortran Program","text":"private recursive subroutine before_save(self) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self Contents None","tags":"","loc":"proc/before_save.html"},{"title":"get_metadata – Fortran Program","text":"private recursive subroutine get_metadata(self, long_name, units, dimensions, minimum, maximum, fill_value, standard_name, path, attributes) Arguments Type Intent Optional Attributes Name class( type_result ), intent(in) :: self character(len=:), intent(out), optional allocatable :: long_name character(len=:), intent(out), optional allocatable :: units type( type_dimension_pointer ), intent(out), optional allocatable :: dimensions (:) real(kind=rk), intent(out), optional :: minimum real(kind=rk), intent(out), optional :: maximum real(kind=rk), intent(out), optional :: fill_value character(len=:), intent(out), optional allocatable :: standard_name character(len=:), intent(out), optional allocatable :: path type( type_attributes ), intent(out), optional :: attributes Contents None","tags":"","loc":"proc/get_metadata.html"},{"title":"apply – Fortran Program","text":"private function apply(self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_interp_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer Contents None","tags":"","loc":"proc/apply~2.html"},{"title":"get_field – Fortran Program","text":"private recursive function get_field(self, field) result(output_field) Arguments Type Intent Optional Attributes Name class( type_result ), intent(in) :: self type( type_field ), target :: field Return Value class( type_base_output_field ),\n  pointer Contents None","tags":"","loc":"proc/get_field.html"},{"title":"configure – Fortran Program","text":"private subroutine configure(self, settings, field_manager) Arguments Type Intent Optional Attributes Name class( type_interp_operator ), intent(inout), target :: self class(type_settings), intent(inout) :: settings type( type_field_manager ), intent(inout) :: field_manager Calls proc~~configure~3~~CallsGraph proc~configure~3 configure type_option type_option proc~configure~3->type_option Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/configure~3.html"},{"title":"coordinate_list_set_length – Fortran Program","text":"private recursive subroutine coordinate_list_set_length(self, n) Arguments Type Intent Optional Attributes Name class( type_coordinate_list_populator ), intent(inout) :: self integer, intent(in) :: n Contents None","tags":"","loc":"proc/coordinate_list_set_length.html"},{"title":"coordinate_list_create_element – Fortran Program","text":"private recursive subroutine coordinate_list_create_element(self, index, item) Arguments Type Intent Optional Attributes Name class( type_coordinate_list_populator ), intent(inout) :: self integer, intent(in) :: index type(type_list_item), intent(inout) :: item Calls proc~~coordinate_list_create_element~~CallsGraph proc~coordinate_list_create_element coordinate_list_create_element type_real_setting_create type_real_setting_create proc~coordinate_list_create_element->type_real_setting_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/coordinate_list_create_element.html"},{"title":"flag_as_required – Fortran Program","text":"private recursive subroutine flag_as_required(self, required) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self logical, intent(in) :: required Contents None","tags":"","loc":"proc/flag_as_required~2.html"},{"title":"before_save – Fortran Program","text":"private recursive subroutine before_save(self) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self Calls proc~~before_save~2~~CallsGraph proc~before_save~2 before_save proc~interp interp proc~before_save~2->proc~interp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/before_save~2.html"},{"title":"interp – Fortran Program","text":"private subroutine interp(x, xp, fp, f, out_of_bounds_treatment, out_of_bounds_value) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (:) real(kind=rk), intent(in) :: xp (:) real(kind=rk), intent(in) :: fp (:) real(kind=rk), intent(out) :: f (:) integer, intent(in) :: out_of_bounds_treatment real(kind=rk), intent(in) :: out_of_bounds_value Called by proc~~interp~~CalledByGraph proc~interp interp proc~before_save~2 before_save proc~before_save~2->proc~interp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interp.html"},{"title":"apply_operator – Fortran Program","text":"public subroutine apply_operator(final_operator, settings, field_manager) Arguments Type Intent Optional Attributes Name class( type_base_operator ), pointer :: final_operator class(type_settings), intent(inout) :: settings type( type_field_manager ), intent(inout) :: field_manager Calls proc~~apply_operator~~CallsGraph proc~apply_operator apply_operator type_option type_option proc~apply_operator->type_option Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~apply_operator~~CalledByGraph proc~apply_operator apply_operator proc~create_operator_settings create_operator_settings proc~create_operator_settings->proc~apply_operator Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/apply_operator.html"},{"title":"apply – Fortran Program","text":"private function apply(self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_slice_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer Contents None","tags":"","loc":"proc/apply~3.html"},{"title":"add – Fortran Program","text":"private subroutine add(self, dimension, start, stop, stride) Arguments Type Intent Optional Attributes Name class( type_slice_operator ), intent(inout) :: self character(len=*), intent(in) :: dimension integer, intent(in) :: start integer, intent(in) :: stop integer, intent(in) :: stride Contents None","tags":"","loc":"proc/add.html"},{"title":"find_local_range – Fortran Program","text":"private subroutine find_local_range(global_start, global_stop, local_offset, local_length, stride, local_start, local_stop) Arguments Type Intent Optional Attributes Name integer, intent(in) :: global_start integer, intent(in) :: global_stop integer, intent(in) :: local_offset integer, intent(in) :: local_length integer, intent(in) :: stride integer, intent(out) :: local_start integer, intent(out) :: local_stop Contents None","tags":"","loc":"proc/find_local_range.html"},{"title":"get_field – Fortran Program","text":"private recursive function get_field(self, field) result(output_field) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(in) :: self type( type_field ), target :: field Return Value class( type_base_output_field ),\n  pointer Contents None","tags":"","loc":"proc/get_field~2.html"},{"title":"universal_get_field – Fortran Program","text":"private recursive function universal_get_field(self, field) result(output_field) Arguments Type Intent Optional Attributes Name class( type_universal_operator_result ), intent(in) :: self type( type_field ), target :: field Return Value class( type_base_output_field ),\n  pointer Contents None","tags":"","loc":"proc/universal_get_field.html"},{"title":"new_data – Fortran Program","text":"private recursive subroutine new_data(self) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self Contents None","tags":"","loc":"proc/new_data~2.html"},{"title":"before_save – Fortran Program","text":"private recursive subroutine before_save(self) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self Contents None","tags":"","loc":"proc/before_save~3.html"},{"title":"get_metadata – Fortran Program","text":"private recursive subroutine get_metadata(self, long_name, units, dimensions, minimum, maximum, fill_value, standard_name, path, attributes) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(in) :: self character(len=:), intent(out), optional allocatable :: long_name character(len=:), intent(out), optional allocatable :: units type( type_dimension_pointer ), intent(out), optional allocatable :: dimensions (:) real(kind=rk), intent(out), optional :: minimum real(kind=rk), intent(out), optional :: maximum real(kind=rk), intent(out), optional :: fill_value character(len=:), intent(out), optional allocatable :: standard_name character(len=:), intent(out), optional allocatable :: path type( type_attributes ), intent(out), optional :: attributes Contents None","tags":"","loc":"proc/get_metadata~2.html"},{"title":"flag_as_required – Fortran Program","text":"private recursive subroutine flag_as_required(self, required) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self logical, intent(in) :: required Contents None","tags":"","loc":"proc/flag_as_required~3.html"},{"title":"fill – Fortran Program","text":"private subroutine fill(self, value) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self real(kind=rk), intent(in) :: value Contents None","tags":"","loc":"proc/fill.html"},{"title":"field_manager – Fortran Program","text":"Uses iso_fortran_env module~~field_manager~~UsesGraph module~field_manager field_manager iso_fortran_env iso_fortran_env module~field_manager->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~field_manager~~UsedByGraph module~field_manager field_manager module~output_operators_base output_operators_base module~output_operators_base->module~field_manager module~output_manager_core output_manager_core module~output_operators_base->module~output_manager_core module~output_operators_interp output_operators_interp module~output_operators_interp->module~field_manager module~output_operators_interp->module~output_operators_base module~output_operators_interp->module~output_manager_core module~output_manager output_manager module~output_manager->module~field_manager module~output_operators_library output_operators_library module~output_manager->module~output_operators_library module~netcdf_output netcdf_output module~output_manager->module~netcdf_output module~output_manager->module~output_manager_core module~text_output text_output module~output_manager->module~text_output module~output_operators_time_average output_operators_time_average module~output_manager->module~output_operators_time_average module~output_operators_slice output_operators_slice module~output_manager->module~output_operators_slice module~output_operators_library->module~field_manager module~output_operators_library->module~output_operators_base module~output_operators_library->module~output_operators_interp module~output_operators_library->module~output_manager_core module~output_operators_library->module~output_operators_time_average module~output_operators_library->module~output_operators_slice module~netcdf_output->module~field_manager module~netcdf_output->module~output_manager_core module~output_manager_core->module~field_manager module~text_output->module~field_manager module~text_output->module~output_manager_core module~output_operators_time_average->module~field_manager module~output_operators_time_average->module~output_operators_base module~output_operators_time_average->module~output_manager_core module~output_operators_slice->module~field_manager module~output_operators_slice->module~output_operators_base module~output_operators_slice->module~output_manager_core var panmodulefield_managerUsedByGraph = svgPanZoom('#modulefield_managerUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables string_length nmaxdims rk id_dim_lon id_dim_lat id_dim_z id_dim_zi id_dim_time id_dim_unused status_not_registered status_registered_no_data status_registered_with_data output_level_none output_level_required output_level_default output_level_debug default_fill_value default_minimum default_maximum hash_table_size Derived Types type_dimension type_dimension_pointer type_attribute type_real_attribute type_integer_attribute type_string_attribute type_attributes type_nd_data_pointer type_field type_node type_field_node type_category_node type_dictionary_bin type_field_set_member type_field_set type_field_manager Functions next_free_dimension_id find_dimension select_for_output select_category_for_output has_fields find has_dimension field_has_dimension find_category data_is_empty get_state category_get_path hash Subroutines register_dimension initialize list list_node finalize reset_used field_set_add field_set_finalize get_all_fields register attributes_delete attributes_set_object attributes_set_real attributes_set_integer attributes_set_string attributes_update field_finalize add_field_to_tree add_to_category send_data_by_name_0d send_data_by_name_1d send_data_by_name_2d send_data_by_name_3d check_sent_data send_data_0d send_data_1d send_data_2d send_data_3d data_set_0d data_set_1d data_set_2d data_set_3d data_get_extents fatal_error node_finalize field_set_real_attribute Variables Type Visibility Attributes Name Initial integer, public, parameter :: string_length = 256 integer, private, parameter :: nmaxdims = 10 integer, private, parameter :: rk = kind(_ONE_) integer, public, parameter :: id_dim_lon = 1 integer, public, parameter :: id_dim_lat = 2 integer, public, parameter :: id_dim_z = 3 integer, public, parameter :: id_dim_zi = 4 integer, public, parameter :: id_dim_time = 5 integer, public, parameter :: id_dim_unused = 20 integer, public, parameter :: status_not_registered = 0 integer, public, parameter :: status_registered_no_data = 1 integer, public, parameter :: status_registered_with_data = 2 integer, public, parameter :: output_level_none = 0 integer, public, parameter :: output_level_required = 2 integer, public, parameter :: output_level_default = 8 integer, public, parameter :: output_level_debug = 32 real(kind=rk), public, parameter :: default_fill_value = -huge(_ONE_) real(kind=rk), public, parameter :: default_minimum = default_fill_value+spacing(default_fill_value) real(kind=rk), public, parameter :: default_maximum = huge(_ONE_) integer, private, parameter :: hash_table_size = 256 Derived Types type, public :: type_dimension Components Type Visibility Attributes Name Initial character(len=string_length), public :: name = '' character(len=string_length), public :: iterator = '' integer, public :: length = -1 integer, public :: global_length = -1 integer, public :: offset = 0 integer, public :: id = -1 type( type_field ), public, pointer :: coordinate => null() type( type_dimension ), public, pointer :: next => null() type, public :: type_dimension_pointer Components Type Visibility Attributes Name Initial type( type_dimension ), public, pointer :: p => null() type, public :: type_attribute Components Type Visibility Attributes Name Initial character(len=string_length), public :: name = '' class( type_attribute ), public, pointer :: next => null() type, public, extends( type_attribute ) :: type_real_attribute Components Type Visibility Attributes Name Initial character(len=string_length), public :: name = '' class( type_attribute ), public, pointer :: next => null() real(kind=rk), public :: value = 0.0_rk type, public, extends( type_attribute ) :: type_integer_attribute Components Type Visibility Attributes Name Initial character(len=string_length), public :: name = '' class( type_attribute ), public, pointer :: next => null() integer, public :: value = 0 type, public, extends( type_attribute ) :: type_string_attribute Components Type Visibility Attributes Name Initial character(len=string_length), public :: name = '' class( type_attribute ), public, pointer :: next => null() character(len=string_length), public :: value = '' type, public :: type_attributes Components Type Visibility Attributes Name Initial class( type_attribute ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: set_object => attributes_set_object procedure, public :: delete => attributes_delete procedure, public :: set_real => attributes_set_real procedure, public :: set_integer => attributes_set_integer procedure, public :: set_string => attributes_set_string generic, public :: set => set_real, set_integer, set_string, set_object procedure, public :: update => attributes_update type, public :: type_nd_data_pointer Components Type Visibility Attributes Name Initial real(kind=rk), public, pointer :: p0d => null() real(kind=rk), public, pointer :: p1d (:) => null() real(kind=rk), public, pointer :: p2d (:,:) => null() real(kind=rk), public, pointer :: p3d (:,:,:) => null() Type-Bound Procedures procedure, public :: set_0d => data_set_0d procedure, public :: set_1d => data_set_1d procedure, public :: set_2d => data_set_2d procedure, public :: set_3d => data_set_3d generic, public :: set => set_0d, set_1d, set_2d, set_3d procedure, public :: get_extents => data_get_extents procedure, public :: is_empty => data_is_empty type, public :: type_field Components Type Visibility Attributes Name Initial integer, public :: id = 0 character(len=string_length), public :: name = '' character(len=string_length), public :: units = '' character(len=string_length), public :: long_name = '' character(len=string_length), public :: standard_name = '' real(kind=rk), public :: fill_value = default_fill_value real(kind=rk), public :: minimum = default_minimum real(kind=rk), public :: maximum = default_maximum integer, public :: output_level = output_level_default logical, public :: in_output = .false. logical, public, pointer :: used_now => null() integer, public :: status = status_not_registered type( type_dimension_pointer ), public, allocatable :: dimensions (:) type( type_attributes ), public :: attributes integer, public, allocatable :: extents (:) type( type_nd_data_pointer ), public :: data class( type_category_node ), public, pointer :: category => null() type( type_field ), public, pointer :: next => null() Type-Bound Procedures procedure, public :: has_dimension => field_has_dimension procedure, public :: finalize => field_finalize procedure, public :: field_set_real_attribute generic, public :: set_attribute => field_set_real_attribute type, private, abstract :: type_node Components Type Visibility Attributes Name Initial class( type_node ), public, pointer :: parent => null() class( type_node ), public, pointer :: first_child => null() class( type_node ), public, pointer :: next_sibling => null() Type-Bound Procedures procedure, public :: finalize => node_finalize type, private, extends( type_node ) :: type_field_node Components Type Visibility Attributes Name Initial class( type_node ), public, pointer :: parent => null() class( type_node ), public, pointer :: first_child => null() class( type_node ), public, pointer :: next_sibling => null() type( type_field ), public, pointer :: field => null() Type-Bound Procedures procedure, public :: finalize => node_finalize type, public, extends( type_node ) :: type_category_node Components Type Visibility Attributes Name Initial class( type_node ), public, pointer :: parent => null() class( type_node ), public, pointer :: first_child => null() class( type_node ), public, pointer :: next_sibling => null() character(len=string_length), public :: name = '' integer, public :: output_level = output_level_none Type-Bound Procedures procedure, public :: finalize => node_finalize procedure, public :: get_all_fields procedure, public :: has_fields procedure, public :: get_path => category_get_path type, private :: type_dictionary_bin Components Type Visibility Attributes Name Initial type( type_field ), public, pointer :: first_field => null() type, public :: type_field_set_member Components Type Visibility Attributes Name Initial type( type_field ), public, pointer :: field => null() type( type_field_set_member ), public, pointer :: next => null() type, public :: type_field_set Components Type Visibility Attributes Name Initial type( type_field_set_member ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: add => field_set_add procedure, public :: finalize => field_set_finalize type, public :: type_field_manager Components Type Visibility Attributes Name Initial type( type_dimension ), public, pointer :: first_dimension => null() type( type_dimension_pointer ), public, allocatable :: prepend_dimensions (:) type( type_dimension_pointer ), public, allocatable :: append_dimensions (:) type( type_dictionary_bin ), public :: field_table (hash_table_size) type( type_category_node ), public :: root integer, public :: nregistered = 0 Type-Bound Procedures procedure, public :: initialize procedure, public :: finalize procedure, public :: register procedure, public :: find procedure, public :: list procedure, public :: send_data_0d procedure, public :: send_data_1d procedure, public :: send_data_2d procedure, public :: send_data_3d procedure, public :: send_data_by_name_0d procedure, public :: send_data_by_name_1d procedure, public :: send_data_by_name_2d procedure, public :: send_data_by_name_3d procedure, public :: select_for_output procedure, public :: select_category_for_output procedure, public :: register_dimension procedure, public :: find_dimension procedure, public :: find_category procedure, public :: get_state procedure, public :: reset_used generic, public :: send_data => send_data_0d, send_data_1d, send_data_2d, send_data_3d, send_data_by_name_0d, send_data_by_name_1d, send_data_by_name_2d, send_data_by_name_3d Functions private function next_free_dimension_id (self) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(in) :: self Return Value integer private function find_dimension (self, dimid) result(dim) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(in) :: self integer, intent(in) :: dimid Return Value type( type_dimension ),\n  pointer private function select_for_output (self, name) result(field) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name Return Value type( type_field ),\n  pointer private function select_category_for_output (self, name, output_level) result(category) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(in) :: output_level Return Value class( type_category_node ),\n  pointer private recursive function has_fields (self) Arguments Type Intent Optional Attributes Name class( type_category_node ), intent(inout) :: self Return Value logical private function find (self, name, create) result(field) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name logical, intent(in), optional :: create Return Value type( type_field ),\n  pointer public function has_dimension (dimensions, id) Arguments Type Intent Optional Attributes Name type( type_dimension_pointer ), intent(in) :: dimensions (:) integer, intent(in) :: id Return Value logical private function field_has_dimension (self, id) Arguments Type Intent Optional Attributes Name class( type_field ), intent(in) :: self integer, intent(in) :: id Return Value logical private function find_category (self, name, create) result(category) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout), target :: self character(len=*), intent(in) :: name logical, intent(in), optional :: create Return Value class( type_category_node ),\n  pointer private function data_is_empty (self) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(in) :: self Return Value logical private function get_state (self) result(field_set) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self Return Value type( type_field_set ) private function category_get_path (self) result(path) Arguments Type Intent Optional Attributes Name class( type_category_node ), intent(in), target :: self Return Value character(len=256) private function hash (str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer Subroutines private subroutine register_dimension (self, name, length, global_length, offset, id, newid) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(in), optional :: length integer, intent(in), optional :: global_length integer, intent(in), optional :: offset integer, intent(in), optional :: id integer, intent(out), optional :: newid private subroutine initialize (self, prepend_by_default, append_by_default) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self integer, intent(in), optional :: prepend_by_default (:) integer, intent(in), optional :: append_by_default (:) private subroutine list (self) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(in) :: self private recursive subroutine list_node (category, depth) Arguments Type Intent Optional Attributes Name type( type_category_node ), intent(in) :: category integer, intent(in) :: depth private subroutine finalize (self) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self private subroutine reset_used (self) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self private subroutine field_set_add (self, field) Arguments Type Intent Optional Attributes Name class( type_field_set ), intent(inout) :: self type( type_field ), target :: field private subroutine field_set_finalize (self) Arguments Type Intent Optional Attributes Name class( type_field_set ), intent(inout) :: self private recursive subroutine get_all_fields (self, set, output_level) Arguments Type Intent Optional Attributes Name class( type_category_node ), intent(inout) :: self type( type_field_set ), intent(inout) :: set integer, intent(in) :: output_level private subroutine register (self, name, units, long_name, standard_name, fill_value, minimum, maximum, dimensions, data0d, data1d, data2d, data3d, no_default_dimensions, category, output_level, coordinate_dimension, part_of_state, used, used_now, field) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: units character(len=*), intent(in) :: long_name character(len=*), intent(in), optional :: standard_name real(kind=rk), intent(in), optional :: fill_value real(kind=rk), intent(in), optional :: minimum real(kind=rk), intent(in), optional :: maximum integer, intent(in), optional :: dimensions (:) real(kind=rk), optional target :: data0d real(kind=rk), optional target :: data1d (:) real(kind=rk), optional target :: data2d (:,:) real(kind=rk), optional target :: data3d (:,:,:) logical, intent(in), optional :: no_default_dimensions character(len=*), intent(in), optional :: category integer, intent(in), optional :: output_level integer, intent(in), optional :: coordinate_dimension logical, intent(in), optional :: part_of_state logical, intent(out), optional :: used logical, optional target :: used_now type( type_field ), optional pointer :: field private subroutine attributes_delete (self, name) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name private subroutine attributes_set_object (self, name, attribute) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name class( type_attribute ), intent(inout), target :: attribute private subroutine attributes_set_real (self, name, value) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), intent(in) :: value private subroutine attributes_set_integer (self, name, value) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name integer, intent(in) :: value private subroutine attributes_set_string (self, name, value) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self character(len=*), intent(in) :: name character(len=*), intent(in) :: value private subroutine attributes_update (self, other) Arguments Type Intent Optional Attributes Name class( type_attributes ), intent(inout) :: self class( type_attributes ), intent(in) :: other private subroutine field_finalize (self) Arguments Type Intent Optional Attributes Name class( type_field ), intent(inout) :: self private subroutine add_field_to_tree (self, field, category) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout), target :: self type( type_field ), target :: field character(len=*), intent(in), optional :: category private subroutine add_to_category (parent, node) Arguments Type Intent Optional Attributes Name type( type_category_node ), intent(inout), target :: parent class( type_node ), target :: node private subroutine send_data_by_name_0d (self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data private subroutine send_data_by_name_1d (self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data (:) private subroutine send_data_by_name_2d (self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data (:,:) private subroutine send_data_by_name_3d (self, name, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), target :: data (:,:,:) private subroutine check_sent_data (field) Arguments Type Intent Optional Attributes Name type( type_field ), intent(inout) :: field private subroutine send_data_0d (self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data private subroutine send_data_1d (self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data (:) private subroutine send_data_2d (self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data (:,:) private subroutine send_data_3d (self, field, data) Arguments Type Intent Optional Attributes Name class( type_field_manager ), intent(inout) :: self type( type_field ), intent(inout) :: field real(kind=rk), target :: data (:,:,:) private subroutine data_set_0d (self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data private subroutine data_set_1d (self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data (:) private subroutine data_set_2d (self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data (:,:) private subroutine data_set_3d (self, data) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(inout) :: self real(kind=rk), target :: data (:,:,:) private subroutine data_get_extents (self, extents) Arguments Type Intent Optional Attributes Name class( type_nd_data_pointer ), intent(in) :: self integer, intent(out), allocatable :: extents (:) private subroutine fatal_error (location, error) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: location character(len=*), intent(in) :: error private recursive subroutine node_finalize (self) Arguments Type Intent Optional Attributes Name class( type_node ), intent(inout) :: self private subroutine field_set_real_attribute (self, name, value) Arguments Type Intent Optional Attributes Name class( type_field ), intent(inout) :: self character(len=*), intent(in) :: name real(kind=rk), intent(in) :: value","tags":"","loc":"module/field_manager.html"},{"title":"output_manager_core – Fortran Program","text":"Uses iso_fortran_env field_manager yaml_settings module~~output_manager_core~~UsesGraph module~output_manager_core output_manager_core module~field_manager field_manager module~output_manager_core->module~field_manager yaml_settings yaml_settings module~output_manager_core->yaml_settings iso_fortran_env iso_fortran_env module~output_manager_core->iso_fortran_env module~field_manager->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~output_manager_core~~UsedByGraph module~output_manager_core output_manager_core module~output_operators_base output_operators_base module~output_operators_base->module~output_manager_core module~output_operators_interp output_operators_interp module~output_operators_interp->module~output_manager_core module~output_operators_interp->module~output_operators_base module~output_manager output_manager module~output_manager->module~output_manager_core module~output_operators_library output_operators_library module~output_manager->module~output_operators_library module~netcdf_output netcdf_output module~output_manager->module~netcdf_output module~text_output text_output module~output_manager->module~text_output module~output_operators_time_average output_operators_time_average module~output_manager->module~output_operators_time_average module~output_operators_slice output_operators_slice module~output_manager->module~output_operators_slice module~output_operators_library->module~output_manager_core module~output_operators_library->module~output_operators_base module~output_operators_library->module~output_operators_interp module~output_operators_library->module~output_operators_time_average module~output_operators_library->module~output_operators_slice module~netcdf_output->module~output_manager_core module~text_output->module~output_manager_core module~output_operators_time_average->module~output_manager_core module~output_operators_time_average->module~output_operators_base module~output_operators_slice->module~output_manager_core module~output_operators_slice->module~output_operators_base var panmoduleoutput_manager_coreUsedByGraph = svgPanZoom('#moduleoutput_manager_coreUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables max_path time_method_none time_method_instantaneous time_method_mean time_method_integrated time_unit_none time_unit_second time_unit_hour time_unit_day time_unit_month time_unit_year time_unit_dt time_from_list rk host Abstract Interfaces host_julian_day host_calendar_date Derived Types type_host type_output_variable_settings type_output_item type_output_field_pointer type_base_output_field type_output_field type_file type_base_operator Functions base_field_get_field wrap_field create_settings is_dimension_used operator_apply operator_apply_all Subroutines base_field_flag_as_required base_field_get_metadata base_field_new_data base_field_before_save field_flag_as_required field_get_metadata configure initialize save finalize write_time_string read_time_string host_fatal_error host_log_message append_item output_variable_settings_initialize operator_configure Variables Type Visibility Attributes Name Initial integer, public, parameter :: max_path = 256 integer, public, parameter :: time_method_none = 0 integer, public, parameter :: time_method_instantaneous = 1 integer, public, parameter :: time_method_mean = 2 integer, public, parameter :: time_method_integrated = 3 integer, public, parameter :: time_unit_none = 0 integer, public, parameter :: time_unit_second = 1 integer, public, parameter :: time_unit_hour = 2 integer, public, parameter :: time_unit_day = 3 integer, public, parameter :: time_unit_month = 4 integer, public, parameter :: time_unit_year = 5 integer, public, parameter :: time_unit_dt = 6 integer, public, parameter :: time_from_list = 7 integer, public, parameter :: rk = kind(_ONE_) class( type_host ), public, pointer, save :: host => null() Abstract Interfaces abstract interface private subroutine host_julian_day(self, yyyy, mm, dd, julian) Arguments Type Intent Optional Attributes Name class( type_host ), intent(in) :: self integer, intent(in) :: yyyy integer, intent(in) :: mm integer, intent(in) :: dd integer, intent(out) :: julian abstract interface private subroutine host_calendar_date(self, julian, yyyy, mm, dd) Arguments Type Intent Optional Attributes Name class( type_host ), intent(in) :: self integer, intent(in) :: julian integer, intent(out) :: yyyy integer, intent(out) :: mm integer, intent(out) :: dd Derived Types type, public, abstract :: type_host Type-Bound Procedures procedure(host_julian_day), public :: julian_day procedure(host_calendar_date), public :: calendar_date procedure, public :: fatal_error => host_fatal_error procedure, public :: log_message => host_log_message type, public :: type_output_variable_settings Components Type Visibility Attributes Name Initial integer, public :: time_method = time_method_instantaneous class( type_base_operator ), public, pointer :: final_operator => null() Type-Bound Procedures procedure, public :: initialize => output_variable_settings_initialize type, public :: type_output_item Components Type Visibility Attributes Name Initial class( type_output_variable_settings ), public, pointer :: settings => null() character(len=string_length), public :: name = '' character(len=string_length), public :: prefix = '' character(len=string_length), public :: postfix = '' integer, public :: output_level = output_level_default class( type_category_node ), public, pointer :: category => null() type( type_field ), public, pointer :: field => null() type( type_output_item ), public, pointer :: next => null() type, private :: type_output_field_pointer Components Type Visibility Attributes Name Initial class( type_base_output_field ), public, pointer :: p => null() type, public :: type_base_output_field Components Type Visibility Attributes Name Initial class( type_output_variable_settings ), public, pointer :: settings => null() character(len=string_length), public :: output_name = '' logical, public :: is_coordinate = .false. type( type_nd_data_pointer ), public :: data type( type_output_field_pointer ), public, allocatable :: coordinates (:) class( type_base_output_field ), public, pointer :: next => null() Type-Bound Procedures procedure, public :: new_data => base_field_new_data procedure, public :: before_save => base_field_before_save procedure, public :: flag_as_required => base_field_flag_as_required procedure, public :: get_metadata => base_field_get_metadata procedure, public :: get_field => base_field_get_field type, public, extends( type_base_output_field ) :: type_output_field Components Type Visibility Attributes Name Initial class( type_output_variable_settings ), public, pointer :: settings => null() character(len=string_length), public :: output_name = '' logical, public :: is_coordinate = .false. type( type_nd_data_pointer ), public :: data type( type_output_field_pointer ), public, allocatable :: coordinates (:) class( type_base_output_field ), public, pointer :: next => null() type( type_field ), public, pointer :: source => null() Type-Bound Procedures procedure, public :: new_data => base_field_new_data procedure, public :: before_save => base_field_before_save procedure, public :: get_field => base_field_get_field procedure, public :: flag_as_required => field_flag_as_required procedure, public :: get_metadata => field_get_metadata type, public :: type_file Components Type Visibility Attributes Name Initial type( type_field_manager ), public, pointer :: field_manager => null() character(len=max_path), public :: path = '' character(len=max_path), public :: postfix = '' character(len=string_length), public :: title = '' integer, public :: time_unit = time_unit_none integer, public :: time_step = 0 integer, public :: first_index = 0 integer, public :: next_julian = -1 integer, public :: next_seconds = -1 integer, public :: first_julian = -1 integer, public :: first_seconds = -1 integer, public :: last_julian = huge(1) integer, public :: last_seconds = 0 type( type_output_item ), public, pointer :: first_item => null() class( type_base_output_field ), public, pointer :: first_field => null() class( type_file ), public, pointer :: next => null() Type-Bound Procedures procedure, public :: configure procedure, public :: initialize procedure, public :: save procedure, public :: finalize procedure, public :: create_settings procedure, public :: is_dimension_used procedure, public :: append_item type, public :: type_base_operator Components Type Visibility Attributes Name Initial class( type_base_operator ), public, pointer :: previous => null() Type-Bound Procedures procedure, public :: configure => operator_configure procedure, public :: apply => operator_apply procedure, public :: apply_all => operator_apply_all Functions private recursive function base_field_get_field (self, field) result(output_field) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(in) :: self type( type_field ), target :: field Return Value class( type_base_output_field ),\n  pointer public function wrap_field (field, allow_unregistered) result(output_field) Arguments Type Intent Optional Attributes Name type( type_field ), target :: field logical, intent(in) :: allow_unregistered Return Value class( type_output_field ),\n  pointer private function create_settings (self) result(settings) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self Return Value class( type_output_variable_settings ),\n  pointer private function is_dimension_used (self, dim) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self type( type_dimension ), target :: dim Return Value logical private function operator_apply (self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_base_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer private recursive function operator_apply_all (self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_base_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer Subroutines private recursive subroutine base_field_flag_as_required (self, required) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(inout) :: self logical, intent(in) :: required private recursive subroutine base_field_get_metadata (self, long_name, units, dimensions, minimum, maximum, fill_value, standard_name, path, attributes) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(in) :: self character(len=:), intent(out), optional allocatable :: long_name character(len=:), intent(out), optional allocatable :: units type( type_dimension_pointer ), intent(out), optional allocatable :: dimensions (:) real(kind=rk), intent(out), optional :: minimum real(kind=rk), intent(out), optional :: maximum real(kind=rk), intent(out), optional :: fill_value character(len=:), intent(out), optional allocatable :: standard_name character(len=:), intent(out), optional allocatable :: path type( type_attributes ), intent(out), optional :: attributes private recursive subroutine base_field_new_data (self) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(inout) :: self private recursive subroutine base_field_before_save (self) Arguments Type Intent Optional Attributes Name class( type_base_output_field ), intent(inout) :: self private recursive subroutine field_flag_as_required (self, required) Arguments Type Intent Optional Attributes Name class( type_output_field ), intent(inout) :: self logical, intent(in) :: required private recursive subroutine field_get_metadata (self, long_name, units, dimensions, minimum, maximum, fill_value, standard_name, path, attributes) Arguments Type Intent Optional Attributes Name class( type_output_field ), intent(in) :: self character(len=:), intent(out), optional allocatable :: long_name character(len=:), intent(out), optional allocatable :: units type( type_dimension_pointer ), intent(out), optional allocatable :: dimensions (:) real(kind=rk), intent(out), optional :: minimum real(kind=rk), intent(out), optional :: maximum real(kind=rk), intent(out), optional :: fill_value character(len=:), intent(out), optional allocatable :: standard_name character(len=:), intent(out), optional allocatable :: path type( type_attributes ), intent(out), optional :: attributes private subroutine configure (self, settings) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self class(type_settings), intent(inout) :: settings private subroutine initialize (self) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self private subroutine save (self, julianday, secondsofday, microseconds) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds private subroutine finalize (self) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self public subroutine write_time_string (jul, secs, timestr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: jul integer, intent(in) :: secs character(len=*), intent(out) :: timestr public subroutine read_time_string (timestr, jul, secs, success) Arguments Type Intent Optional Attributes Name character(len=19) :: timestr integer, intent(out) :: jul integer, intent(out) :: secs logical, intent(out) :: success private subroutine host_fatal_error (self, location, error) Arguments Type Intent Optional Attributes Name class( type_host ), intent(in) :: self character(len=*), intent(in) :: location character(len=*), intent(in) :: error private subroutine host_log_message (self, message) Arguments Type Intent Optional Attributes Name class( type_host ), intent(in) :: self character(len=*), intent(in) :: message private subroutine append_item (self, item) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self type( type_output_item ), target :: item private subroutine output_variable_settings_initialize (self, settings, parent) Arguments Type Intent Optional Attributes Name class( type_output_variable_settings ), intent(inout) :: self class(type_settings), intent(inout) :: settings class( type_output_variable_settings ), intent(in), optional :: parent private subroutine operator_configure (self, settings, field_manager) Arguments Type Intent Optional Attributes Name class( type_base_operator ), intent(inout), target :: self class(type_settings), intent(inout) :: settings type( type_field_manager ), intent(inout) :: field_manager","tags":"","loc":"module/output_manager_core.html"},{"title":"flexout_version – Fortran Program","text":"Version information will be optained from Git and includes branch and hash information. Contents Variables git_commit_id git_branch_name Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: git_commit_id = \"@GIT_COMMIT_ID@\" character(len=*), public, parameter :: git_branch_name = \"@GIT_BRANCH_NAME@\"","tags":"","loc":"module/flexout_version.html"},{"title":"output_manager – Fortran Program","text":"Uses field_manager output_manager_core netcdf_output text_output output_operators_library output_operators_time_average output_operators_slice yaml_settings module~~output_manager~~UsesGraph module~output_manager output_manager module~output_operators_library output_operators_library module~output_manager->module~output_operators_library module~netcdf_output netcdf_output module~output_manager->module~netcdf_output module~field_manager field_manager module~output_manager->module~field_manager module~output_manager_core output_manager_core module~output_manager->module~output_manager_core module~text_output text_output module~output_manager->module~text_output module~output_operators_time_average output_operators_time_average module~output_manager->module~output_operators_time_average yaml_settings yaml_settings module~output_manager->yaml_settings module~output_operators_slice output_operators_slice module~output_manager->module~output_operators_slice module~output_operators_library->module~field_manager module~output_operators_library->module~output_manager_core module~output_operators_library->module~output_operators_time_average module~output_operators_library->yaml_settings module~output_operators_library->module~output_operators_slice module~output_operators_interp output_operators_interp module~output_operators_library->module~output_operators_interp module~output_operators_base output_operators_base module~output_operators_library->module~output_operators_base module~netcdf_output->module~field_manager module~netcdf_output->module~output_manager_core module~netcdf_output->yaml_settings netcdf netcdf module~netcdf_output->netcdf iso_fortran_env iso_fortran_env module~field_manager->iso_fortran_env module~output_manager_core->module~field_manager module~output_manager_core->yaml_settings module~output_manager_core->iso_fortran_env module~text_output->module~field_manager module~text_output->module~output_manager_core module~output_operators_time_average->module~field_manager module~output_operators_time_average->module~output_manager_core module~output_operators_time_average->module~output_operators_base module~output_operators_slice->module~field_manager module~output_operators_slice->module~output_manager_core module~output_operators_slice->module~output_operators_base module~output_operators_interp->module~field_manager module~output_operators_interp->module~output_manager_core module~output_operators_interp->yaml_settings module~output_operators_interp->module~output_operators_base module~output_operators_base->module~field_manager module~output_operators_base->module~output_manager_core yaml_types yaml_types module~output_operators_base->yaml_types var panmoduleoutput_managerUsesGraph = svgPanZoom('#moduleoutput_managerUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables first_file files_initialized allow_missing_fields Interfaces output_manager_save Derived Types type_file_populator type_operator_populator type_group_populator type_variable_populator Functions in_window Subroutines output_manager_init output_manager_clean populate output_manager_start set_next_output output_manager_save1 output_manager_prepare_save output_manager_save2 configure_from_yaml output_manager_add_file process_file configure_group create_group_settings create_operator_settings create_variable_settings Variables Type Visibility Attributes Name Initial class( type_file ), private, pointer :: first_file logical, private :: files_initialized logical, public, save :: allow_missing_fields = .false. Interfaces public interface output_manager_save private subroutine output_manager_save1 (julianday, secondsofday, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: n private subroutine output_manager_save2 (julianday, secondsofday, microseconds, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds integer, intent(in) :: n Derived Types type, private, extends(type_dictionary_populator) :: type_file_populator Components Type Visibility Attributes Name Initial type( type_field_manager ), public, pointer :: fm => null() character(len=:), public, allocatable :: title character(len=:), public, allocatable :: postfix Type-Bound Procedures procedure, public :: create => process_file type, private, extends(type_list_populator) :: type_operator_populator Components Type Visibility Attributes Name Initial type( type_field_manager ), public, pointer :: field_manager => null() class( type_output_variable_settings ), public, pointer :: variable_settings => null() Type-Bound Procedures procedure, public :: create => create_operator_settings type, private, extends(type_list_populator) :: type_group_populator Components Type Visibility Attributes Name Initial class( type_file ), public, pointer :: file class( type_output_variable_settings ), public, pointer :: variable_settings => null() Type-Bound Procedures procedure, public :: create => create_group_settings type, private, extends(type_list_populator) :: type_variable_populator Components Type Visibility Attributes Name Initial class( type_file ), public, pointer :: file => null() class( type_output_variable_settings ), public, pointer :: variable_settings => null() Type-Bound Procedures procedure, public :: create => create_variable_settings Functions private function in_window (self, julianday, secondsofday, microseconds, n) Arguments Type Intent Optional Attributes Name class( type_file ), intent(in) :: self integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds integer, intent(in) :: n Return Value logical Subroutines public subroutine output_manager_init (field_manager, title, postfix, settings) Arguments Type Intent Optional Attributes Name type( type_field_manager ), target :: field_manager character(len=*), intent(in) :: title character(len=*), intent(in), optional :: postfix class(type_settings), optional pointer :: settings public subroutine output_manager_clean () Arguments None private subroutine populate (file) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: file public subroutine output_manager_start (julianday, secondsofday, microseconds, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds integer, intent(in) :: n private subroutine set_next_output (self, julianday, secondsofday, microseconds, n) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout) :: self integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds integer, intent(in) :: n private subroutine output_manager_save1 (julianday, secondsofday, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: n public subroutine output_manager_prepare_save (julianday, secondsofday, microseconds, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds integer, intent(in) :: n private subroutine output_manager_save2 (julianday, secondsofday, microseconds, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds integer, intent(in) :: n private subroutine configure_from_yaml (field_manager, title, postfix, settings) Arguments Type Intent Optional Attributes Name type( type_field_manager ), target :: field_manager character(len=*), intent(in) :: title character(len=*), intent(in), optional :: postfix class(type_settings), optional pointer :: settings public subroutine output_manager_add_file (field_manager, file) Arguments Type Intent Optional Attributes Name type( type_field_manager ), target :: field_manager class( type_file ), target :: file private subroutine process_file (self, pair) Arguments Type Intent Optional Attributes Name class( type_file_populator ), intent(inout) :: self type(type_key_value_pair), intent(inout) :: pair private recursive subroutine configure_group (file, settings, default_variable_settings) Arguments Type Intent Optional Attributes Name class( type_file ), intent(inout), target :: file class(type_settings), intent(inout) :: settings class( type_output_variable_settings ), intent(in), optional :: default_variable_settings private recursive subroutine create_group_settings (self, index, item) Arguments Type Intent Optional Attributes Name class( type_group_populator ), intent(inout) :: self integer, intent(in) :: index type(type_list_item), intent(inout) :: item private recursive subroutine create_operator_settings (self, index, item) Arguments Type Intent Optional Attributes Name class( type_operator_populator ), intent(inout) :: self integer, intent(in) :: index type(type_list_item), intent(inout) :: item private recursive subroutine create_variable_settings (self, index, item) Arguments Type Intent Optional Attributes Name class( type_variable_populator ), intent(inout) :: self integer, intent(in) :: index type(type_list_item), intent(inout) :: item","tags":"","loc":"module/output_manager.html"},{"title":"netcdf_output – Fortran Program","text":"Uses field_manager output_manager_core yaml_settings netcdf module~~netcdf_output~~UsesGraph module~netcdf_output netcdf_output module~field_manager field_manager module~netcdf_output->module~field_manager module~output_manager_core output_manager_core module~netcdf_output->module~output_manager_core netcdf netcdf module~netcdf_output->netcdf yaml_settings yaml_settings module~netcdf_output->yaml_settings iso_fortran_env iso_fortran_env module~field_manager->iso_fortran_env module~output_manager_core->module~field_manager module~output_manager_core->yaml_settings module~output_manager_core->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~netcdf_output~~UsedByGraph module~netcdf_output netcdf_output module~output_manager output_manager module~output_manager->module~netcdf_output Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables default_xtype default_coordinate_xtype Derived Types type_netcdf_file type_netcdf_variable_settings Functions put_att_typed_real create_settings Subroutines configure initialize save finalize check_err netcdf_variable_settings_initialize Variables Type Visibility Attributes Name Initial integer, public, save :: default_xtype = NF90_FLOAT integer, public, save :: default_coordinate_xtype = NF90_FLOAT Derived Types type, public, extends( type_file ) :: type_netcdf_file Components Type Visibility Attributes Name Initial type( type_field_manager ), public, pointer :: field_manager => null() character(len=max_path), public :: path = '' character(len=max_path), public :: postfix = '' character(len=string_length), public :: title = '' integer, public :: time_unit = time_unit_none integer, public :: time_step = 0 integer, public :: first_index = 0 integer, public :: next_julian = -1 integer, public :: next_seconds = -1 integer, public :: first_julian = -1 integer, public :: first_seconds = -1 integer, public :: last_julian = huge(1) integer, public :: last_seconds = 0 type( type_output_item ), public, pointer :: first_item => null() class( type_base_output_field ), public, pointer :: first_field => null() class( type_file ), public, pointer :: next => null() integer, public :: itime = 0 integer, public :: ncid = -1 integer, public :: time_id = -1 integer, public :: reference_julian = -1 integer, public :: reference_seconds = -1 integer, public :: sync_interval = 1 Type-Bound Procedures procedure, public :: is_dimension_used procedure, public :: append_item procedure, public :: configure procedure, public :: initialize procedure, public :: save procedure, public :: finalize procedure, public :: create_settings type, public, extends( type_output_variable_settings ) :: type_netcdf_variable_settings Components Type Visibility Attributes Name Initial integer, public :: time_method = time_method_instantaneous class( type_base_operator ), public, pointer :: final_operator => null() integer, public :: varid = -1 integer, public, allocatable :: start (:) integer, public, allocatable :: edges (:) integer, public :: itimedim = -1 integer, public :: xtype = -1 Type-Bound Procedures procedure, public :: initialize => netcdf_variable_settings_initialize Functions private function put_att_typed_real (ncid, varid, name, value, data_type) result(iret) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: varid character(len=*), intent(in) :: name real(kind=rk), intent(in) :: value integer, intent(in) :: data_type Return Value integer private function create_settings (self) result(settings) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self Return Value class( type_output_variable_settings ),\n  pointer Subroutines private subroutine configure (self, settings) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self class(type_settings), intent(inout) :: settings private subroutine initialize (self) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self private subroutine save (self, julianday, secondsofday, microseconds) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds private subroutine finalize (self) Arguments Type Intent Optional Attributes Name class( type_netcdf_file ), intent(inout) :: self private subroutine check_err (iret) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iret private subroutine netcdf_variable_settings_initialize (self, settings, parent) Arguments Type Intent Optional Attributes Name class( type_netcdf_variable_settings ), intent(inout) :: self class(type_settings), intent(inout) :: settings class( type_output_variable_settings ), intent(in), optional :: parent","tags":"","loc":"module/netcdf_output.html"},{"title":"text_output – Fortran Program","text":"Uses field_manager output_manager_core module~~text_output~~UsesGraph module~text_output text_output module~field_manager field_manager module~text_output->module~field_manager module~output_manager_core output_manager_core module~text_output->module~output_manager_core iso_fortran_env iso_fortran_env module~field_manager->iso_fortran_env module~output_manager_core->module~field_manager yaml_settings yaml_settings module~output_manager_core->yaml_settings module~output_manager_core->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~text_output~~UsedByGraph module~text_output text_output module~output_manager output_manager module~output_manager->module~text_output Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables separator extension Abstract Interfaces host_write_header host_write_data Derived Types type_single_text_file type_scalar type_single_text_file_with_scalars type_single_text_file_with_1d_variable type_text_file Functions get_free_unit Subroutines initialize save finalize single_text_file_with_scalars_write_header single_text_file_with_scalars_write_data single_text_file_with_1d_variable_write_header single_text_file_with_1d_variable_write_data Variables Type Visibility Attributes Name Initial character, private, parameter :: separator = char(9) character(len=4), private, parameter :: extension = '.txt' Abstract Interfaces abstract interface private subroutine host_write_header(self) Arguments Type Intent Optional Attributes Name class( type_single_text_file ), intent(in) :: self abstract interface private subroutine host_write_data(self, timestr) Arguments Type Intent Optional Attributes Name class( type_single_text_file ), intent(in) :: self character(len=*), intent(in) :: timestr Derived Types type, private, abstract :: type_single_text_file Components Type Visibility Attributes Name Initial character(len=max_path), public :: path = '' character(len=max_path), public :: title = '' integer, public :: unit = -1 class( type_single_text_file ), public, pointer :: next => null() Type-Bound Procedures procedure(host_write_header), public :: write_header procedure(host_write_data), public :: write_data type, private :: type_scalar Components Type Visibility Attributes Name Initial class( type_base_output_field ), public, pointer :: field => null() real(kind=rk), public, pointer :: value => null() type, private, extends( type_single_text_file ) :: type_single_text_file_with_scalars Components Type Visibility Attributes Name Initial character(len=max_path), public :: path = '' character(len=max_path), public :: title = '' integer, public :: unit = -1 class( type_single_text_file ), public, pointer :: next => null() type( type_scalar ), public, allocatable :: variables (:) type( type_scalar ), public, allocatable :: constants (:) Type-Bound Procedures procedure, public :: write_header => single_text_file_with_scalars_write_header procedure, public :: write_data => single_text_file_with_scalars_write_data type, private, extends( type_single_text_file ) :: type_single_text_file_with_1d_variable Components Type Visibility Attributes Name Initial character(len=max_path), public :: path = '' character(len=max_path), public :: title = '' integer, public :: unit = -1 class( type_single_text_file ), public, pointer :: next => null() class( type_base_output_field ), public, pointer :: field => null() type( type_dimension ), public, pointer :: dimension => null() class( type_base_output_field ), public, pointer :: coordinate => null() real(kind=rk), public, pointer :: values (:) => null() Type-Bound Procedures procedure, public :: write_header => single_text_file_with_1d_variable_write_header procedure, public :: write_data => single_text_file_with_1d_variable_write_data type, public, extends( type_file ) :: type_text_file Components Type Visibility Attributes Name Initial type( type_field_manager ), public, pointer :: field_manager => null() character(len=max_path), public :: path = '' character(len=max_path), public :: postfix = '' character(len=string_length), public :: title = '' integer, public :: time_unit = time_unit_none integer, public :: time_step = 0 integer, public :: first_index = 0 integer, public :: next_julian = -1 integer, public :: next_seconds = -1 integer, public :: first_julian = -1 integer, public :: first_seconds = -1 integer, public :: last_julian = huge(1) integer, public :: last_seconds = 0 type( type_output_item ), public, pointer :: first_item => null() class( type_base_output_field ), public, pointer :: first_field => null() class( type_file ), public, pointer :: next => null() class( type_single_text_file ), public, pointer :: first_file => null() Type-Bound Procedures procedure, public :: configure procedure, public :: create_settings procedure, public :: is_dimension_used procedure, public :: append_item procedure, public :: initialize procedure, public :: save procedure, public :: finalize Functions private function get_free_unit (start, stop) result(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: start integer, intent(in) :: stop Return Value integer Subroutines private subroutine initialize (self) Arguments Type Intent Optional Attributes Name class( type_text_file ), intent(inout) :: self private subroutine save (self, julianday, secondsofday, microseconds) Arguments Type Intent Optional Attributes Name class( type_text_file ), intent(inout) :: self integer, intent(in) :: julianday integer, intent(in) :: secondsofday integer, intent(in) :: microseconds private subroutine finalize (self) Arguments Type Intent Optional Attributes Name class( type_text_file ), intent(inout) :: self private subroutine single_text_file_with_scalars_write_header (self) Arguments Type Intent Optional Attributes Name class( type_single_text_file_with_scalars ), intent(in) :: self private subroutine single_text_file_with_scalars_write_data (self, timestr) Arguments Type Intent Optional Attributes Name class( type_single_text_file_with_scalars ), intent(in) :: self character(len=*), intent(in) :: timestr private subroutine single_text_file_with_1d_variable_write_header (self) Arguments Type Intent Optional Attributes Name class( type_single_text_file_with_1d_variable ), intent(in) :: self private subroutine single_text_file_with_1d_variable_write_data (self, timestr) Arguments Type Intent Optional Attributes Name class( type_single_text_file_with_1d_variable ), intent(in) :: self character(len=*), intent(in) :: timestr","tags":"","loc":"module/text_output.html"},{"title":"output_operators_time_average – Fortran Program","text":"Uses output_manager_core field_manager output_operators_base module~~output_operators_time_average~~UsesGraph module~output_operators_time_average output_operators_time_average module~output_manager_core output_manager_core module~output_operators_time_average->module~output_manager_core module~field_manager field_manager module~output_operators_time_average->module~field_manager module~output_operators_base output_operators_base module~output_operators_time_average->module~output_operators_base module~output_manager_core->module~field_manager yaml_settings yaml_settings module~output_manager_core->yaml_settings iso_fortran_env iso_fortran_env module~output_manager_core->iso_fortran_env module~field_manager->iso_fortran_env module~output_operators_base->module~output_manager_core module~output_operators_base->module~field_manager yaml_types yaml_types module~output_operators_base->yaml_types var panmoduleoutput_operators_time_averageUsesGraph = svgPanZoom('#moduleoutput_operators_time_averageUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~output_operators_time_average~~UsedByGraph module~output_operators_time_average output_operators_time_average module~output_manager output_manager module~output_manager->module~output_operators_time_average module~output_operators_library output_operators_library module~output_manager->module~output_operators_library module~output_operators_library->module~output_operators_time_average Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types type_time_average_operator type_result Functions apply Subroutines flag_as_required new_data before_save get_metadata Derived Types type, public, extends( type_base_operator ) :: type_time_average_operator Components Type Visibility Attributes Name Initial class( type_base_operator ), public, pointer :: previous => null() integer, public :: method = time_method_mean Type-Bound Procedures procedure, public :: configure => operator_configure procedure, public :: apply_all => operator_apply_all procedure, public :: apply type, private, extends( type_universal_operator_result ) :: type_result Components Type Visibility Attributes Name Initial class( type_output_variable_settings ), public, pointer :: settings => null() character(len=string_length), public :: output_name = '' logical, public :: is_coordinate = .false. type( type_nd_data_pointer ), public :: data type( type_output_field_pointer ), public, allocatable :: coordinates (:) class( type_base_output_field ), public, pointer :: next => null() class( type_base_operator ), public, pointer :: operator => null() class( type_base_output_field ), public, pointer :: source => null() real(kind=rk), public :: result_0d real(kind=rk), public, allocatable :: result_1d (:) real(kind=rk), public, allocatable :: result_2d (:,:) real(kind=rk), public, allocatable :: result_3d (:,:,:) type( type_dimension_pointer ), public, allocatable :: dimensions (:) integer, public :: method = time_method_mean integer, public :: n = 0 Type-Bound Procedures procedure, public :: fill procedure, public :: get_field => universal_get_field procedure, public :: flag_as_required procedure, public :: new_data procedure, public :: before_save procedure, public :: get_metadata Functions private function apply (self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_time_average_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer Subroutines private recursive subroutine flag_as_required (self, required) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self logical, intent(in) :: required private recursive subroutine new_data (self) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self private recursive subroutine before_save (self) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self private recursive subroutine get_metadata (self, long_name, units, dimensions, minimum, maximum, fill_value, standard_name, path, attributes) Arguments Type Intent Optional Attributes Name class( type_result ), intent(in) :: self character(len=:), intent(out), optional allocatable :: long_name character(len=:), intent(out), optional allocatable :: units type( type_dimension_pointer ), intent(out), optional allocatable :: dimensions (:) real(kind=rk), intent(out), optional :: minimum real(kind=rk), intent(out), optional :: maximum real(kind=rk), intent(out), optional :: fill_value character(len=:), intent(out), optional allocatable :: standard_name character(len=:), intent(out), optional allocatable :: path type( type_attributes ), intent(out), optional :: attributes","tags":"","loc":"module/output_operators_time_average.html"},{"title":"output_operators_interp – Fortran Program","text":"Uses output_manager_core field_manager yaml_settings output_operators_base module~~output_operators_interp~~UsesGraph module~output_operators_interp output_operators_interp module~output_manager_core output_manager_core module~output_operators_interp->module~output_manager_core module~field_manager field_manager module~output_operators_interp->module~field_manager yaml_settings yaml_settings module~output_operators_interp->yaml_settings module~output_operators_base output_operators_base module~output_operators_interp->module~output_operators_base module~output_manager_core->module~field_manager module~output_manager_core->yaml_settings iso_fortran_env iso_fortran_env module~output_manager_core->iso_fortran_env module~field_manager->iso_fortran_env module~output_operators_base->module~output_manager_core module~output_operators_base->module~field_manager yaml_types yaml_types module~output_operators_base->yaml_types var panmoduleoutput_operators_interpUsesGraph = svgPanZoom('#moduleoutput_operators_interpUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~output_operators_interp~~UsedByGraph module~output_operators_interp output_operators_interp module~output_operators_library output_operators_library module~output_operators_library->module~output_operators_interp module~output_manager output_manager module~output_manager->module~output_operators_library Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types type_interp_operator type_result type_coordinate_list_populator Functions apply get_field Subroutines configure coordinate_list_set_length coordinate_list_create_element flag_as_required before_save interp Derived Types type, public, extends( type_base_operator ) :: type_interp_operator Components Type Visibility Attributes Name Initial class( type_base_operator ), public, pointer :: previous => null() character(len=string_length), public :: dimension character(len=string_length), public :: target_dimension_name character(len=string_length), public :: target_long_name character(len=string_length), public :: target_standard_name real(kind=rk), public, allocatable :: target_coordinates (:) type( type_field ), public, pointer :: source_field => null() type( type_field ), public, pointer :: offset_field => null() integer, public :: out_of_bounds_treatment = 1 real(kind=rk), public :: offset_scale = 1._rk type( type_dimension ), public, pointer :: target_dimension => null() Type-Bound Procedures procedure, public :: apply_all => operator_apply_all procedure, public :: configure procedure, public :: apply type, private, extends( type_operator_result ) :: type_result Components Type Visibility Attributes Name Initial class( type_output_variable_settings ), public, pointer :: settings => null() character(len=string_length), public :: output_name = '' logical, public :: is_coordinate = .false. type( type_nd_data_pointer ), public :: data type( type_output_field_pointer ), public, allocatable :: coordinates (:) class( type_base_output_field ), public, pointer :: next => null() class( type_base_operator ), public, pointer :: operator => null() class( type_base_output_field ), public, pointer :: source => null() real(kind=rk), public :: result_0d real(kind=rk), public, allocatable :: result_1d (:) real(kind=rk), public, allocatable :: result_2d (:,:) real(kind=rk), public, allocatable :: result_3d (:,:,:) type( type_dimension_pointer ), public, allocatable :: dimensions (:) integer, public :: idim = -1 integer, public :: idatadim = -1 class( type_base_output_field ), public, pointer :: source_coordinate => null() class( type_base_output_field ), public, pointer :: offset => null() integer, public :: out_of_bounds_treatment = 1 real(kind=rk), public :: out_of_bounds_value real(kind=rk), public, allocatable :: target_coordinates (:) real(kind=rk), public :: offset_scale = 1._rk Type-Bound Procedures procedure, public :: new_data procedure, public :: get_metadata procedure, public :: fill procedure, public :: flag_as_required procedure, public :: before_save procedure, public :: get_field type, private, extends(type_list_populator) :: type_coordinate_list_populator Components Type Visibility Attributes Name Initial class( type_interp_operator ), public, pointer :: operator => null() Type-Bound Procedures procedure, public :: set_length => coordinate_list_set_length procedure, public :: create => coordinate_list_create_element Functions private function apply (self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_interp_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer private recursive function get_field (self, field) result(output_field) Arguments Type Intent Optional Attributes Name class( type_result ), intent(in) :: self type( type_field ), target :: field Return Value class( type_base_output_field ),\n  pointer Subroutines private subroutine configure (self, settings, field_manager) Arguments Type Intent Optional Attributes Name class( type_interp_operator ), intent(inout), target :: self class(type_settings), intent(inout) :: settings type( type_field_manager ), intent(inout) :: field_manager private recursive subroutine coordinate_list_set_length (self, n) Arguments Type Intent Optional Attributes Name class( type_coordinate_list_populator ), intent(inout) :: self integer, intent(in) :: n private recursive subroutine coordinate_list_create_element (self, index, item) Arguments Type Intent Optional Attributes Name class( type_coordinate_list_populator ), intent(inout) :: self integer, intent(in) :: index type(type_list_item), intent(inout) :: item private recursive subroutine flag_as_required (self, required) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self logical, intent(in) :: required private recursive subroutine before_save (self) Arguments Type Intent Optional Attributes Name class( type_result ), intent(inout) :: self private subroutine interp (x, xp, fp, f, out_of_bounds_treatment, out_of_bounds_value) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (:) real(kind=rk), intent(in) :: xp (:) real(kind=rk), intent(in) :: fp (:) real(kind=rk), intent(out) :: f (:) integer, intent(in) :: out_of_bounds_treatment real(kind=rk), intent(in) :: out_of_bounds_value","tags":"","loc":"module/output_operators_interp.html"},{"title":"output_operators_library – Fortran Program","text":"Uses field_manager yaml_settings output_manager_core output_operators_base output_operators_interp output_operators_time_average output_operators_slice module~~output_operators_library~~UsesGraph module~output_operators_library output_operators_library module~output_operators_base output_operators_base module~output_operators_library->module~output_operators_base module~output_operators_interp output_operators_interp module~output_operators_library->module~output_operators_interp module~field_manager field_manager module~output_operators_library->module~field_manager module~output_manager_core output_manager_core module~output_operators_library->module~output_manager_core module~output_operators_time_average output_operators_time_average module~output_operators_library->module~output_operators_time_average yaml_settings yaml_settings module~output_operators_library->yaml_settings module~output_operators_slice output_operators_slice module~output_operators_library->module~output_operators_slice module~output_operators_base->module~field_manager module~output_operators_base->module~output_manager_core yaml_types yaml_types module~output_operators_base->yaml_types module~output_operators_interp->module~output_operators_base module~output_operators_interp->module~field_manager module~output_operators_interp->module~output_manager_core module~output_operators_interp->yaml_settings iso_fortran_env iso_fortran_env module~field_manager->iso_fortran_env module~output_manager_core->module~field_manager module~output_manager_core->yaml_settings module~output_manager_core->iso_fortran_env module~output_operators_time_average->module~output_operators_base module~output_operators_time_average->module~field_manager module~output_operators_time_average->module~output_manager_core module~output_operators_slice->module~output_operators_base module~output_operators_slice->module~field_manager module~output_operators_slice->module~output_manager_core var panmoduleoutput_operators_libraryUsesGraph = svgPanZoom('#moduleoutput_operators_libraryUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~output_operators_library~~UsedByGraph module~output_operators_library output_operators_library module~output_manager output_manager module~output_manager->module~output_operators_library Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines apply_operator Subroutines public subroutine apply_operator (final_operator, settings, field_manager) Arguments Type Intent Optional Attributes Name class( type_base_operator ), pointer :: final_operator class(type_settings), intent(inout) :: settings type( type_field_manager ), intent(inout) :: field_manager","tags":"","loc":"module/output_operators_library.html"},{"title":"output_operators_slice – Fortran Program","text":"Uses output_manager_core field_manager output_operators_base module~~output_operators_slice~~UsesGraph module~output_operators_slice output_operators_slice module~output_manager_core output_manager_core module~output_operators_slice->module~output_manager_core module~field_manager field_manager module~output_operators_slice->module~field_manager module~output_operators_base output_operators_base module~output_operators_slice->module~output_operators_base module~output_manager_core->module~field_manager yaml_settings yaml_settings module~output_manager_core->yaml_settings iso_fortran_env iso_fortran_env module~output_manager_core->iso_fortran_env module~field_manager->iso_fortran_env module~output_operators_base->module~output_manager_core module~output_operators_base->module~field_manager yaml_types yaml_types module~output_operators_base->yaml_types var panmoduleoutput_operators_sliceUsesGraph = svgPanZoom('#moduleoutput_operators_sliceUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~output_operators_slice~~UsedByGraph module~output_operators_slice output_operators_slice module~output_manager output_manager module~output_manager->module~output_operators_slice module~output_operators_library output_operators_library module~output_manager->module~output_operators_library module~output_operators_library->module~output_operators_slice Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types type_single_dimension_slice type_slice_operator Functions apply Subroutines add find_local_range Derived Types type, private :: type_single_dimension_slice Components Type Visibility Attributes Name Initial character(len=string_length), public :: dimension integer, public :: global_start = 1 integer, public :: global_stop = -1 integer, public :: stride = 1 type( type_single_dimension_slice ), public, pointer :: next => null() type, public, extends( type_base_operator ) :: type_slice_operator Components Type Visibility Attributes Name Initial class( type_base_operator ), public, pointer :: previous => null() type( type_single_dimension_slice ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: configure => operator_configure procedure, public :: apply_all => operator_apply_all procedure, public :: apply procedure, public :: add Functions private function apply (self, source) result(output_field) Arguments Type Intent Optional Attributes Name class( type_slice_operator ), intent(inout), target :: self class( type_base_output_field ), target :: source Return Value class( type_base_output_field ),\n  pointer Subroutines private subroutine add (self, dimension, start, stop, stride) Arguments Type Intent Optional Attributes Name class( type_slice_operator ), intent(inout) :: self character(len=*), intent(in) :: dimension integer, intent(in) :: start integer, intent(in) :: stop integer, intent(in) :: stride private subroutine find_local_range (global_start, global_stop, local_offset, local_length, stride, local_start, local_stop) Arguments Type Intent Optional Attributes Name integer, intent(in) :: global_start integer, intent(in) :: global_stop integer, intent(in) :: local_offset integer, intent(in) :: local_length integer, intent(in) :: stride integer, intent(out) :: local_start integer, intent(out) :: local_stop","tags":"","loc":"module/output_operators_slice.html"},{"title":"output_operators_base – Fortran Program","text":"Uses output_manager_core field_manager yaml_types module~~output_operators_base~~UsesGraph module~output_operators_base output_operators_base module~output_manager_core output_manager_core module~output_operators_base->module~output_manager_core module~field_manager field_manager module~output_operators_base->module~field_manager yaml_types yaml_types module~output_operators_base->yaml_types module~output_manager_core->module~field_manager yaml_settings yaml_settings module~output_manager_core->yaml_settings iso_fortran_env iso_fortran_env module~output_manager_core->iso_fortran_env module~field_manager->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~output_operators_base~~UsedByGraph module~output_operators_base output_operators_base module~output_operators_slice output_operators_slice module~output_operators_slice->module~output_operators_base module~output_operators_library output_operators_library module~output_operators_library->module~output_operators_base module~output_operators_library->module~output_operators_slice module~output_operators_interp output_operators_interp module~output_operators_library->module~output_operators_interp module~output_operators_time_average output_operators_time_average module~output_operators_library->module~output_operators_time_average module~output_operators_interp->module~output_operators_base module~output_operators_time_average->module~output_operators_base module~output_manager output_manager module~output_manager->module~output_operators_slice module~output_manager->module~output_operators_library module~output_manager->module~output_operators_time_average Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types type_operator_result type_universal_operator_result Functions get_field universal_get_field Subroutines new_data before_save get_metadata flag_as_required fill Derived Types type, public, extends( type_base_output_field ) :: type_operator_result Components Type Visibility Attributes Name Initial class( type_output_variable_settings ), public, pointer :: settings => null() character(len=string_length), public :: output_name = '' logical, public :: is_coordinate = .false. type( type_nd_data_pointer ), public :: data type( type_output_field_pointer ), public, allocatable :: coordinates (:) class( type_base_output_field ), public, pointer :: next => null() class( type_base_operator ), public, pointer :: operator => null() class( type_base_output_field ), public, pointer :: source => null() real(kind=rk), public :: result_0d real(kind=rk), public, allocatable :: result_1d (:) real(kind=rk), public, allocatable :: result_2d (:,:) real(kind=rk), public, allocatable :: result_3d (:,:,:) type( type_dimension_pointer ), public, allocatable :: dimensions (:) Type-Bound Procedures procedure, public :: new_data procedure, public :: before_save procedure, public :: get_metadata procedure, public :: flag_as_required procedure, public :: fill procedure, public :: get_field type, public, extends( type_operator_result ) :: type_universal_operator_result Components Type Visibility Attributes Name Initial class( type_output_variable_settings ), public, pointer :: settings => null() character(len=string_length), public :: output_name = '' logical, public :: is_coordinate = .false. type( type_nd_data_pointer ), public :: data type( type_output_field_pointer ), public, allocatable :: coordinates (:) class( type_base_output_field ), public, pointer :: next => null() class( type_base_operator ), public, pointer :: operator => null() class( type_base_output_field ), public, pointer :: source => null() real(kind=rk), public :: result_0d real(kind=rk), public, allocatable :: result_1d (:) real(kind=rk), public, allocatable :: result_2d (:,:) real(kind=rk), public, allocatable :: result_3d (:,:,:) type( type_dimension_pointer ), public, allocatable :: dimensions (:) Type-Bound Procedures procedure, public :: new_data procedure, public :: before_save procedure, public :: get_metadata procedure, public :: flag_as_required procedure, public :: fill procedure, public :: get_field => universal_get_field Functions private recursive function get_field (self, field) result(output_field) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(in) :: self type( type_field ), target :: field Return Value class( type_base_output_field ),\n  pointer private recursive function universal_get_field (self, field) result(output_field) Arguments Type Intent Optional Attributes Name class( type_universal_operator_result ), intent(in) :: self type( type_field ), target :: field Return Value class( type_base_output_field ),\n  pointer Subroutines private recursive subroutine new_data (self) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self private recursive subroutine before_save (self) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self private recursive subroutine get_metadata (self, long_name, units, dimensions, minimum, maximum, fill_value, standard_name, path, attributes) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(in) :: self character(len=:), intent(out), optional allocatable :: long_name character(len=:), intent(out), optional allocatable :: units type( type_dimension_pointer ), intent(out), optional allocatable :: dimensions (:) real(kind=rk), intent(out), optional :: minimum real(kind=rk), intent(out), optional :: maximum real(kind=rk), intent(out), optional :: fill_value character(len=:), intent(out), optional allocatable :: standard_name character(len=:), intent(out), optional allocatable :: path type( type_attributes ), intent(out), optional :: attributes private recursive subroutine flag_as_required (self, required) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self logical, intent(in) :: required private subroutine fill (self, value) Arguments Type Intent Optional Attributes Name class( type_operator_result ), intent(inout) :: self real(kind=rk), intent(in) :: value","tags":"","loc":"module/output_operators_base.html"}]}