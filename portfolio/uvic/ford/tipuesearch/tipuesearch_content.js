var tipuesearch = {"pages":[{"title":" FABM in UVic ","text":"FABM in UVic Developer Info Karsten Bolding,\nNicolas Schnedler-Meyer and\nJorn Bruggeman","tags":"home","loc":"index.html"},{"title":"fabm_configure – FABM in UVic","text":"public  subroutine fabm_configure(dt, yaml_file) read fabm.yaml and call FABM configuration subroutines Note seems tmask is not initialised until called in mom() -\ni.e. after initialization - so all values are 0 here Arguments Type Intent Optional Attributes Name real(kind=rke), intent(in) :: dt bio-geochemical time step as set by MOM2 [s] character(len=*), intent(in), optional :: yaml_file name of alternativ FABM configuration file Calls proc~~fabm_configure~~CallsGraph proc~fabm_configure uvic_fabm::fabm_configure fabm_create_model fabm_create_model proc~fabm_configure->fabm_create_model set_bottom_index set_bottom_index proc~fabm_configure->set_bottom_index set_domain set_domain proc~fabm_configure->set_domain set_domain_start set_domain_start proc~fabm_configure->set_domain_start set_domain_stop set_domain_stop proc~fabm_configure->set_domain_stop set_mask set_mask proc~fabm_configure->set_mask tmask tmask proc~fabm_configure->tmask Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fabm_configure ( dt , yaml_file ) !! read fabm.yaml and call FABM configuration subroutines real ( rke ), intent ( in ) :: dt !! bio-geochemical time step as set by MOM2 [s] character ( len =* ), intent ( in ), optional :: yaml_file !! name of alternativ FABM configuration file integer :: n print * , '==> Initializing FABM with (nt, nsrc, numbsc) =' , & nt , nsrc , numsbc if ( present ( yaml_file )) then model => fabm_create_model ( trim ( yaml_file )) else model => fabm_create_model ( 'fabm.yaml' ) end if nsurface = size ( model % surface_state_variables ) npelagic = size ( model % interior_state_variables ) nbottom = size ( model % bottom_state_variables ) if ( nfabm . ne . npelagic ) then print * , 'nt (UVic)     = ' , nt print * , 'nsrc (UVic)   = ' , nsrc print * , 'numsbc (UVic) = ' , numsbc print * , 'nsurface      = ' , nsurface print * , 'npelagic      = ' , npelagic print * , 'nbottom       = ' , nbottom stop 'fabm_configure()' end if #ifdef DEBUG print * , imt , jmt , jmw !print*, jrow,js,je,is,ie print * , 'zt: ' , shape ( zt ) print * , 't: ' , shape ( t ) print * , 'sbc: ' , shape ( sbc ) print * , 'src: ' , shape ( src ) ! imt,km,jsmw:jemw,nsrc print * , 'source: ' , shape ( source ) ! imt,km,jsmw:jemw print * , 'rho: ' , shape ( rho ) !stop 112 #endif call model % set_domain ( imt , km , jmt , dt ) call model % set_domain_start ( 2 , 1 , 2 ) call model % set_domain_stop ( imt - 1 , km , jmt - 1 ) call model % set_mask ( tmask , tmask (:, 1 ,:)) call model % set_bottom_index ( kmt ) !! @note !! seems tmask is not initialised until called in mom() - !! i.e. after initialization - so all values are 0 here !! @endnote end subroutine fabm_configure","tags":"","loc":"proc/fabm_configure.html"},{"title":"fabm_sbc_init – FABM in UVic","text":"public  subroutine fabm_sbc_init(m) surface boundary data are handled via sbc(imt,jmt,numsbc) in\nsetmom.F, tracer.F, gosbc.F, embmio.F Arguments Type Intent Optional Attributes Name integer, intent(inout) :: m number of handled variables handled so far Calls proc~~fabm_sbc_init~~CallsGraph proc~fabm_sbc_init uvic_fabm::fabm_sbc_init interior_state_variables interior_state_variables proc~fabm_sbc_init->interior_state_variables mapsbc mapsbc proc~fabm_sbc_init->mapsbc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fabm_sbc_init ( m ) !! surface boundary data are handled via sbc(imt,jmt,numsbc) in !! setmom.F, tracer.F, gosbc.F, embmio.F integer , intent ( inout ) :: m !! number of handled variables handled so far integer :: n , nn associate ( VAR => model % interior_state_variables ) nn = m do n = 1 , size ( model % interior_state_variables ) mapsbc ( nn ) = 'ss' // trim ( VAR ( n )% name ) mapsbc ( nn + 1 ) = trim ( VAR ( n )% name ) // 'flx' nn = nn + 2 !mapsbc(m+n) = m+n end do end associate m = m + 2 * numsbc_fabm end subroutine fabm_sbc_init","tags":"","loc":"proc/fabm_sbc_init.html"},{"title":"fabm_tracer_init – FABM in UVic","text":"public  subroutine fabm_tracer_init(m) surface boundary data are handled via sbc(imt,jmt,numsbc) in\nsetmom.F, tracer.F, gosbc.F, embmio.F Arguments Type Intent Optional Attributes Name integer, intent(inout) :: m number of handled variables handled so far Calls proc~~fabm_tracer_init~~CallsGraph proc~fabm_tracer_init uvic_fabm::fabm_tracer_init interior_state_variables interior_state_variables proc~fabm_tracer_init->interior_state_variables itrc itrc proc~fabm_tracer_init->itrc mapst mapst proc~fabm_tracer_init->mapst mapt mapt proc~fabm_tracer_init->mapt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fabm_tracer_init ( m ) !! surface boundary data are handled via sbc(imt,jmt,numsbc) in !! setmom.F, tracer.F, gosbc.F, embmio.F integer , intent ( inout ) :: m !! number of handled variables handled so far integer :: n ! need to get mapt populated early - setmom() -> mom_rest_in() associate ( VAR => model % interior_state_variables ) !KB         print*, 'AAA ', mapt do n = 1 , size ( model % interior_state_variables ) mapt ( m + n ) = trim ( VAR ( n )% name ) mapst ( m + n - 4 ) = 's' // trim ( VAR ( n )% name ) itrc ( m + n - 4 ) = m + n end do #if 0 print * , 'AAA ' , mapt print * , mapst stop 'kaj' #endif end associate end subroutine fabm_tracer_init","tags":"","loc":"proc/fabm_tracer_init.html"},{"title":"rowi_fabm – FABM in UVic","text":"private  subroutine rowi_fabm() this is done in fabm_initialize_state() - but check !!KB\nsetmom.F - if (.not. init) then - around line 299 Arguments None Source Code subroutine rowi_fabm () !! this is done in fabm_initialize_state() - but check !!KB !! setmom.F - if (.not. init) then - around line 299 integer :: n associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic !   t(:,:,:,n,1) = VAR(n)%c0 end do end associate end subroutine rowi_fabm","tags":"","loc":"proc/rowi_fabm.html"},{"title":"fabm_rest_in – FABM in UVic","text":"public  subroutine fabm_rest_in(iou, ln, ib, ic, tmpik, ils, ile, kls, kle, tau) reading FABM restart variables from NetCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: iou NetCDF file id integer, intent(in) :: ln data length integer, intent(in) :: ib (:) array of start indices integer, intent(in) :: ic (:) array of counts real, intent(inout) :: tmpik (ils:ile,kls:kle) array for present data slice integer, intent(in) :: ils start index - i integer, intent(in) :: ile end index - i integer, intent(in) :: kls start index - k integer, intent(in) :: kle end index - k integer, intent(in) :: tau time index - -1:1 Calls proc~~fabm_rest_in~~CallsGraph proc~fabm_rest_in uvic_fabm::fabm_rest_in getvara getvara proc~fabm_rest_in->getvara interior_state_variables interior_state_variables proc~fabm_rest_in->interior_state_variables t t proc~fabm_rest_in->t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fabm_rest_in ( iou , ln , ib , ic , tmpik , ils , ile , kls , kle , tau ) !! reading FABM restart variables from NetCDF integer , intent ( in ) :: iou !! NetCDF file id integer , intent ( in ) :: ln !! data length integer , intent ( in ) :: ib (:) !! array of start indices integer , intent ( in ) :: ic (:) !! array of counts real , intent ( inout ) :: tmpik ( ils : ile , kls : kle ) !! array for present data slice integer , intent ( in ) :: ils !! start index - i integer , intent ( in ) :: ile !! end index - i integer , intent ( in ) :: kls !! start index - k integer , intent ( in ) :: kle !! end index - k integer , intent ( in ) :: tau !! time index - -1:1 real , parameter :: c0 = 0. real , parameter :: c1 = 1. character ( 1 ) :: x ! to distinguise between tau and taup1 integer :: j ! j row slice integer :: n ! counter if ( tau == 0 ) x = '1' if ( tau == 1 ) x = '2' j = ib ( 2 ) associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic tmpik ( ils : ile , kls : kle ) = t ( ils : ile , kls : kle , j , n , tau ) call getvara ( trim ( VAR ( n )% name ) // x , iou , ln , ib , ic , & tmpik , c1 , c0 ) t ( ils : ile , kls : kle , j , n , tau ) = tmpik ( ils : ile , kls : kle ) end do end associate end subroutine fabm_rest_in","tags":"","loc":"proc/fabm_rest_in.html"},{"title":"fabm_rest_def – FABM in UVic","text":"public  subroutine fabm_rest_def(iou, it) define FABM restart variables in NetCDF context Arguments Type Intent Optional Attributes Name integer, intent(in) :: iou NetCDF file id integer, intent(in) :: it (:) time dimension Calls proc~~fabm_rest_def~~CallsGraph proc~fabm_rest_def uvic_fabm::fabm_rest_def defvar defvar proc~fabm_rest_def->defvar interior_state_variables interior_state_variables proc~fabm_rest_def->interior_state_variables Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fabm_rest_def ( iou , it ) !! define FABM restart variables in NetCDF context integer , intent ( in ) :: iou !! NetCDF file id integer , intent ( in ) :: it (:) !! time dimension integer :: n associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic call defvar ( trim ( VAR ( n )% name ) // '1' , iou , 4 , it , & VAR ( n )% minimum , VAR ( n )% maximum , ' ' , 'D' , & trim ( VAR ( n )% long_name ) // ' at tau' , ' ' , & trim ( VAR ( n )% units )) call defvar ( trim ( VAR ( n )% name ) // '2' , iou , 4 , it , & VAR ( n )% minimum , VAR ( n )% maximum , ' ' , 'D' , & trim ( VAR ( n )% long_name ) // ' at tau+1' , ' ' , & trim ( VAR ( n )% units )) end do end associate end subroutine fabm_rest_def","tags":"","loc":"proc/fabm_rest_def.html"},{"title":"fabm_rest_out – FABM in UVic","text":"public  subroutine fabm_rest_out(iou, ln, ib, ic, tmpik, ils, ile, kls, kle, tau) save 4D data to the NetCDF file given by iou Arguments Type Intent Optional Attributes Name integer, intent(in) :: iou NetCDF file id integer, intent(in) :: ln data length integer, intent(in) :: ib (:) array of start indices integer, intent(in) :: ic (:) array of counts real, intent(inout) :: tmpik (ils:ile,kls:kle) mask array for present data slice integer, intent(in) :: ils start index - i integer, intent(in) :: ile end index - i integer, intent(in) :: kls start index - k integer, intent(in) :: kle end index - k integer, intent(in) :: tau time index - -1:1 Calls proc~~fabm_rest_out~~CallsGraph proc~fabm_rest_out uvic_fabm::fabm_rest_out interior_state_variables interior_state_variables proc~fabm_rest_out->interior_state_variables putvara putvara proc~fabm_rest_out->putvara t t proc~fabm_rest_out->t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fabm_rest_out ( iou , ln , ib , ic , tmpik , ils , ile , kls , kle , tau ) !! save 4D data to the NetCDF file given by iou integer , intent ( in ) :: iou !! NetCDF file id integer , intent ( in ) :: ln !! data length integer , intent ( in ) :: ib (:) !! array of start indices integer , intent ( in ) :: ic (:) !! array of counts real , intent ( inout ) :: tmpik ( ils : ile , kls : kle ) !! mask array for present data slice integer , intent ( in ) :: ils !! start index - i integer , intent ( in ) :: ile !! end index - i integer , intent ( in ) :: kls !! start index - k integer , intent ( in ) :: kle !! end index - k integer , intent ( in ) :: tau !! time index - -1:1 real , parameter :: c0 = 0. real , parameter :: c1 = 1. character ( 1 ) :: x ! to distinguise between tau and taup1 integer :: j ! j row slice integer :: n ! counter if ( tau == 0 ) x = '1' if ( tau == 1 ) x = '2' j = ib ( 2 ) associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic ! j row slice tmpik ( ils : ile , kls : kle ) = t ( ils : ile , kls : kle , j , n , tau ) call putvara ( trim ( VAR ( n )% name ) // x , iou , ln , ib , ic , & tmpik , c1 , c0 ) end do end associate end subroutine fabm_rest_out","tags":"","loc":"proc/fabm_rest_out.html"},{"title":"ta_fabm_tsi – FABM in UVic","text":"public  subroutine ta_fabm_tsi(m, ntatio, tbar) define FABM variables in NetCDF context Arguments Type Intent Optional Attributes Name integer, intent(in) :: m switch operations integer, intent(in), optional :: ntatio switch operations real, intent(in), optional :: tbar (:) slice of UVic maintained temporary variable Calls proc~~ta_fabm_tsi~~CallsGraph proc~ta_fabm_tsi uvic_fabm::ta_fabm_tsi float float proc~ta_fabm_tsi->float Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine ta_fabm_tsi ( m , ntatio , tbar ) !! define FABM variables in NetCDF context integer , intent ( in ) :: m !! switch operations integer , intent ( in ), optional :: ntatio !! switch operations real , intent ( in ), optional :: tbar (:) !! slice of UVic maintained temporary variable integer :: n real :: rntatio if ( m . eq . 0 ) then ! initialize tai_fabm = 0. else if ( m . eq . 1 ) then ! accumulate tai_fabm (:) = tai_fabm (:) + tbar (:) else if ( m . eq . 2 . and . ntatio . ne . 0 ) then rntatio = 1. / float ( ntatio ) tai_fabm (:) = tai_fabm (:) * rntatio end if end subroutine ta_fabm_tsi","tags":"","loc":"proc/ta_fabm_tsi.html"},{"title":"fabm_tsi_def – FABM in UVic","text":"public  subroutine fabm_tsi_def(iou, id) define FABM time series variables in NetCDF context Arguments Type Intent Optional Attributes Name integer, intent(in) :: iou NetCDF file id integer, intent(in) :: id (1) time dimension Calls proc~~fabm_tsi_def~~CallsGraph proc~fabm_tsi_def uvic_fabm::fabm_tsi_def defvar defvar proc~fabm_tsi_def->defvar interior_state_variables interior_state_variables proc~fabm_tsi_def->interior_state_variables Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fabm_tsi_def ( iou , id ) !! define FABM time series variables in NetCDF context integer , intent ( in ) :: iou !! NetCDF file id integer , intent ( in ) :: id ( 1 ) !! time dimension integer :: n associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic call defvar ( 'O_' // trim ( VAR ( n )% name ), iou , 1 , id , & VAR ( n )% minimum , VAR ( n )% maximum , ' ' , 'F' , & trim ( VAR ( n )% long_name ), ' ' , trim ( VAR ( n )% units )) end do end associate end subroutine fabm_tsi_def","tags":"","loc":"proc/fabm_tsi_def.html"},{"title":"fabm_tsi_out – FABM in UVic","text":"public  subroutine fabm_tsi_out(iou, ntrec) define FABM variables in NetCDF context Arguments Type Intent Optional Attributes Name integer, intent(in) :: iou NetCDF file id integer, intent(in) :: ntrec time record Calls proc~~fabm_tsi_out~~CallsGraph proc~fabm_tsi_out uvic_fabm::fabm_tsi_out interior_state_variables interior_state_variables proc~fabm_tsi_out->interior_state_variables putvars putvars proc~fabm_tsi_out->putvars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fabm_tsi_out ( iou , ntrec ) !! define FABM variables in NetCDF context integer , intent ( in ) :: iou !! NetCDF file id integer , intent ( in ) :: ntrec !! time record integer :: n real , parameter :: c0 = 0. real , parameter :: c1 = 1. associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic call putvars ( 'O_' // trim ( VAR ( n )% name ), iou , ntrec , & tai_fabm ( n ), c1 , c0 ) end do end associate end subroutine fabm_tsi_out","tags":"","loc":"proc/fabm_tsi_out.html"},{"title":"fabm_tavg_def_4d – FABM in UVic","text":"public  subroutine fabm_tavg_def_4d(iou, it) define FABM variables in NetCDF context Arguments Type Intent Optional Attributes Name integer, intent(in) :: iou NetCDF file id integer, intent(in) :: it (:) array of dimension ids Calls proc~~fabm_tavg_def_4d~~CallsGraph proc~fabm_tavg_def_4d uvic_fabm::fabm_tavg_def_4d defvar defvar proc~fabm_tavg_def_4d->defvar interior_state_variables interior_state_variables proc~fabm_tavg_def_4d->interior_state_variables Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fabm_tavg_def_4d ( iou , it ) !! define FABM variables in NetCDF context integer , intent ( in ) :: iou !! NetCDF file id integer , intent ( in ) :: it (:) !! array of dimension ids integer :: j , k , n real , parameter :: c0 = 0. real , parameter :: c1 = 1. real , parameter :: c100 = 10 0. real , parameter :: c500 = 50 0. associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic !            call defvar ('O_'//trim(mapt(2+n)), iou, 4, it, print * , 'O_' // trim ( VAR ( n )% name ) call defvar ( 'O_' // trim ( VAR ( n )% name ), iou , 4 , it , & VAR ( n )% minimum , VAR ( n )% maximum , ' ' , 'F' , & trim ( VAR ( n )% long_name ), ' ' , trim ( VAR ( n )% units )) end do end associate end subroutine fabm_tavg_def_4d","tags":"","loc":"proc/fabm_tavg_def_4d.html"},{"title":"fabm_tavg_out_4d – FABM in UVic","text":"public  subroutine fabm_tavg_out_4d(iou, ln, ib, ic, tmpijkm, ils, ile, jls, jle, kls, kle, t, ids, ide, jds, jde, km, nt) save 4D data to the NetCDF file given by iou Arguments Type Intent Optional Attributes Name integer, intent(in) :: iou NetCDF file id integer, intent(in) :: ln data length integer, intent(in) :: ib (:) array of start indices integer, intent(in) :: ic (:) array of counts real, intent(in) :: tmpijkm (ils:ile,jls:jle,kls:kle) mask array for present data slice integer, intent(in) :: ils start index - i integer, intent(in) :: ile end index - i integer, intent(in) :: jls start index - j integer, intent(in) :: jle end index - j integer, intent(in) :: kls start index - k integer, intent(in) :: kle end index - k real, intent(in) :: t (ids:ide,jds:jde,km,nt) UVic maintained data array slice integer, intent(in) :: ids start index - i integer, intent(in) :: ide end index - i integer, intent(in) :: jds start index - j integer, intent(in) :: jde end index - j integer, intent(in) :: km index - k integer, intent(in) :: nt number of tracers Calls proc~~fabm_tavg_out_4d~~CallsGraph proc~fabm_tavg_out_4d uvic_fabm::fabm_tavg_out_4d interior_state_variables interior_state_variables proc~fabm_tavg_out_4d->interior_state_variables putvaramsk putvaramsk proc~fabm_tavg_out_4d->putvaramsk Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fabm_tavg_out_4d ( iou , ln , ib , ic , & tmpijkm , ils , ile , jls , jle , kls , kle , & t , ids , ide , jds , jde , km , nt ) !! save 4D data to the NetCDF file given by iou integer , intent ( in ) :: iou !! NetCDF file id integer , intent ( in ) :: ln !! data length integer , intent ( in ) :: ib (:) !! array of start indices integer , intent ( in ) :: ic (:) !! array of counts real , intent ( in ) :: tmpijkm ( ils : ile , jls : jle , kls : kle ) !! mask array for present data slice integer , intent ( in ) :: ils !! start index - i integer , intent ( in ) :: ile !! end index - i integer , intent ( in ) :: jls !! start index - j integer , intent ( in ) :: jle !! end index - j integer , intent ( in ) :: kls !! start index - k integer , intent ( in ) :: kle !! end index - k real , intent ( in ) :: t ( ids : ide , jds : jde , km , nt ) !! UVic maintained data array slice integer , intent ( in ) :: ids !! start index - i integer , intent ( in ) :: ide !! end index - i integer , intent ( in ) :: jds !! start index - j integer , intent ( in ) :: jde !! end index - j integer , intent ( in ) :: km !! index - k integer , intent ( in ) :: nt !! number of tracers integer :: i , j , k , n ! counter !KB - should maybe be arguments - or picked from !     somewhere else real , parameter :: s = 1. real , parameter :: o = 0. real , allocatable :: tmpijk (:,:,:) ! t(ids:ide,jds:jde,km,nt) allocate ( tmpijk ( ils : ile , jls : jle , kls : kle ) ) associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic #if 1 tmpijk ( ils : ile , jls : jle , kls : kle ) = & t ( ils : ile , jls : jle , kls : kle , n + 2 ) #else do j = jls , jle do k = kls , kle do i = ils , ile tmpijk ( i , j , k ) = t ( i , k , j , n + 2 , 0 ) end do end do end do #endif call putvaramsk ( 'O_' // trim ( VAR ( n )% name ), iou , ln , & ib , ic , tmpijk , tmpijkm , s , o ) end do end associate deallocate ( tmpijk ) end subroutine fabm_tavg_out_4d","tags":"","loc":"proc/fabm_tavg_out_4d.html"},{"title":"fabm_link_data – FABM in UVic","text":"public  subroutine fabm_link_data() link all FABM configured external dependencies - and call\nmodel%start() to assure proper configuration Arguments None Calls proc~~fabm_link_data~~CallsGraph proc~fabm_link_data uvic_fabm::fabm_link_data itrc itrc proc~fabm_link_data->itrc link_bottom_state_data link_bottom_state_data proc~fabm_link_data->link_bottom_state_data link_interior_data link_interior_data proc~fabm_link_data->link_interior_data link_interior_state_data link_interior_state_data proc~fabm_link_data->link_interior_state_data proc~link_bottom_stress uvic_fabm::link_bottom_stress proc~fabm_link_data->proc~link_bottom_stress proc~link_density uvic_fabm::link_density proc~fabm_link_data->proc~link_density proc~link_grid uvic_fabm::link_grid proc~fabm_link_data->proc~link_grid proc~link_mole_fraction_of_carbon_dioxide_in_air uvic_fabm::link_mole_fraction_of_carbon_dioxide_in_air proc~fabm_link_data->proc~link_mole_fraction_of_carbon_dioxide_in_air proc~link_salinity uvic_fabm::link_salinity proc~fabm_link_data->proc~link_salinity proc~link_surface_swr_flux uvic_fabm::link_surface_swr_flux proc~fabm_link_data->proc~link_surface_swr_flux proc~link_wind uvic_fabm::link_wind proc~fabm_link_data->proc~link_wind sed sed proc~fabm_link_data->sed start start proc~fabm_link_data->start t t proc~fabm_link_data->t get_horizontal_variable_id get_horizontal_variable_id proc~link_bottom_stress->get_horizontal_variable_id link_horizontal_data link_horizontal_data proc~link_bottom_stress->link_horizontal_data variable_needs_values variable_needs_values proc~link_bottom_stress->variable_needs_values proc~link_density->link_interior_data get_interior_variable_id get_interior_variable_id proc~link_density->get_interior_variable_id proc~link_density->variable_needs_values proc~link_grid->link_interior_data dzt dzt proc~link_grid->dzt kmt kmt proc~link_grid->kmt zt zt proc~link_grid->zt proc~link_mole_fraction_of_carbon_dioxide_in_air->get_horizontal_variable_id proc~link_mole_fraction_of_carbon_dioxide_in_air->link_horizontal_data proc~link_mole_fraction_of_carbon_dioxide_in_air->variable_needs_values proc~link_salinity->link_interior_data proc~link_salinity->get_interior_variable_id proc~link_salinity->variable_needs_values proc~link_surface_swr_flux->get_horizontal_variable_id proc~link_surface_swr_flux->link_horizontal_data proc~link_surface_swr_flux->variable_needs_values proc~link_wind->get_horizontal_variable_id proc~link_wind->link_horizontal_data proc~link_wind->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fabm_link_data () !! link all FABM configured external dependencies - and call !! model%start() to assure proper configuration integer :: n ! link to time in-dependent data that do require transformation call link_grid () ! link to time dependent data that do NOT require transformation call model % link_interior_data ( & fabm_standard_variables % temperature , t (:,:,:, itemp , 0 )) ! link to time dependent data that do require transformation ! initialize and update time changing environmental variables call link_wind () call link_mole_fraction_of_carbon_dioxide_in_air () ckb call link_surface_downwelling_photosynthetic_radiative_flux () call link_surface_swr_flux () call link_bottom_stress () ckb call link_downwelling_photosynthetic_radiative_flux () call link_salinity () call link_density () ! link to FABMs surface state variables do n = 1 , nsurface ! call model%link_surface_state_data(n, sed(:,:,n)) end do ! link to FABMs interior state variables do n = 1 , size ( model % interior_state_variables ) call model % link_interior_state_data ( n , t (:,:,:, 2 + n , 0 )) itrc ( n + 2 ) = n + 2 !KBmapst(2+n) = 's'//trim(mapt(2+n)) end do ! link to FABMs bottom state variables do n = 1 , nbottom call model % link_bottom_state_data ( n , sed (:,:, n )) end do call model % start () end subroutine fabm_link_data","tags":"","loc":"proc/fabm_link_data.html"},{"title":"fabm_initialize_state – FABM in UVic","text":"public  subroutine fabm_initialize_state() the initialization must be split form the linking as the\nmasks are not yet calculated Arguments None Calls proc~~fabm_initialize_state~~CallsGraph proc~fabm_initialize_state uvic_fabm::fabm_initialize_state initialize_bottom_state initialize_bottom_state proc~fabm_initialize_state->initialize_bottom_state initialize_interior_state initialize_interior_state proc~fabm_initialize_state->initialize_interior_state initialize_surface_state initialize_surface_state proc~fabm_initialize_state->initialize_surface_state t t proc~fabm_initialize_state->t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fabm_initialize_state () !! the initialization must be split form the linking as the !! masks are not yet calculated integer :: j , k logical , save :: first = . true . if (. not . first ) return ! careful if not full window first = . false . ! fill the surface state if ( nsurface > 0 ) then do j = 2 , jmt - 1 call model % initialize_surface_state ( 2 , imt - 1 , j ) end do end if ! fill the interior state do j = 2 , jmt - 1 do k = 1 , km call model % initialize_interior_state ( 2 , imt - 1 , k , j ) end do end do t (:,:,:, offset :, 1 ) = t (:,:,:, offset :, 0 ) ! initial values must be in tau+1 slice ! fill the bottom state if ( nbottom > 0 ) then do j = 2 , jmt - 1 call model % initialize_bottom_state ( 2 , imt - 1 , j ) end do end if end subroutine fabm_initialize_state","tags":"","loc":"proc/fabm_initialize_state.html"},{"title":"fabm_list – FABM in UVic","text":"public  subroutine fabm_list() lists all FABM configured variables Arguments None Calls proc~~fabm_list~~CallsGraph proc~fabm_list uvic_fabm::fabm_list bottom_state_variables bottom_state_variables proc~fabm_list->bottom_state_variables interior_state_variables interior_state_variables proc~fabm_list->interior_state_variables surface_state_variables surface_state_variables proc~fabm_list->surface_state_variables Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fabm_list () !! lists all FABM configured variables integer :: n print * , 'FABM interior state variables:' do n = 1 , size ( model % interior_state_variables ) print * , n , & trim ( model % interior_state_variables ( n )% name ), '  ' , & trim ( model % interior_state_variables ( n )% units ), '  ' , & trim ( model % interior_state_variables ( n )% long_name ) end do print * , 'FABM surface-bound state variables:' do n = 1 , size ( model % surface_state_variables ) print * , n , & trim ( model % surface_state_variables ( n )% name ), '  ' , & trim ( model % surface_state_variables ( n )% units ), '  ' , & trim ( model % surface_state_variables ( n )% long_name ) end do print * , 'FABM bottom-bound state variables:' do n = 1 , size ( model % bottom_state_variables ) print * , n , & trim ( model % bottom_state_variables ( n )% name ), '  ' , & trim ( model % bottom_state_variables ( n )% units ), '  ' , & trim ( model % bottom_state_variables ( n )% long_name ) end do #if 0 print * , 'FABM diagnostic variables defined on the full model domain:' do n = 1 , size ( model % interior_diagnostic_variables ) print * , n , & trim ( model % interior_diagnostic_variables ( n )% name ), '  ' , & trim ( model % interior_diagnostic_variables ( n )% units ), '  ' , & trim ( model % interior_diagnostic_variables ( n )% long_name ) end do print * , 'FABM diagnostic variables defined on a horizontal slice of the model domain:' do n = 1 , size ( model % horizontal_diagnostic_variables ) print * , n , & trim ( model % horizontal_diagnostic_variables ( n )% name ), '  ' , & trim ( model % horizontal_diagnostic_variables ( n )% units ), '  ' , & trim ( model % horizontal_diagnostic_variables ( n )% long_name ) end do #endif end subroutine fabm_list","tags":"","loc":"proc/fabm_list.html"},{"title":"fabm_update – FABM in UVic","text":"public  subroutine fabm_update(joff, js, je, is, ie) update the environment and calculate the source/sink terms -\nis called with the same argument list as mom() calls tracer(      !)\ni.e. the specification of the active UVic window - typically\nthe full domain on modern hardware Arguments Type Intent Optional Attributes Name integer, intent(in) :: joff offset row in global window integer, intent(in) :: js start row integer, intent(in) :: je end row integer, intent(in) :: is start column integer, intent(in) :: ie end column Calls proc~~fabm_update~~CallsGraph proc~fabm_update uvic_fabm::fabm_update finalize_outputs finalize_outputs proc~fabm_update->finalize_outputs get_bottom_sources get_bottom_sources proc~fabm_update->get_bottom_sources get_interior_sources get_interior_sources proc~fabm_update->get_interior_sources get_surface_sources get_surface_sources proc~fabm_update->get_surface_sources get_vertical_movement get_vertical_movement proc~fabm_update->get_vertical_movement kmt kmt proc~fabm_update->kmt prepare_inputs prepare_inputs proc~fabm_update->prepare_inputs proc~update_data uvic_fabm::update_data proc~fabm_update->proc~update_data src src proc~fabm_update->src t t proc~fabm_update->t proc~update_bottom_stress uvic_fabm::update_bottom_stress proc~update_data->proc~update_bottom_stress proc~update_density uvic_fabm::update_density proc~update_data->proc~update_density proc~update_mole_fraction_of_carbon_dioxide_in_air uvic_fabm::update_mole_fraction_of_carbon_dioxide_in_air proc~update_data->proc~update_mole_fraction_of_carbon_dioxide_in_air proc~update_salinity uvic_fabm::update_salinity proc~update_data->proc~update_salinity proc~update_surface_swr_flux uvic_fabm::update_surface_swr_flux proc~update_data->proc~update_surface_swr_flux proc~update_wind uvic_fabm::update_wind proc~update_data->proc~update_wind proc~update_bottom_stress->kmt bmf bmf proc~update_bottom_stress->bmf variable_needs_values variable_needs_values proc~update_bottom_stress->variable_needs_values proc~update_density->kmt rho rho proc~update_density->rho proc~update_density->variable_needs_values proc~update_mole_fraction_of_carbon_dioxide_in_air->kmt proc~update_mole_fraction_of_carbon_dioxide_in_air->variable_needs_values proc~update_salinity->kmt proc~update_salinity->t proc~update_salinity->variable_needs_values proc~update_surface_swr_flux->kmt dnswr dnswr proc~update_surface_swr_flux->dnswr proc~update_wind->kmt sbc sbc proc~update_wind->sbc proc~update_wind->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fabm_update ( joff , js , je , is , ie ) !! update the environment and calculate the source/sink terms - !! is called with the same argument list as mom() calls tracer() !! i.e. the specification of the active UVic window - typically !! the full domain on modern hardware integer , intent ( in ) :: joff !! offset row in global window integer , intent ( in ) :: js !! start row integer , intent ( in ) :: je !! end row integer , intent ( in ) :: is !! start column integer , intent ( in ) :: ie !! end column integer :: i , j , k , n ! local loop counters real :: wloc real :: flux #ifdef DEBUG !print*, 'fabm_update:',joff,js,je,is,ie !print*, 'fabm_update:',t(53,1,53,itemp,1),src(53,1,53,3:6) !print*, 'fabm_update:',t(53,1,53,itemp,1),t(53,1,53,3:6,0) #endif surface_flux = 0._rke surface_sms = 0._rke pelagic_sms = 0._rke bottom_flux = 0._rke bottom_sms = 0._rke src = 0._rke ! t(:,:,:,var,0) is updated in loadmw() in mom() ! this is done before the call to tracer() - and thus ! data are ready here call update_data ( joff ) #if defined O_fabm_check_state if ( nsurface > 0 ) then do j = js , je call model % check_surface_state ( is , ie , j , repair , & valid_surf ) end do end if if ( npelagic > 0 ) then do j = js , je do k = 1 , km call model % check_interior_state ( is , ie , k , j , repair , & valid_pel ) end do end do end if if ( nbottom > 0 ) then do j = js , je call model % check_bottom_state ( is , ie , j , repair , & valid_bott ) end do end if #endif call model % prepare_inputs () ! update the surface if ( nsurface > 0 ) then do j = js , je call model % get_surface_sources ( is , ie , j , & surface_flux ( is : ie , j ,:), surface_sms ( is : ie , j ,:)) end do end if ! update the pelagic do j = js , je pelagic_sms = 0._rke do k = 1 , km call model % get_interior_sources ( is , ie , k , j , & pelagic_sms ( is : ie , k , 1 ,:)) end do src ( is : ie ,:, j , offset :) = pelagic_sms ( is : ie ,:, 1 ,:) end do ! update the bottom if ( nbottom > 0 ) then do j = js , je call model % get_bottom_sources ( is , ie , j , & bottom_flux ( is : ie , j ,:), bottom_sms ( is : ie , j ,:)) end do end if ! fold the surface and bottom flux terms do j = js , je do i = is , ie if ( kmt ( i , j ) > 0 ) then k = 1 ! surface src ( i , k , j , offset :) = src ( i , k , j , offset :) + & surface_flux ( i , j ,:) / dz ( i , k , j ) k = kmt ( i , j ) ! bottom src ( i , k , j , offset :) = src ( i , k , j , offset :) + & bottom_flux ( i , j ,:) / dz ( i , k , j ) end if end do end do ! vertical velocities do j = js , je do k = 1 , km call model % get_vertical_movement ( is , ie , k , j , w ( is : ie , k ,:)) end do ! do vertical advection - first-order upstream do n = 1 , npelagic if ( . not . ( any ( w ( is : ie ,:, n ) /= 0.0_rke ))) cycle do i = is , ie do k = 1 , kmt ( i , j ) - 1 wloc = - 0.5_rke * ( w ( i , k , n ) + w ( i , k + 1 , n )) if ( wloc > 0.0_rke ) then flux = wloc * t ( i , k , j , n , 0 ) else flux = wloc * t ( i , k + 1 , j , n , 0 ) end if t ( i , k , j , n , 0 ) = t ( i , k , j , n , 0 ) - flux / dz ( i , k , j ) t ( i , k + 1 , j , n , 0 ) = t ( i , k + 1 , j , n , 0 ) + flux / dz ( i , k + 1 , j ) end do end do end do end do call model % finalize_outputs () end subroutine fabm_update","tags":"","loc":"proc/fabm_update.html"},{"title":"fabm_clean – FABM in UVic","text":"public  subroutine fabm_clean() de-allocate all allocated arrays Arguments None Source Code subroutine fabm_clean () !! de-allocate all allocated arrays if ( allocated ( windspeed )) deallocate ( windspeed ) if ( allocated ( mole_fraction_of_carbon_dioxide_in_air )) & deallocate ( mole_fraction_of_carbon_dioxide_in_air ) c if ( allocated ( surface_downwelling_photosynthetic_radiative_flux )) c & deallocate ( surface_downwelling_photosynthetic_radiative_flux ) if ( allocated ( surface_swr_flux )) deallocate ( surface_swr_flux ) if ( allocated ( bottom_stress )) deallocate ( bottom_stress ) if ( allocated ( salt )) deallocate ( salt ) if ( allocated ( downwelling_photosynthetic_radiative_flux )) & deallocate ( downwelling_photosynthetic_radiative_flux ) if ( allocated ( rho_fabm )) deallocate ( rho_fabm ) end subroutine fabm_clean","tags":"","loc":"proc/fabm_clean.html"},{"title":"update_data – FABM in UVic","text":"private  subroutine update_data(joff) update all time varying FABM configured external dependencie      !s\nby calling individual update routines - tests done in routin      !es Arguments Type Intent Optional Attributes Name integer, intent(in) :: joff offset row in global window Calls proc~~update_data~~CallsGraph proc~update_data uvic_fabm::update_data proc~update_bottom_stress uvic_fabm::update_bottom_stress proc~update_data->proc~update_bottom_stress proc~update_density uvic_fabm::update_density proc~update_data->proc~update_density proc~update_mole_fraction_of_carbon_dioxide_in_air uvic_fabm::update_mole_fraction_of_carbon_dioxide_in_air proc~update_data->proc~update_mole_fraction_of_carbon_dioxide_in_air proc~update_salinity uvic_fabm::update_salinity proc~update_data->proc~update_salinity proc~update_surface_swr_flux uvic_fabm::update_surface_swr_flux proc~update_data->proc~update_surface_swr_flux proc~update_wind uvic_fabm::update_wind proc~update_data->proc~update_wind bmf bmf proc~update_bottom_stress->bmf kmt kmt proc~update_bottom_stress->kmt variable_needs_values variable_needs_values proc~update_bottom_stress->variable_needs_values proc~update_density->kmt rho rho proc~update_density->rho proc~update_density->variable_needs_values proc~update_mole_fraction_of_carbon_dioxide_in_air->kmt proc~update_mole_fraction_of_carbon_dioxide_in_air->variable_needs_values proc~update_salinity->kmt t t proc~update_salinity->t proc~update_salinity->variable_needs_values dnswr dnswr proc~update_surface_swr_flux->dnswr proc~update_surface_swr_flux->kmt proc~update_wind->kmt sbc sbc proc~update_wind->sbc proc~update_wind->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~update_data~~CalledByGraph proc~update_data uvic_fabm::update_data proc~fabm_update uvic_fabm::fabm_update proc~fabm_update->proc~update_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update_data ( joff ) !! update all time varying FABM configured external dependencies !! by calling individual update routines - tests done in routines integer , intent ( in ) :: joff !! offset row in global window ! dic, carbon_14, alk, n03, 02, n2? call update_wind () call update_mole_fraction_of_carbon_dioxide_in_air () c call update_surface_downwelling_photosynthetic_radiative_flux () call update_surface_swr_flux () call update_bottom_stress ( joff ) c call update_downwelling_photosynthetic_radiative_flux () call update_salinity () call update_density () end subroutine update_data","tags":"","loc":"proc/update_data.html"},{"title":"link_grid – FABM in UVic","text":"private  subroutine link_grid() Allocate and link grid related FABM standard variables that\nare being transformed from UVic native variables [cm -> m]. Arguments None Calls proc~~link_grid~~CallsGraph proc~link_grid uvic_fabm::link_grid dzt dzt proc~link_grid->dzt kmt kmt proc~link_grid->kmt link_interior_data link_interior_data proc~link_grid->link_interior_data zt zt proc~link_grid->zt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~link_grid~~CalledByGraph proc~link_grid uvic_fabm::link_grid proc~fabm_link_data uvic_fabm::fabm_link_data proc~fabm_link_data->proc~link_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine link_grid () !! Allocate and link grid related FABM standard variables that !! are being transformed from UVic native variables [cm -> m]. integer :: rc ! status variable integer :: i , j , k ! local loop counters !            print*, zt/100._rke !            print*, (dzt/100._rke) !            print*, zw/100._rke !            print*, dzw/100._rke !            stop 'egon' allocate ( depth ( imt , km , jmt ), stat = rc ) if ( rc /= 0 ) stop 'link_grid(): Error allocating (depth)' depth = 0._rke allocate ( pressure ( imt , km , jmt ), stat = rc ) if ( rc /= 0 ) stop 'link_grid(): Error allocating (pressure)' pressure = 0._rke allocate ( dz ( imt , km , jmt ), stat = rc ) if ( rc /= 0 ) stop 'link_grid(): Error allocating (dz)' dz = 0._rke do j = 2 , jmt - 1 do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) then depth ( i , 1 : kmt ( i , j ), j ) = zt ( 1 : kmt ( i , j )) / 10 0._rke pressure ( i , 1 : kmt ( i , j ), j ) = & depth ( i , 1 : kmt ( i , j ), j ) / 1 0._rke dz ( i , 1 : kmt ( i , j ), j ) = dzt ( 1 : kmt ( i , j )) / 10 0._rke end if end do end do call model % link_interior_data ( & fabm_standard_variables % depth , depth ) call model % link_interior_data ( & fabm_standard_variables % pressure , pressure ) call model % link_interior_data ( & fabm_standard_variables % cell_thickness , dz ) #if 0 print * , depth ( 53 ,:, 53 ), pressure (: 53 ,:, 53 ), dz ( 53 ,:, 53 ) stop 'egon' #endif end subroutine link_grid","tags":"","loc":"proc/link_grid.html"},{"title":"link_wind – FABM in UVic","text":"private  subroutine link_wind() get wind speed FABM standard variable and if needed by FABM\nallocate memory Arguments None Calls proc~~link_wind~~CallsGraph proc~link_wind uvic_fabm::link_wind get_horizontal_variable_id get_horizontal_variable_id proc~link_wind->get_horizontal_variable_id link_horizontal_data link_horizontal_data proc~link_wind->link_horizontal_data variable_needs_values variable_needs_values proc~link_wind->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~link_wind~~CalledByGraph proc~link_wind uvic_fabm::link_wind proc~fabm_link_data uvic_fabm::fabm_link_data proc~fabm_link_data->proc~link_wind Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine link_wind () !! get wind speed FABM standard variable and if needed by FABM !! allocate memory integer rc ! status variable id_windspeed = model % get_horizontal_variable_id ( & standard_variables % wind_speed ) if ( model % variable_needs_values ( id_windspeed )) then allocate ( windspeed ( imt , jmt ), stat = rc ) if ( rc /= 0 ) stop & 'link_wind(): Error allocating (windspeed)' windspeed = 0._rke call model % link_horizontal_data ( id_windspeed , windspeed ) end if end subroutine link_wind","tags":"","loc":"proc/link_wind.html"},{"title":"update_wind – FABM in UVic","text":"private  subroutine update_wind() calculate wind speed in m/s according to Arguments None Calls proc~~update_wind~~CallsGraph proc~update_wind uvic_fabm::update_wind kmt kmt proc~update_wind->kmt sbc sbc proc~update_wind->sbc variable_needs_values variable_needs_values proc~update_wind->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~update_wind~~CalledByGraph proc~update_wind uvic_fabm::update_wind proc~update_data uvic_fabm::update_data proc~update_data->proc~update_wind proc~fabm_update uvic_fabm::fabm_update proc~fabm_update->proc~update_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update_wind () !! calculate wind speed in m/s according to !! w = w_{UVic}/100 ! the wind speed in m/s - iws, iaws integer i , j ! local loop counters if ( model % variable_needs_values ( id_windspeed )) then do j = 2 , jmt - 1 do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) windspeed ( i , j ) = & sbc ( i , j , iws ) / 10 0._rke end do end do end if end subroutine update_wind","tags":"","loc":"proc/update_wind.html"},{"title":"link_mole_fraction_of_carbon_dioxide_in_air – FABM in UVic","text":"private  subroutine link_mole_fraction_of_carbon_dioxide_in_air() Arguments None Calls proc~~link_mole_fraction_of_carbon_dioxide_in_air~~CallsGraph proc~link_mole_fraction_of_carbon_dioxide_in_air uvic_fabm::link_mole_fraction_of_carbon_dioxide_in_air get_horizontal_variable_id get_horizontal_variable_id proc~link_mole_fraction_of_carbon_dioxide_in_air->get_horizontal_variable_id link_horizontal_data link_horizontal_data proc~link_mole_fraction_of_carbon_dioxide_in_air->link_horizontal_data variable_needs_values variable_needs_values proc~link_mole_fraction_of_carbon_dioxide_in_air->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~link_mole_fraction_of_carbon_dioxide_in_air~~CalledByGraph proc~link_mole_fraction_of_carbon_dioxide_in_air uvic_fabm::link_mole_fraction_of_carbon_dioxide_in_air proc~fabm_link_data uvic_fabm::fabm_link_data proc~fabm_link_data->proc~link_mole_fraction_of_carbon_dioxide_in_air Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine link_mole_fraction_of_carbon_dioxide_in_air () integer i , j , rc ! local loop counters id_mole_fraction_of_carbon_dioxide_in_air = model % & get_horizontal_variable_id ( standard_variables % & mole_fraction_of_carbon_dioxide_in_air ) if ( model % variable_needs_values ( & id_mole_fraction_of_carbon_dioxide_in_air )) then allocate ( mole_fraction_of_carbon_dioxide_in_air ( imt , jmt ), & stat = rc ) if ( rc /= 0 ) stop & 'link_mole_fraction_of_carbon_dioxide_in_air(): &      Error allocating (mole_fraction_of_carbon_dioxide_in_air)' mole_fraction_of_carbon_dioxide_in_air = 0._rke call model % link_horizontal_data ( & id_mole_fraction_of_carbon_dioxide_in_air , & mole_fraction_of_carbon_dioxide_in_air ) end if end subroutine link_mole_fraction_of_carbon_dioxide_in_air","tags":"","loc":"proc/link_mole_fraction_of_carbon_dioxide_in_air.html"},{"title":"update_mole_fraction_of_carbon_dioxide_in_air – FABM in UVic","text":"private  subroutine update_mole_fraction_of_carbon_dioxide_in_air() calculate the ?????? in W/m&#94;2 Arguments None Calls proc~~update_mole_fraction_of_carbon_dioxide_in_air~~CallsGraph proc~update_mole_fraction_of_carbon_dioxide_in_air uvic_fabm::update_mole_fraction_of_carbon_dioxide_in_air kmt kmt proc~update_mole_fraction_of_carbon_dioxide_in_air->kmt variable_needs_values variable_needs_values proc~update_mole_fraction_of_carbon_dioxide_in_air->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~update_mole_fraction_of_carbon_dioxide_in_air~~CalledByGraph proc~update_mole_fraction_of_carbon_dioxide_in_air uvic_fabm::update_mole_fraction_of_carbon_dioxide_in_air proc~update_data uvic_fabm::update_data proc~update_data->proc~update_mole_fraction_of_carbon_dioxide_in_air proc~fabm_update uvic_fabm::fabm_update proc~fabm_update->proc~update_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update_mole_fraction_of_carbon_dioxide_in_air () !! calculate the ?????? in W/m&#94;2 integer i , j ! local loop counters if ( model % variable_needs_values ( & id_mole_fraction_of_carbon_dioxide_in_air )) then do j = 2 , jmt - 1 do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) then mole_fraction_of_carbon_dioxide_in_air ( i , j ) = & 1 0._rke !KB end if end do end do end if end subroutine update_mole_fraction_of_carbon_dioxide_in_air","tags":"","loc":"proc/update_mole_fraction_of_carbon_dioxide_in_air.html"},{"title":"link_surface_swr_flux – FABM in UVic","text":"private  subroutine link_surface_swr_flux() Arguments None Calls proc~~link_surface_swr_flux~~CallsGraph proc~link_surface_swr_flux uvic_fabm::link_surface_swr_flux get_horizontal_variable_id get_horizontal_variable_id proc~link_surface_swr_flux->get_horizontal_variable_id link_horizontal_data link_horizontal_data proc~link_surface_swr_flux->link_horizontal_data variable_needs_values variable_needs_values proc~link_surface_swr_flux->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~link_surface_swr_flux~~CalledByGraph proc~link_surface_swr_flux uvic_fabm::link_surface_swr_flux proc~fabm_link_data uvic_fabm::fabm_link_data proc~fabm_link_data->proc~link_surface_swr_flux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine link_surface_swr_flux () integer rc ! status variable id_surface_swr_flux = model % & get_horizontal_variable_id ( standard_variables % & surface_downwelling_shortwave_flux ) if ( model % variable_needs_values ( id_surface_swr_flux )) then allocate ( surface_swr_flux ( imt , jmt ), stat = rc ) if ( rc /= 0 ) stop 'link_surface_swr_flux(): &                        Error allocating (surface_swr_flux)' surface_swr_flux = 0._rke call model % link_horizontal_data ( id_surface_swr_flux , & surface_swr_flux ) end if end subroutine link_surface_swr_flux","tags":"","loc":"proc/link_surface_swr_flux.html"},{"title":"update_surface_swr_flux – FABM in UVic","text":"private  subroutine update_surface_swr_flux() Note This calculation of the surface swr uses the flux directly\nfrom the atmospheric model - must be corrected for ice at\nsome point. alternatively the variable in tracer.F90 calculate the short wave flux in according to carefull with the time averaged value Arguments None Calls proc~~update_surface_swr_flux~~CallsGraph proc~update_surface_swr_flux uvic_fabm::update_surface_swr_flux dnswr dnswr proc~update_surface_swr_flux->dnswr kmt kmt proc~update_surface_swr_flux->kmt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~update_surface_swr_flux~~CalledByGraph proc~update_surface_swr_flux uvic_fabm::update_surface_swr_flux proc~update_data uvic_fabm::update_data proc~update_data->proc~update_surface_swr_flux proc~fabm_update uvic_fabm::fabm_update proc~fabm_update->proc~update_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update_surface_swr_flux () !! @note !! This calculation of the surface swr uses the flux directly !! from the atmospheric model - must be corrected for ice at !! some point. !! !! alternatively the gl variable in tracer.F90 !! @endnote !! !! calculate the short wave flux in W/m&#94;2 according to !! I_0 = 41868\\ (W/m²)/(cal/cm²/s)\\ I_{0_{UVic}}\\ !! cal/cm²/s¹ !! !! carefull with the time averaged value integer i , j ! local loop counters !KB         if (model%variable_needs_values(id_surface_swr_flux)) then do j = 2 , jmt - 1 do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) surface_swr_flux ( i , j ) = & 0.001 * dnswr ( i , j ) end do end do !KB         end if end subroutine update_surface_swr_flux","tags":"","loc":"proc/update_surface_swr_flux.html"},{"title":"link_bottom_stress – FABM in UVic","text":"private  subroutine link_bottom_stress() get bottom stress FABM standard variable and if needed by\nFABM allocate memory Arguments None Calls proc~~link_bottom_stress~~CallsGraph proc~link_bottom_stress uvic_fabm::link_bottom_stress get_horizontal_variable_id get_horizontal_variable_id proc~link_bottom_stress->get_horizontal_variable_id link_horizontal_data link_horizontal_data proc~link_bottom_stress->link_horizontal_data variable_needs_values variable_needs_values proc~link_bottom_stress->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~link_bottom_stress~~CalledByGraph proc~link_bottom_stress uvic_fabm::link_bottom_stress proc~fabm_link_data uvic_fabm::fabm_link_data proc~fabm_link_data->proc~link_bottom_stress Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine link_bottom_stress () !! get bottom stress FABM standard variable and if needed by !! FABM allocate memory integer rc ! status variable id_bottom_stress = model % get_horizontal_variable_id ( & standard_variables % bottom_stress ) if ( model % variable_needs_values ( id_bottom_stress )) then allocate ( bottom_stress ( imt , jmt ), stat = rc ) if ( rc /= 0 ) stop 'link_bottom_stress(): &                   Error allocating (bottom_stress)' bottom_stress = 0._rke call model % link_horizontal_data ( & id_bottom_stress , bottom_stress ) end if end subroutine link_bottom_stress","tags":"","loc":"proc/link_bottom_stress.html"},{"title":"update_bottom_stress – FABM in UVic","text":"private  subroutine update_bottom_stress(joff) calculate the bottom stress in Pa Arguments Type Intent Optional Attributes Name integer, intent(in) :: joff offset row in global window Calls proc~~update_bottom_stress~~CallsGraph proc~update_bottom_stress uvic_fabm::update_bottom_stress bmf bmf proc~update_bottom_stress->bmf kmt kmt proc~update_bottom_stress->kmt variable_needs_values variable_needs_values proc~update_bottom_stress->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~update_bottom_stress~~CalledByGraph proc~update_bottom_stress uvic_fabm::update_bottom_stress proc~update_data uvic_fabm::update_data proc~update_data->proc~update_bottom_stress proc~fabm_update uvic_fabm::fabm_update proc~fabm_update->proc~update_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update_bottom_stress ( joff ) !! calculate the bottom stress in Pa integer , intent ( in ) :: joff !! offset row in global window real ( rke ), parameter :: x = 1 0._rke !! dynes/cm2 --> Pa integer i , j , jrow ! local loop counters if ( model % variable_needs_values ( id_bottom_stress )) then do j = 2 , jmt - 1 jrow = j + joff do i = 2 , imt - 1 if ( kmt ( i , jrow ) > 0 ) then bottom_stress ( i , j ) = x * sqrt ( & bmf ( i , jrow , 1 ) ** 2 + bmf ( i , jrow , 2 ) ** 2 ) end if end do end do end if end subroutine update_bottom_stress","tags":"","loc":"proc/update_bottom_stress.html"},{"title":"link_downwelling_photosynthetic_radiative_flux – FABM in UVic","text":"private  subroutine link_downwelling_photosynthetic_radiative_flux() get salinity FABM standard variable and if needed by FABM\nallocate memory Arguments None Calls proc~~link_downwelling_photosynthetic_radiative_flux~~CallsGraph proc~link_downwelling_photosynthetic_radiative_flux uvic_fabm::link_downwelling_photosynthetic_radiative_flux get_interior_variable_id get_interior_variable_id proc~link_downwelling_photosynthetic_radiative_flux->get_interior_variable_id link_interior_data link_interior_data proc~link_downwelling_photosynthetic_radiative_flux->link_interior_data variable_needs_values variable_needs_values proc~link_downwelling_photosynthetic_radiative_flux->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine link_downwelling_photosynthetic_radiative_flux () !! get salinity FABM standard variable and if needed by FABM !! allocate memory integer rc ! status variable id_downwelling_photosynthetic_radiative_flux = & model % get_interior_variable_id ( & fabm_standard_variables % & downwelling_photosynthetic_radiative_flux ) if ( model % variable_needs_values ( & id_downwelling_photosynthetic_radiative_flux )) then allocate ( & downwelling_photosynthetic_radiative_flux ( imt , km , jmt ), & stat = rc ) if ( rc /= 0 ) stop 'link_salinity(): &      Error allocating &      (downwelling_photosynthetic_radiative_flux)' downwelling_photosynthetic_radiative_flux = 0._rke call model % link_interior_data ( & id_downwelling_photosynthetic_radiative_flux , & downwelling_photosynthetic_radiative_flux ) end if end subroutine link_downwelling_photosynthetic_radiative_flux","tags":"","loc":"proc/link_downwelling_photosynthetic_radiative_flux.html"},{"title":"update_downwelling_photosynthetic_radiative_flux – FABM in UVic","text":"private  subroutine update_downwelling_photosynthetic_radiative_flux() calculate salinity in PSU according to Arguments None Calls proc~~update_downwelling_photosynthetic_radiative_flux~~CallsGraph proc~update_downwelling_photosynthetic_radiative_flux uvic_fabm::update_downwelling_photosynthetic_radiative_flux kmt kmt proc~update_downwelling_photosynthetic_radiative_flux->kmt t t proc~update_downwelling_photosynthetic_radiative_flux->t variable_needs_values variable_needs_values proc~update_downwelling_photosynthetic_radiative_flux->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update_downwelling_photosynthetic_radiative_flux () !! calculate salinity in PSU according to S = 35 + 1000*S_{UVic} integer i , j , k ! local loop counters if ( model % variable_needs_values ( & id_downwelling_photosynthetic_radiative_flux )) then do j = 2 , jmt - 1 do k = 1 , km do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) then downwelling_photosynthetic_radiative_flux ( i , k , j ) & = 3 5._rk + 100 0._rke * t ( i , k , j , isalt , 0 ) end if end do end do end do end if end subroutine update_downwelling_photosynthetic_radiative_flux","tags":"","loc":"proc/update_downwelling_photosynthetic_radiative_flux.html"},{"title":"link_salinity – FABM in UVic","text":"private  subroutine link_salinity() get salinity FABM standard variable and if needed by FABM\nallocate memory Arguments None Calls proc~~link_salinity~~CallsGraph proc~link_salinity uvic_fabm::link_salinity get_interior_variable_id get_interior_variable_id proc~link_salinity->get_interior_variable_id link_interior_data link_interior_data proc~link_salinity->link_interior_data variable_needs_values variable_needs_values proc~link_salinity->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~link_salinity~~CalledByGraph proc~link_salinity uvic_fabm::link_salinity proc~fabm_link_data uvic_fabm::fabm_link_data proc~fabm_link_data->proc~link_salinity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine link_salinity () !! get salinity FABM standard variable and if needed by FABM !! allocate memory integer rc ! status variable id_practical_salinity = model % get_interior_variable_id ( & fabm_standard_variables % practical_salinity ) if ( model % variable_needs_values ( id_practical_salinity )) then allocate ( salt ( imt , km , jmt ), stat = rc ) if ( rc /= 0 ) stop 'link_salinity(): &                         Error allocating (salt)' salt = 0._rke call model % link_interior_data ( id_practical_salinity , salt ) end if end subroutine link_salinity","tags":"","loc":"proc/link_salinity.html"},{"title":"update_salinity – FABM in UVic","text":"private  subroutine update_salinity() calculate salinity in PSU according to Arguments None Calls proc~~update_salinity~~CallsGraph proc~update_salinity uvic_fabm::update_salinity kmt kmt proc~update_salinity->kmt t t proc~update_salinity->t variable_needs_values variable_needs_values proc~update_salinity->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~update_salinity~~CalledByGraph proc~update_salinity uvic_fabm::update_salinity proc~update_data uvic_fabm::update_data proc~update_data->proc~update_salinity proc~fabm_update uvic_fabm::fabm_update proc~fabm_update->proc~update_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update_salinity () !! calculate salinity in PSU according to S = 35 + !! 1000*S_{UVic} integer i , j , k ! local loop counters if ( model % variable_needs_values ( id_practical_salinity )) then do j = 2 , jmt - 1 do k = 1 , km do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) then salt ( i , k , j ) = 3 5._rk + 100 0._rke * t ( i , k , j , isalt , 0 ) end if end do end do end do end if end subroutine update_salinity","tags":"","loc":"proc/update_salinity.html"},{"title":"link_density – FABM in UVic","text":"private  subroutine link_density() get density FABM standard variable and if needed by FABM\nallocate  memory Arguments None Calls proc~~link_density~~CallsGraph proc~link_density uvic_fabm::link_density get_interior_variable_id get_interior_variable_id proc~link_density->get_interior_variable_id link_interior_data link_interior_data proc~link_density->link_interior_data variable_needs_values variable_needs_values proc~link_density->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~link_density~~CalledByGraph proc~link_density uvic_fabm::link_density proc~fabm_link_data uvic_fabm::fabm_link_data proc~fabm_link_data->proc~link_density Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine link_density () !! get density FABM standard variable and if needed by FABM !! allocate  memory integer rc ! status variable id_density = model % get_interior_variable_id ( & fabm_standard_variables % density ) if ( model % variable_needs_values ( id_density )) then allocate ( rho_fabm ( imt , km , jmt ), stat = rc ) if ( rc /= 0 ) stop 'link_density(): &                         Error allocating (rho_fabm)' rho_fabm = 0._rke call model % link_interior_data ( id_density , rho_fabm ) end if end subroutine link_density","tags":"","loc":"proc/link_density.html"},{"title":"update_density – FABM in UVic","text":"private  subroutine update_density() calculate density in kg/m³ according to with . MUST match rho0 from UVic_ESCM.F90 Note loadmw.F: l 154 imt=102, km=19, jsmw=2, jmw=jmt --- jemw=jmw-1 declared: rho(imt,km,jsmw:jmw) calculated rho(1:102,2:102)\nrho Note KB check depth dependent reference density Arguments None Calls proc~~update_density~~CallsGraph proc~update_density uvic_fabm::update_density kmt kmt proc~update_density->kmt rho rho proc~update_density->rho variable_needs_values variable_needs_values proc~update_density->variable_needs_values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~update_density~~CalledByGraph proc~update_density uvic_fabm::update_density proc~update_data uvic_fabm::update_data proc~update_data->proc~update_density proc~fabm_update uvic_fabm::fabm_update proc~fabm_update->proc~update_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update_density () !! calculate density in kg/m³ according to !! \\rho = 1000*(\\rho_0 + \\rho_{UVic}) !! with \\rho_0 = 1.035. MUST match rho0 from UVic_ESCM.F90 !! @note !! loadmw.F: l 154 !! !! imt=102, km=19, jsmw=2, jmw=jmt --- jemw=jmw-1 !! !! declared: rho(imt,km,jsmw:jmw) calculated rho(1:102,2:102) !! rho !! @endnote !! @note !! KB check depth dependent reference density !! @endnote integer i , j , k ! local loop counters real ( rke ), parameter :: rho0 = 1.035 ! reference density if ( model % variable_needs_values ( id_density )) then c do j = 1 , jmt do j = jsmw , jmw ! must be 2:102 do k = 1 , km do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) then rho_fabm ( i , k , j ) = 100 0._rke * ( rho0 + rho ( i , k , j )) end if end do end do end do end if #if 0 print * , rho_fabm ( 53 ,:, 53 ) stop 'kurt' #endif end subroutine update_density","tags":"","loc":"proc/update_density.html"},{"title":"uvic_fabm – FABM in UVic","text":"Copyright (C) 2024 Bolding & Bruggeman Warning This module is still under development.\nAPI and functioning might change without notice. History A list of important UVic (MOM2) variables used by FABM: - all tracers [source/mom/mw.h] -\n[T,S] = [1,2] : tracers with sources [source/mom/tracer.f] surface boundary conditions [source/common/csbc.h] :  density [source/mom/mw.h] with [commom/size.h] number of tracers [commom/size.h] [commom/size.h] : number of tracers with source terms [common/size.h] : total number of surface boundary conditions -\n  list in [common/csbc.h] set in [common/UVic_ESCM.F]. Updating FABM is done in the tracer() subroutine called like: with The arguments to tracer() are passed directly to fabm_update(). Note\nthat potentially jstrac:jetrac does not cover the entire domain.\nFocus - initially - will be on getting it to work with !O_min_window\ni.e. the entire domain calculated in one go. Note The FABM calculation domain in UVic reference is Is it best to allocate arrays correspondingly or do the mapping\nin the do-loops? Note Dimension of z, dz and pressure in a z-coordinate model?\nOption to be 1D? Note What are the proper links to FABM modules? Note Is there a way to check if a FABM pelagic variable has source terms? With UVic model all tracer variables - except T, S and CFC gases.\nAll respecting #ifdefs. Some native UVic_ESCM variables will have to be converted to be compatible with FABM.\nThis can either be because of different dimensionality or different units.\nThis is done by creating module level private variables that will be calculated/updated\nbased on the original UVic_ECSM variables. Some will only need to be calculated once - like\nlayer heights - and some will have to be updated every time step - like density. Uses fabm uvic_common_blocks fabm_debug fabm_types module~~uvic_fabm~~UsesGraph module~uvic_fabm uvic_fabm fabm fabm module~uvic_fabm->fabm fabm_debug fabm_debug module~uvic_fabm->fabm_debug fabm_types fabm_types module~uvic_fabm->fabm_types uvic_common_blocks uvic_common_blocks module~uvic_fabm->uvic_common_blocks Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial class(type_fabm_model), private, pointer :: model This variable will contain all FABM configuration and\ngive access to FABM routines real(kind=rke), private, allocatable, target :: dz (:,:,:) type(type_fabm_interior_variable_id), private :: id_density real(kind=rke), private, allocatable, target :: rho_fabm (:,:,:) real(kind=rke), private, allocatable, target :: depth (:,:,:) type(type_fabm_interior_variable_id), private :: id_downwelling_photosynthetic_radiative_flux real(kind=rke), private, allocatable, target :: downwelling_photosynthetic_radiative_flux (:,:,:) type(type_fabm_interior_variable_id), private :: id_practical_salinity real(kind=rke), private, allocatable, target :: salt (:,:,:) type(type_fabm_interior_variable_id), private :: id_pressure real(kind=rke), private, allocatable, target :: pressure (:,:,:) type(type_fabm_horizontal_variable_id), private :: id_mole_fraction_of_carbon_dioxide_in_air real(kind=rke), private, allocatable, target :: mole_fraction_of_carbon_dioxide_in_air (:,:) type(type_fabm_horizontal_variable_id), private :: id_surface_downwelling_photosynthetic_radiative_flux real(kind=rke), private, allocatable, target :: surface_downwelling_photosynthetic_radiative_flux (:,:) type(type_fabm_horizontal_variable_id), private :: id_surface_swr_flux real(kind=rke), private, allocatable, target :: surface_swr_flux (:,:) type(type_fabm_horizontal_variable_id), private :: id_windspeed real(kind=rke), private, allocatable, target :: windspeed (:,:) type(type_fabm_horizontal_variable_id), private :: id_bottom_stress real(kind=rke), private, allocatable, target :: bottom_stress (:,:) integer, private, parameter :: offset = nsrc-nfabm+1 real(kind=rke), private :: pelagic_sms (imt,km,1,nfabm) pelagic source-sink terms in one j-stride real(kind=rke), private :: surface_flux (imt,jmt,nfabm) surface fluxes real(kind=rke), private :: surface_sms (imt,jmt,nfabm) surface source-sink terms real(kind=rke), private :: bottom_flux (imt,jmt,nfabm) bottom fluxes real(kind=rke), private :: bottom_sms (imt,jmt,nfabm) bottom source-sink terms real(kind=rke), private :: w (imt,km,nt-2) vertical velocity in m/s real(kind=rke), private :: tai_fabm (nt-2) time averaged variables integer, private :: nsurface integer, private :: npelagic integer, private :: nbottom logical, private, parameter :: repair = .true. logical, private :: valid_pel Note The variables to hold surface, pelagic and bottom state variabl      !es\ncomes from mw.h - included in a 1 compilation clause logical, private :: valid_surf Note The variables to hold surface, pelagic and bottom state variabl      !es\ncomes from mw.h - included in a 1 compilation clause logical, private :: valid_bott Note The variables to hold surface, pelagic and bottom state variabl      !es\ncomes from mw.h - included in a 1 compilation clause Subroutines public  subroutine fabm_configure (dt, yaml_file) read fabm.yaml and call FABM configuration subroutines Read more… Arguments Type Intent Optional Attributes Name real(kind=rke), intent(in) :: dt bio-geochemical time step as set by MOM2 [s] character(len=*), intent(in), optional :: yaml_file name of alternativ FABM configuration file public  subroutine fabm_sbc_init (m) surface boundary data are handled via sbc(imt,jmt,numsbc) in\nsetmom.F, tracer.F, gosbc.F, embmio.F Arguments Type Intent Optional Attributes Name integer, intent(inout) :: m number of handled variables handled so far public  subroutine fabm_tracer_init (m) surface boundary data are handled via sbc(imt,jmt,numsbc) in\nsetmom.F, tracer.F, gosbc.F, embmio.F Arguments Type Intent Optional Attributes Name integer, intent(inout) :: m number of handled variables handled so far private  subroutine rowi_fabm () this is done in fabm_initialize_state() - but check !!KB\nsetmom.F - if (.not. init) then - around line 299 Arguments None public  subroutine fabm_rest_in (iou, ln, ib, ic, tmpik, ils, ile, kls, kle, tau) reading FABM restart variables from NetCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: iou NetCDF file id integer, intent(in) :: ln data length integer, intent(in) :: ib (:) array of start indices integer, intent(in) :: ic (:) array of counts real, intent(inout) :: tmpik (ils:ile,kls:kle) array for present data slice integer, intent(in) :: ils start index - i integer, intent(in) :: ile end index - i integer, intent(in) :: kls start index - k integer, intent(in) :: kle end index - k integer, intent(in) :: tau time index - -1:1 public  subroutine fabm_rest_def (iou, it) define FABM restart variables in NetCDF context Arguments Type Intent Optional Attributes Name integer, intent(in) :: iou NetCDF file id integer, intent(in) :: it (:) time dimension public  subroutine fabm_rest_out (iou, ln, ib, ic, tmpik, ils, ile, kls, kle, tau) save 4D data to the NetCDF file given by iou Arguments Type Intent Optional Attributes Name integer, intent(in) :: iou NetCDF file id integer, intent(in) :: ln data length integer, intent(in) :: ib (:) array of start indices integer, intent(in) :: ic (:) array of counts real, intent(inout) :: tmpik (ils:ile,kls:kle) mask array for present data slice integer, intent(in) :: ils start index - i integer, intent(in) :: ile end index - i integer, intent(in) :: kls start index - k integer, intent(in) :: kle end index - k integer, intent(in) :: tau time index - -1:1 public  subroutine ta_fabm_tsi (m, ntatio, tbar) define FABM variables in NetCDF context Arguments Type Intent Optional Attributes Name integer, intent(in) :: m switch operations integer, intent(in), optional :: ntatio switch operations real, intent(in), optional :: tbar (:) slice of UVic maintained temporary variable public  subroutine fabm_tsi_def (iou, id) define FABM time series variables in NetCDF context Arguments Type Intent Optional Attributes Name integer, intent(in) :: iou NetCDF file id integer, intent(in) :: id (1) time dimension public  subroutine fabm_tsi_out (iou, ntrec) define FABM variables in NetCDF context Arguments Type Intent Optional Attributes Name integer, intent(in) :: iou NetCDF file id integer, intent(in) :: ntrec time record public  subroutine fabm_tavg_def_4d (iou, it) define FABM variables in NetCDF context Arguments Type Intent Optional Attributes Name integer, intent(in) :: iou NetCDF file id integer, intent(in) :: it (:) array of dimension ids public  subroutine fabm_tavg_out_4d (iou, ln, ib, ic, tmpijkm, ils, ile, jls, jle, kls, kle, t, ids, ide, jds, jde, km, nt) save 4D data to the NetCDF file given by iou Arguments Type Intent Optional Attributes Name integer, intent(in) :: iou NetCDF file id integer, intent(in) :: ln data length integer, intent(in) :: ib (:) array of start indices integer, intent(in) :: ic (:) array of counts real, intent(in) :: tmpijkm (ils:ile,jls:jle,kls:kle) mask array for present data slice integer, intent(in) :: ils start index - i integer, intent(in) :: ile end index - i integer, intent(in) :: jls start index - j integer, intent(in) :: jle end index - j integer, intent(in) :: kls start index - k integer, intent(in) :: kle end index - k real, intent(in) :: t (ids:ide,jds:jde,km,nt) UVic maintained data array slice integer, intent(in) :: ids start index - i integer, intent(in) :: ide end index - i integer, intent(in) :: jds start index - j integer, intent(in) :: jde end index - j integer, intent(in) :: km index - k integer, intent(in) :: nt number of tracers public  subroutine fabm_link_data () link all FABM configured external dependencies - and call\nmodel%start() to assure proper configuration Arguments None public  subroutine fabm_initialize_state () the initialization must be split form the linking as the\nmasks are not yet calculated Arguments None public  subroutine fabm_list () lists all FABM configured variables Arguments None public  subroutine fabm_update (joff, js, je, is, ie) update the environment and calculate the source/sink terms -\nis called with the same argument list as mom() calls tracer(      !)\ni.e. the specification of the active UVic window - typically\nthe full domain on modern hardware Arguments Type Intent Optional Attributes Name integer, intent(in) :: joff offset row in global window integer, intent(in) :: js start row integer, intent(in) :: je end row integer, intent(in) :: is start column integer, intent(in) :: ie end column public  subroutine fabm_clean () de-allocate all allocated arrays Arguments None private  subroutine update_data (joff) update all time varying FABM configured external dependencie      !s\nby calling individual update routines - tests done in routin      !es Arguments Type Intent Optional Attributes Name integer, intent(in) :: joff offset row in global window private  subroutine link_grid () Allocate and link grid related FABM standard variables that\nare being transformed from UVic native variables [cm -> m]. Arguments None private  subroutine link_wind () get wind speed FABM standard variable and if needed by FABM\nallocate memory Arguments None private  subroutine update_wind () calculate wind speed in m/s according to Arguments None private  subroutine link_mole_fraction_of_carbon_dioxide_in_air () Arguments None private  subroutine update_mole_fraction_of_carbon_dioxide_in_air () calculate the ?????? in W/m&#94;2 Arguments None private  subroutine link_surface_swr_flux () Arguments None private  subroutine update_surface_swr_flux () This calculation of the surface swr uses the flux directly\nfrom the atmospheric model - must be corrected for ice at\nsome point. Read more… Arguments None private  subroutine link_bottom_stress () get bottom stress FABM standard variable and if needed by\nFABM allocate memory Arguments None private  subroutine update_bottom_stress (joff) calculate the bottom stress in Pa Arguments Type Intent Optional Attributes Name integer, intent(in) :: joff offset row in global window private  subroutine link_downwelling_photosynthetic_radiative_flux () get salinity FABM standard variable and if needed by FABM\nallocate memory Arguments None private  subroutine update_downwelling_photosynthetic_radiative_flux () calculate salinity in PSU according to Arguments None private  subroutine link_salinity () get salinity FABM standard variable and if needed by FABM\nallocate memory Arguments None private  subroutine update_salinity () calculate salinity in PSU according to Arguments None private  subroutine link_density () get density FABM standard variable and if needed by FABM\nallocate  memory Arguments None private  subroutine update_density () calculate density in kg/m³ according to with . MUST match rho0 from UVic_ESCM.F90 Read more… Arguments None","tags":"","loc":"module/uvic_fabm.html"},{"title":"fabm.F – FABM in UVic","text":"Source Code !> Copyright (C) 2024 Bolding & Bruggeman !> !> @warning !> This module is still under development. !> API and functioning might change without notice. !> @endwarning !> !> @history !> A list of important UVic (MOM2) variables used by FABM: !> !> - t(imt,km,jmt,nt,-1:1) - all tracers [source/mom/mw.h] - !> [T,S] = [1,2] !> - src(imt,km,jsmw:jemw,nsrc): tracers with sources [source/mom/tracer.f] !> - sbc(imt,jmt,numsbc) surface boundary conditions [source/common/csbc.h] !> - rho(imt,km,jsmw:jmw):  density [source/mom/mw.h] !> !> with !> !> - (imt,km,jmt) = (102,19,102) [commom/size.h] !> - nt = 2+?? number of tracers [commom/size.h] !> - jsmw:jemw = (2, jmw=jmt) or (2, jmw=(3,4,5) [commom/size.h] !> - nsrc: number of tracers with source terms [common/size.h] !> - numsbc: total number of surface boundary conditions - !>   list in [common/csbc.h] set in [common/UVic_ESCM.F]. !> !> Updating FABM is done in the tracer() subroutine called like: !> !> - call\\ tracer (joff, jstrac, jetrac, is, ie) !> with !> (joff, jstrac, jetrac, is, ie) = (0,2,101,2,101) !> !> The arguments to tracer() are passed directly to fabm_update(). Note !> that potentially jstrac:jetrac does not cover the entire domain. !> Focus - initially - will be on getting it to work with !O_min_window !> i.e. the entire domain calculated in one go. !> !> @endhistory !> !> @note !> The FABM calculation domain in UVic reference is !>  t(2:imt-1,km,2:jmt-1,3:nt)  !> !> Is it best to allocate arrays correspondingly or do the mapping !> in the do-loops? !> @endnote !> !> @note !> Dimension of z, dz and pressure in a z-coordinate model? !> Option to be 1D? !> !> @endnote !> !> @note !> What are the proper links to FABM modules? !> @endnote !> !> @note !> Is there a way to check if a FABM pelagic variable has source terms? !> !> With UVic model all tracer variables - except T, S and CFC gases. !> All respecting #ifdefs. !> @endnote !> !> Some native UVic_ESCM variables will have to be converted to be compatible with FABM. !> This can either be because of different dimensionality or different units. !> This is done by creating module level private variables that will be calculated/updated !> based on the original UVic_ECSM variables. Some will only need to be calculated once - like !> layer heights - and some will have to be updated every time step - like density. module uvic_fabm #ifdef O_fabm use uvic_common_blocks use fabm use fabm_types #define DEBUG #ifdef DEBUG use fabm_debug #endif #endif IMPLICIT NONE private class ( type_fabm_model ), pointer :: model !! This variable will contain all FABM configuration and !! give access to FABM routines ! The following is a list of all FABM standard variables - the definitions can be updated ! during the implementation. The order of the variables is mainained from: ! https://github.com/fabm-model/fabm/wiki/List-of-standard-variables ! For mandatory variables - e.g. cell thinkness it is not necessary to obtain an id. ! Interior variables ! id_alkalinity_expressed_as_mole_equivalent ! id_attenuation_coefficient_of_photosynthetic_radiative_flux ! id_attenuation_coefficient_of_shortwave_flux !type (type_fabm_interior_variable_id) :: id_cell_thickness real ( rke ), allocatable , target :: dz (:,:,:) type ( type_fabm_interior_variable_id ) :: id_density real ( rke ), allocatable , target :: rho_fabm (:,:,:) !type (type_fabm_interior_variable_id) :: id_depth real ( rke ), allocatable , target :: depth (:,:,:) type ( type_fabm_interior_variable_id ) & id_downwelling_photosynthetic_radiative_flux real ( rke ), allocatable , target :: & downwelling_photosynthetic_radiative_flux (:,:,:) ! id_downwelling_shortwave_flux ! id_fractional_saturation_of_oxygen ! id_mass_concentration_of_suspended_matter ! id_mole_concentration_of_ammonium ! id_mole_concentration_of_carbonate_expressed_as_carbon ! id_mole_concentration_of_dissolved_inorganic_carbon ! id_mole_concentration_of_dissolved_iron ! id_mole_concentration_of_nitrate ! id_mole_concentration_of_phosphate ! id_mole_concentration_of_silicate ! id_net_rate_of_absorption_of_shortwave_energy_in_layer ! id_ph_reported_on_total_scale type ( type_fabm_interior_variable_id ) :: id_practical_salinity real ( rke ), allocatable , target :: salt (:,:,:) type ( type_fabm_interior_variable_id ) :: id_pressure real ( rke ), allocatable , target :: pressure (:,:,:) ! id_secchi_depth !type (type_fabm_interior_variable_id) :: id_temperature ! Surface variables ! id_cloud_area_fraction ! id_ice_area_fraction type ( type_fabm_horizontal_variable_id ) :: & id_mole_fraction_of_carbon_dioxide_in_air real ( rke ), allocatable , target :: & mole_fraction_of_carbon_dioxide_in_air (:,:) ! id_surface_air_pressure ! id_surface_albedo !KB ipsw - 1 cal cm-2 s-1 = 41868 W/m2 type ( type_fabm_horizontal_variable_id ) :: & id_surface_downwelling_photosynthetic_radiative_flux real ( rke ), allocatable , target :: & surface_downwelling_photosynthetic_radiative_flux (:,:) ! id_surface_downwelling_photosynthetic_radiative_flux_in_air type ( type_fabm_horizontal_variable_id ) :: & id_surface_swr_flux real ( rke ), allocatable , target :: & surface_swr_flux (:,:) ! id_surface_downwelling_shortwave_flux_in_air ! id_surface_drag_coefficient_in_air ! id_surface_specific_humidity ! id_surface_temperature type ( type_fabm_horizontal_variable_id ) :: id_windspeed real ( rke ), allocatable , target :: windspeed (:,:) ! Bottom variables ! id_bottom_depth ! id_bottom_depth_below_geoid ! id_bottom_roughness_length type ( type_fabm_horizontal_variable_id ) :: id_bottom_stress real ( rke ), allocatable , target :: bottom_stress (:,:) ! Global variables ! id_number_of_days_since_start_of_the_year ! Universal variables ! id_total_carbon ! id_total_iron ! id_total_nitrogen ! id_total_phosphorus ! id_total_silicate ! horizontal FABM ids ! interior FABM variables - calculated from UVic_ESCM variables ! horizontal FABM variables ! public available routines public fabm_configure public fabm_sbc_init public fabm_tracer_init public fabm_link_data public fabm_initialize_state public ta_fabm_tsi public fabm_rest_in , fabm_rest_def , fabm_rest_out public fabm_tsi_def , fabm_tsi_out public fabm_tavg_def_4d , fabm_tavg_out_4d public fabm_list public fabm_update public fabm_clean ! module level variables - static or allocatable? Same goes ! with e.g. windspeed and rho_fabm integer , parameter :: offset = nsrc - nfabm + 1 cinteger, parameter :: npel=nt-2 real ( rke ) :: pelagic_sms ( imt , km , 1 , nfabm ) !! pelagic source-sink terms in one j-stride real ( rke ) :: surface_flux ( imt , jmt , nfabm ) !! surface fluxes real ( rke ) :: surface_sms ( imt , jmt , nfabm ) !! surface source-sink terms real ( rke ) :: bottom_flux ( imt , jmt , nfabm ) !! bottom fluxes real ( rke ) :: bottom_sms ( imt , jmt , nfabm ) !! bottom source-sink terms creal(rke) :: w(imt,km,jsmw:jemw,nfabm) !KBreal(rke) :: w(imt,km,jmt,nt-2) real ( rke ) :: w ( imt , km , nt - 2 ) !! vertical velocity in m/s real ( rke ) :: tai_fabm ( nt - 2 ) !! time averaged variables integer :: nsurface integer :: npelagic integer :: nbottom logical , parameter :: repair = . true . logical :: valid_pel , valid_surf , valid_bott !! @note !! The variables to hold surface, pelagic and bottom state variables !! comes from mw.h - included in a O_fabm compilation clause !! @endnote c----------------------------------------------------------------------- contains c----------------------------------------------------------------------- subroutine fabm_configure ( dt , yaml_file ) !! read fabm.yaml and call FABM configuration subroutines real ( rke ), intent ( in ) :: dt !! bio-geochemical time step as set by MOM2 [s] character ( len =* ), intent ( in ), optional :: yaml_file !! name of alternativ FABM configuration file integer :: n print * , '==> Initializing FABM with (nt, nsrc, numbsc) =' , & nt , nsrc , numsbc if ( present ( yaml_file )) then model => fabm_create_model ( trim ( yaml_file )) else model => fabm_create_model ( 'fabm.yaml' ) end if nsurface = size ( model % surface_state_variables ) npelagic = size ( model % interior_state_variables ) nbottom = size ( model % bottom_state_variables ) if ( nfabm . ne . npelagic ) then print * , 'nt (UVic)     = ' , nt print * , 'nsrc (UVic)   = ' , nsrc print * , 'numsbc (UVic) = ' , numsbc print * , 'nsurface      = ' , nsurface print * , 'npelagic      = ' , npelagic print * , 'nbottom       = ' , nbottom stop 'fabm_configure()' end if #ifdef DEBUG print * , imt , jmt , jmw !print*, jrow,js,je,is,ie print * , 'zt: ' , shape ( zt ) print * , 't: ' , shape ( t ) print * , 'sbc: ' , shape ( sbc ) print * , 'src: ' , shape ( src ) ! imt,km,jsmw:jemw,nsrc print * , 'source: ' , shape ( source ) ! imt,km,jsmw:jemw print * , 'rho: ' , shape ( rho ) !stop 112 #endif call model % set_domain ( imt , km , jmt , dt ) call model % set_domain_start ( 2 , 1 , 2 ) call model % set_domain_stop ( imt - 1 , km , jmt - 1 ) call model % set_mask ( tmask , tmask (:, 1 ,:)) call model % set_bottom_index ( kmt ) !! @note !! seems tmask is not initialised until called in mom() - !! i.e. after initialization - so all values are 0 here !! @endnote end subroutine fabm_configure c----------------------------------------------------------------------- subroutine fabm_sbc_init ( m ) !! surface boundary data are handled via sbc(imt,jmt,numsbc) in !! setmom.F, tracer.F, gosbc.F, embmio.F integer , intent ( inout ) :: m !! number of handled variables handled so far integer :: n , nn associate ( VAR => model % interior_state_variables ) nn = m do n = 1 , size ( model % interior_state_variables ) mapsbc ( nn ) = 'ss' // trim ( VAR ( n )% name ) mapsbc ( nn + 1 ) = trim ( VAR ( n )% name ) // 'flx' nn = nn + 2 !mapsbc(m+n) = m+n end do end associate m = m + 2 * numsbc_fabm end subroutine fabm_sbc_init c----------------------------------------------------------------------- subroutine fabm_tracer_init ( m ) !! surface boundary data are handled via sbc(imt,jmt,numsbc) in !! setmom.F, tracer.F, gosbc.F, embmio.F integer , intent ( inout ) :: m !! number of handled variables handled so far integer :: n ! need to get mapt populated early - setmom() -> mom_rest_in() associate ( VAR => model % interior_state_variables ) !KB         print*, 'AAA ', mapt do n = 1 , size ( model % interior_state_variables ) mapt ( m + n ) = trim ( VAR ( n )% name ) mapst ( m + n - 4 ) = 's' // trim ( VAR ( n )% name ) itrc ( m + n - 4 ) = m + n end do #if 0 print * , 'AAA ' , mapt print * , mapst stop 'kaj' #endif end associate end subroutine fabm_tracer_init c----------------------------------------------------------------------- subroutine rowi_fabm () !! this is done in fabm_initialize_state() - but check !!KB !! setmom.F - if (.not. init) then - around line 299 integer :: n associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic !   t(:,:,:,n,1) = VAR(n)%c0 end do end associate end subroutine rowi_fabm c----------------------------------------------------------------------- subroutine fabm_rest_in ( iou , ln , ib , ic , tmpik , ils , ile , kls , kle , tau ) !! reading FABM restart variables from NetCDF integer , intent ( in ) :: iou !! NetCDF file id integer , intent ( in ) :: ln !! data length integer , intent ( in ) :: ib (:) !! array of start indices integer , intent ( in ) :: ic (:) !! array of counts real , intent ( inout ) :: tmpik ( ils : ile , kls : kle ) !! array for present data slice integer , intent ( in ) :: ils !! start index - i integer , intent ( in ) :: ile !! end index - i integer , intent ( in ) :: kls !! start index - k integer , intent ( in ) :: kle !! end index - k integer , intent ( in ) :: tau !! time index - -1:1 real , parameter :: c0 = 0. real , parameter :: c1 = 1. character ( 1 ) :: x ! to distinguise between tau and taup1 integer :: j ! j row slice integer :: n ! counter if ( tau == 0 ) x = '1' if ( tau == 1 ) x = '2' j = ib ( 2 ) associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic tmpik ( ils : ile , kls : kle ) = t ( ils : ile , kls : kle , j , n , tau ) call getvara ( trim ( VAR ( n )% name ) // x , iou , ln , ib , ic , & tmpik , c1 , c0 ) t ( ils : ile , kls : kle , j , n , tau ) = tmpik ( ils : ile , kls : kle ) end do end associate end subroutine fabm_rest_in c----------------------------------------------------------------------- subroutine fabm_rest_def ( iou , it ) !! define FABM restart variables in NetCDF context integer , intent ( in ) :: iou !! NetCDF file id integer , intent ( in ) :: it (:) !! time dimension integer :: n associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic call defvar ( trim ( VAR ( n )% name ) // '1' , iou , 4 , it , & VAR ( n )% minimum , VAR ( n )% maximum , ' ' , 'D' , & trim ( VAR ( n )% long_name ) // ' at tau' , ' ' , & trim ( VAR ( n )% units )) call defvar ( trim ( VAR ( n )% name ) // '2' , iou , 4 , it , & VAR ( n )% minimum , VAR ( n )% maximum , ' ' , 'D' , & trim ( VAR ( n )% long_name ) // ' at tau+1' , ' ' , & trim ( VAR ( n )% units )) end do end associate end subroutine fabm_rest_def c----------------------------------------------------------------------- subroutine fabm_rest_out ( iou , ln , ib , ic , tmpik , ils , ile , kls , kle , tau ) !! save 4D data to the NetCDF file given by iou integer , intent ( in ) :: iou !! NetCDF file id integer , intent ( in ) :: ln !! data length integer , intent ( in ) :: ib (:) !! array of start indices integer , intent ( in ) :: ic (:) !! array of counts real , intent ( inout ) :: tmpik ( ils : ile , kls : kle ) !! mask array for present data slice integer , intent ( in ) :: ils !! start index - i integer , intent ( in ) :: ile !! end index - i integer , intent ( in ) :: kls !! start index - k integer , intent ( in ) :: kle !! end index - k integer , intent ( in ) :: tau !! time index - -1:1 real , parameter :: c0 = 0. real , parameter :: c1 = 1. character ( 1 ) :: x ! to distinguise between tau and taup1 integer :: j ! j row slice integer :: n ! counter if ( tau == 0 ) x = '1' if ( tau == 1 ) x = '2' j = ib ( 2 ) associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic ! j row slice tmpik ( ils : ile , kls : kle ) = t ( ils : ile , kls : kle , j , n , tau ) call putvara ( trim ( VAR ( n )% name ) // x , iou , ln , ib , ic , & tmpik , c1 , c0 ) end do end associate end subroutine fabm_rest_out c----------------------------------------------------------------------- subroutine ta_fabm_tsi ( m , ntatio , tbar ) !! define FABM variables in NetCDF context integer , intent ( in ) :: m !! switch operations integer , intent ( in ), optional :: ntatio !! switch operations real , intent ( in ), optional :: tbar (:) !! slice of UVic maintained temporary variable integer :: n real :: rntatio if ( m . eq . 0 ) then ! initialize tai_fabm = 0. else if ( m . eq . 1 ) then ! accumulate tai_fabm (:) = tai_fabm (:) + tbar (:) else if ( m . eq . 2 . and . ntatio . ne . 0 ) then rntatio = 1. / float ( ntatio ) tai_fabm (:) = tai_fabm (:) * rntatio end if end subroutine ta_fabm_tsi c----------------------------------------------------------------------- subroutine fabm_tsi_def ( iou , id ) !! define FABM time series variables in NetCDF context integer , intent ( in ) :: iou !! NetCDF file id integer , intent ( in ) :: id ( 1 ) !! time dimension integer :: n associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic call defvar ( 'O_' // trim ( VAR ( n )% name ), iou , 1 , id , & VAR ( n )% minimum , VAR ( n )% maximum , ' ' , 'F' , & trim ( VAR ( n )% long_name ), ' ' , trim ( VAR ( n )% units )) end do end associate end subroutine fabm_tsi_def c----------------------------------------------------------------------- subroutine fabm_tsi_out ( iou , ntrec ) !! define FABM variables in NetCDF context integer , intent ( in ) :: iou !! NetCDF file id integer , intent ( in ) :: ntrec !! time record integer :: n real , parameter :: c0 = 0. real , parameter :: c1 = 1. associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic call putvars ( 'O_' // trim ( VAR ( n )% name ), iou , ntrec , & tai_fabm ( n ), c1 , c0 ) end do end associate end subroutine fabm_tsi_out c----------------------------------------------------------------------- subroutine fabm_tavg_def_4d ( iou , it ) !! define FABM variables in NetCDF context integer , intent ( in ) :: iou !! NetCDF file id integer , intent ( in ) :: it (:) !! array of dimension ids integer :: j , k , n real , parameter :: c0 = 0. real , parameter :: c1 = 1. real , parameter :: c100 = 10 0. real , parameter :: c500 = 50 0. associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic !            call defvar ('O_'//trim(mapt(2+n)), iou, 4, it, print * , 'O_' // trim ( VAR ( n )% name ) call defvar ( 'O_' // trim ( VAR ( n )% name ), iou , 4 , it , & VAR ( n )% minimum , VAR ( n )% maximum , ' ' , 'F' , & trim ( VAR ( n )% long_name ), ' ' , trim ( VAR ( n )% units )) end do end associate end subroutine fabm_tavg_def_4d c----------------------------------------------------------------------- !subroutine fabm_tavg_out_4d(iou,ln,ib,ic,s,o) subroutine fabm_tavg_out_4d ( iou , ln , ib , ic , & tmpijkm , ils , ile , jls , jle , kls , kle , & t , ids , ide , jds , jde , km , nt ) !! save 4D data to the NetCDF file given by iou integer , intent ( in ) :: iou !! NetCDF file id integer , intent ( in ) :: ln !! data length integer , intent ( in ) :: ib (:) !! array of start indices integer , intent ( in ) :: ic (:) !! array of counts real , intent ( in ) :: tmpijkm ( ils : ile , jls : jle , kls : kle ) !! mask array for present data slice integer , intent ( in ) :: ils !! start index - i integer , intent ( in ) :: ile !! end index - i integer , intent ( in ) :: jls !! start index - j integer , intent ( in ) :: jle !! end index - j integer , intent ( in ) :: kls !! start index - k integer , intent ( in ) :: kle !! end index - k real , intent ( in ) :: t ( ids : ide , jds : jde , km , nt ) !! UVic maintained data array slice integer , intent ( in ) :: ids !! start index - i integer , intent ( in ) :: ide !! end index - i integer , intent ( in ) :: jds !! start index - j integer , intent ( in ) :: jde !! end index - j integer , intent ( in ) :: km !! index - k integer , intent ( in ) :: nt !! number of tracers integer :: i , j , k , n ! counter !KB - should maybe be arguments - or picked from !     somewhere else real , parameter :: s = 1. real , parameter :: o = 0. real , allocatable :: tmpijk (:,:,:) ! t(ids:ide,jds:jde,km,nt) allocate ( tmpijk ( ils : ile , jls : jle , kls : kle ) ) associate ( VAR => model % interior_state_variables ) do n = 1 , npelagic #if 1 tmpijk ( ils : ile , jls : jle , kls : kle ) = & t ( ils : ile , jls : jle , kls : kle , n + 2 ) #else do j = jls , jle do k = kls , kle do i = ils , ile tmpijk ( i , j , k ) = t ( i , k , j , n + 2 , 0 ) end do end do end do #endif call putvaramsk ( 'O_' // trim ( VAR ( n )% name ), iou , ln , & ib , ic , tmpijk , tmpijkm , s , o ) end do end associate deallocate ( tmpijk ) end subroutine fabm_tavg_out_4d c----------------------------------------------------------------------- subroutine fabm_link_data () !! link all FABM configured external dependencies - and call !! model%start() to assure proper configuration integer :: n ! link to time in-dependent data that do require transformation call link_grid () ! link to time dependent data that do NOT require transformation call model % link_interior_data ( & fabm_standard_variables % temperature , t (:,:,:, itemp , 0 )) ! link to time dependent data that do require transformation ! initialize and update time changing environmental variables call link_wind () call link_mole_fraction_of_carbon_dioxide_in_air () ckb         call link_surface_downwelling_photosynthetic_radiative_flux() call link_surface_swr_flux () call link_bottom_stress () ckb         call link_downwelling_photosynthetic_radiative_flux() call link_salinity () call link_density () ! link to FABMs surface state variables do n = 1 , nsurface ! call model%link_surface_state_data(n, sed(:,:,n)) end do ! link to FABMs interior state variables do n = 1 , size ( model % interior_state_variables ) call model % link_interior_state_data ( n , t (:,:,:, 2 + n , 0 )) itrc ( n + 2 ) = n + 2 !KBmapst(2+n) = 's'//trim(mapt(2+n)) end do ! link to FABMs bottom state variables do n = 1 , nbottom call model % link_bottom_state_data ( n , sed (:,:, n )) end do call model % start () end subroutine fabm_link_data c----------------------------------------------------------------------- subroutine fabm_initialize_state () !! the initialization must be split form the linking as the !! masks are not yet calculated integer :: j , k logical , save :: first = . true . if (. not . first ) return ! careful if not full window first = . false . ! fill the surface state if ( nsurface > 0 ) then do j = 2 , jmt - 1 call model % initialize_surface_state ( 2 , imt - 1 , j ) end do end if ! fill the interior state do j = 2 , jmt - 1 do k = 1 , km call model % initialize_interior_state ( 2 , imt - 1 , k , j ) end do end do t (:,:,:, offset :, 1 ) = t (:,:,:, offset :, 0 ) ! initial values must be in tau+1 slice ! fill the bottom state if ( nbottom > 0 ) then do j = 2 , jmt - 1 call model % initialize_bottom_state ( 2 , imt - 1 , j ) end do end if end subroutine fabm_initialize_state c----------------------------------------------------------------------- subroutine fabm_list () !! lists all FABM configured variables integer :: n print * , 'FABM interior state variables:' do n = 1 , size ( model % interior_state_variables ) print * , n , & trim ( model % interior_state_variables ( n )% name ), '  ' , & trim ( model % interior_state_variables ( n )% units ), '  ' , & trim ( model % interior_state_variables ( n )% long_name ) end do print * , 'FABM surface-bound state variables:' do n = 1 , size ( model % surface_state_variables ) print * , n , & trim ( model % surface_state_variables ( n )% name ), '  ' , & trim ( model % surface_state_variables ( n )% units ), '  ' , & trim ( model % surface_state_variables ( n )% long_name ) end do print * , 'FABM bottom-bound state variables:' do n = 1 , size ( model % bottom_state_variables ) print * , n , & trim ( model % bottom_state_variables ( n )% name ), '  ' , & trim ( model % bottom_state_variables ( n )% units ), '  ' , & trim ( model % bottom_state_variables ( n )% long_name ) end do #if 0 print * , ' FABM diagnostic variables defined on the full model do main:' do n = 1 , size ( model % interior_diagnostic_variables ) print * , n , & trim ( model % interior_diagnostic_variables ( n )% name ), ' ', & trim ( model % interior_diagnostic_variables ( n )% units ), ' ', & trim ( model % interior_diagnostic_variables ( n )% long_name ) end do print * , ' FABM diagnostic variables defined on a horizontal slic e of the model domain:' do n = 1 , size ( model % horizontal_diagnostic_variables ) print * , n , & trim ( model % horizontal_diagnostic_variables ( n )% name ), '  ', & trim ( model % horizontal_diagnostic_variables ( n )% units ), '  ', & trim ( model % horizontal_diagnostic_variables ( n )% long_na me) end do #endif end subroutine fabm_list c----------------------------------------------------------------------- subroutine fabm_update ( joff , js , je , is , ie ) !! update the environment and calculate the source/sink terms - !! is called with the same argument list as mom() calls tracer() !! i.e. the specification of the active UVic window - typically !! the full domain on modern hardware integer , intent ( in ) :: joff !! offset row in global window integer , intent ( in ) :: js !! start row integer , intent ( in ) :: je !! end row integer , intent ( in ) :: is !! start column integer , intent ( in ) :: ie !! end column integer :: i , j , k , n ! local loop counters real :: wloc real :: flux #ifdef DEBUG !print*, 'fabm_update:',joff,js,je,is,ie !print*, 'fabm_update:',t(53,1,53,itemp,1),src(53,1,53,3:6) !print*, 'fabm_update:',t(53,1,53,itemp,1),t(53,1,53,3:6,0) #endif surface_flux = 0._rke surface_sms = 0._rke pelagic_sms = 0._rke bottom_flux = 0._rke bottom_sms = 0._rke src = 0._rke ! t(:,:,:,var,0) is updated in loadmw() in mom() ! this is done before the call to tracer() - and thus ! data are ready here call update_data ( joff ) #if defined O_fabm_check_state if ( nsurface > 0 ) then do j = js , je call model % check_surface_state ( is , ie , j , repair , & valid_surf ) end do end if if ( npelagic > 0 ) then do j = js , je do k = 1 , km call model % check_interior_state ( is , ie , k , j , repair , & valid_pel ) end do end do end if if ( nbottom > 0 ) then do j = js , je call model % check_bottom_state ( is , ie , j , repair , & valid_bott ) end do end if #endif call model % prepare_inputs () ! update the surface if ( nsurface > 0 ) then do j = js , je call model % get_surface_sources ( is , ie , j , & surface_flux ( is : ie , j ,:), surface_sms ( is : ie , j ,:)) end do end if ! update the pelagic do j = js , je pelagic_sms = 0._rke do k = 1 , km call model % get_interior_sources ( is , ie , k , j , & pelagic_sms ( is : ie , k , 1 ,:)) end do src ( is : ie ,:, j , offset :) = pelagic_sms ( is : ie ,:, 1 ,:) end do ! update the bottom if ( nbottom > 0 ) then do j = js , je call model % get_bottom_sources ( is , ie , j , & bottom_flux ( is : ie , j ,:), bottom_sms ( is : ie , j ,:)) end do end if ! fold the surface and bottom flux terms do j = js , je do i = is , ie if ( kmt ( i , j ) > 0 ) then k = 1 ! surface src ( i , k , j , offset :) = src ( i , k , j , offset :) + & surface_flux ( i , j ,:) / dz ( i , k , j ) k = kmt ( i , j ) ! bottom src ( i , k , j , offset :) = src ( i , k , j , offset :) + & bottom_flux ( i , j ,:) / dz ( i , k , j ) end if end do end do ! vertical velocities do j = js , je do k = 1 , km call model % get_vertical_movement ( is , ie , k , j , w ( is : ie , k ,:)) end do ! do vertical advection - first-order upstream do n = 1 , npelagic if ( . not . ( any ( w ( is : ie ,:, n ) /= 0.0_rke ))) cycle do i = is , ie do k = 1 , kmt ( i , j ) - 1 wloc = - 0.5_rke * ( w ( i , k , n ) + w ( i , k + 1 , n )) if ( wloc > 0.0_rke ) then flux = wloc * t ( i , k , j , n , 0 ) else flux = wloc * t ( i , k + 1 , j , n , 0 ) end if t ( i , k , j , n , 0 ) = t ( i , k , j , n , 0 ) - flux / dz ( i , k , j ) t ( i , k + 1 , j , n , 0 ) = t ( i , k + 1 , j , n , 0 ) + flux / dz ( i , k + 1 , j ) end do end do end do end do call model % finalize_outputs () end subroutine fabm_update c----------------------------------------------------------------------- subroutine fabm_clean () !! de-allocate all allocated arrays if ( allocated ( windspeed )) deallocate ( windspeed ) if ( allocated ( mole_fraction_of_carbon_dioxide_in_air )) & deallocate ( mole_fraction_of_carbon_dioxide_in_air ) c      if (allocated(surface_downwelling_photosynthetic_radiative_flux)) c     &    deallocate(surface_downwelling_photosynthetic_radiative_flux) if ( allocated ( surface_swr_flux )) deallocate ( surface_swr_flux ) if ( allocated ( bottom_stress )) deallocate ( bottom_stress ) if ( allocated ( salt )) deallocate ( salt ) if ( allocated ( downwelling_photosynthetic_radiative_flux )) & deallocate ( downwelling_photosynthetic_radiative_flux ) if ( allocated ( rho_fabm )) deallocate ( rho_fabm ) end subroutine fabm_clean c----------------------------------------------------------------------- subroutine update_data ( joff ) !! update all time varying FABM configured external dependencies !! by calling individual update routines - tests done in routines integer , intent ( in ) :: joff !! offset row in global window ! dic, carbon_14, alk, n03, 02, n2? call update_wind () call update_mole_fraction_of_carbon_dioxide_in_air () c         call update_surface_downwelling_photosynthetic_radiative_flux() call update_surface_swr_flux () call update_bottom_stress ( joff ) c         call update_downwelling_photosynthetic_radiative_flux() call update_salinity () call update_density () end subroutine update_data c----------------------------------------------------------------------- subroutine link_grid () !! Allocate and link grid related FABM standard variables that !! are being transformed from UVic native variables [cm -> m]. integer :: rc ! status variable integer :: i , j , k ! local loop counters !            print*, zt/100._rke !            print*, (dzt/100._rke) !            print*, zw/100._rke !            print*, dzw/100._rke !            stop 'egon' allocate ( depth ( imt , km , jmt ), stat = rc ) if ( rc /= 0 ) stop 'link_grid(): Error allocating (depth)' depth = 0._rke allocate ( pressure ( imt , km , jmt ), stat = rc ) if ( rc /= 0 ) stop 'link_grid(): Error allocating (pressure)' pressure = 0._rke allocate ( dz ( imt , km , jmt ), stat = rc ) if ( rc /= 0 ) stop 'link_grid(): Error allocating (dz)' dz = 0._rke do j = 2 , jmt - 1 do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) then depth ( i , 1 : kmt ( i , j ), j ) = zt ( 1 : kmt ( i , j )) / 10 0._rke pressure ( i , 1 : kmt ( i , j ), j ) = & depth ( i , 1 : kmt ( i , j ), j ) / 1 0._rke dz ( i , 1 : kmt ( i , j ), j ) = dzt ( 1 : kmt ( i , j )) / 10 0._rke end if end do end do call model % link_interior_data ( & fabm_standard_variables % depth , depth ) call model % link_interior_data ( & fabm_standard_variables % pressure , pressure ) call model % link_interior_data ( & fabm_standard_variables % cell_thickness , dz ) #if 0 print * , depth ( 53 ,:, 53 ), pressure (: 53 ,:, 53 ), dz ( 53 ,:, 53 ) stop 'egon' #endif end subroutine link_grid c----------------------------------------------------------------------- subroutine link_wind () !! get wind speed FABM standard variable and if needed by FABM !! allocate memory integer rc ! status variable id_windspeed = model % get_horizontal_variable_id ( & standard_variables % wind_speed ) if ( model % variable_needs_values ( id_windspeed )) then allocate ( windspeed ( imt , jmt ), stat = rc ) if ( rc /= 0 ) stop & 'link_wind(): Error allocating (windspeed)' windspeed = 0._rke call model % link_horizontal_data ( id_windspeed , windspeed ) end if end subroutine link_wind c----------------------------------------------------------------------- subroutine update_wind () !! calculate wind speed in m/s according to !! w = w_{UVic}/100 ! the wind speed in m/s - iws, iaws integer i , j ! local loop counters if ( model % variable_needs_values ( id_windspeed )) then do j = 2 , jmt - 1 do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) windspeed ( i , j ) = & sbc ( i , j , iws ) / 10 0._rke end do end do end if end subroutine update_wind c----------------------------------------------------------------------- subroutine link_mole_fraction_of_carbon_dioxide_in_air () integer i , j , rc ! local loop counters id_mole_fraction_of_carbon_dioxide_in_air = model % & get_horizontal_variable_id ( standard_variables % & mole_fraction_of_carbon_dioxide_in_air ) if ( model % variable_needs_values ( & id_mole_fraction_of_carbon_dioxide_in_air )) then allocate ( mole_fraction_of_carbon_dioxide_in_air ( imt , jmt ), & stat = rc ) if ( rc /= 0 ) stop & ' link_mole_fraction_of_carbon_dioxide_in_air (): & Error allocating ( mole_fraction_of_carbon_dioxide_in_air ) ' mole_fraction_of_carbon_dioxide_in_air = 0._rke call model % link_horizontal_data ( & id_mole_fraction_of_carbon_dioxide_in_air , & mole_fraction_of_carbon_dioxide_in_air ) end if end subroutine link_mole_fraction_of_carbon_dioxide_in_air c----------------------------------------------------------------------- subroutine update_mole_fraction_of_carbon_dioxide_in_air () !! calculate the ?????? in W/m&#94;2 integer i , j ! local loop counters if ( model % variable_needs_values ( & id_mole_fraction_of_carbon_dioxide_in_air )) then do j = 2 , jmt - 1 do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) then mole_fraction_of_carbon_dioxide_in_air ( i , j ) = & 1 0._rke !KB end if end do end do end if end subroutine update_mole_fraction_of_carbon_dioxide_in_air c----------------------------------------------------------------------- #if 0 subroutine link_surface_downwelling_photosynthetic_radiative_flux ( ) integer rc ! status variable id_surface_downwelling_photosynthetic_radiative_flux = model % & get_horizontal_variable_id ( standard_variables % & surface_downwelling_photosynthetic_radiative_flux ) if ( model % variable_needs_values ( id_surface_downwelling_photosynthetic_radiative_flux )) then allocate ( surface_downwelling_photosynthetic_radiative_flux ( i mt,jmt),stat=rc) if ( rc /= 0 ) stop ' link_surface_downwelling_photosynthetic_r adiative_flux(): & Error allocating ( surface_downwelling_photosynthetic_ radiative_flux)' surface_downwelling_photosynthetic_radiative_flux = 0._rke call model % link_horizontal_data ( & id_surface_downwelling_photosynthetic_radiative_flux , & surface_downwelling_photosynthetic_radiative_flux ) end if end subroutine link_surface_downwelling_photosynthetic_radiative_f lux c----------------------------------------------------------------------- s ubroutine update_surface_downwelling_photosynthetic_radiative_flux () !! calculate the ?????????? flux in W/m&#94;2 integer i , j ! local loop counters if ( model % variable_needs_values ( id_surface_downwelling_photosynt hetic_radiative_flux)) then do j = 2 , jmt - 1 do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) surface_downwelling_photosynthetic_ra diative_flux(i,j) = 200._rke !KB end do end do end if e nd subroutine update_surface_downwelling_photosynthetic_radiative_ flux #endif c----------------------------------------------------------------------- subroutine link_surface_swr_flux () integer rc ! status variable id_surface_swr_flux = model % & get_horizontal_variable_id ( standard_variables % & surface_downwelling_shortwave_flux ) if ( model % variable_needs_values ( id_surface_swr_flux )) then allocate ( surface_swr_flux ( imt , jmt ), stat = rc ) if ( rc /= 0 ) stop ' link_surface_swr_flux (): & Error allocating ( surface_swr_flux ) ' surface_swr_flux = 0._rke call model % link_horizontal_data ( id_surface_swr_flux , & surface_swr_flux ) end if end subroutine link_surface_swr_flux c----------------------------------------------------------------------- subroutine update_surface_swr_flux () !! @note !! This calculation of the surface swr uses the flux directly !! from the atmospheric model - must be corrected for ice at !! some point. !! !! alternatively the gl variable in tracer.F90 !! @endnote !! !! calculate the short wave flux in W/m&#94;2 according to !! I_0 = 41868\\ (W/m²)/(cal/cm²/s)\\ I_{0_{UVic}}\\ !! cal/cm²/s¹ !! !! carefull with the time averaged value integer i , j ! local loop counters !KB         if (model%variable_needs_values(id_surface_swr_flux)) then do j = 2 , jmt - 1 do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) surface_swr_flux ( i , j ) = & 0.001 * dnswr ( i , j ) end do end do !KB         end if end subroutine update_surface_swr_flux c----------------------------------------------------------------------- subroutine link_bottom_stress () !! get bottom stress FABM standard variable and if needed by !! FABM allocate memory integer rc ! status variable id_bottom_stress = model % get_horizontal_variable_id ( & standard_variables % bottom_stress ) if ( model % variable_needs_values ( id_bottom_stress )) then allocate ( bottom_stress ( imt , jmt ), stat = rc ) if ( rc /= 0 ) stop ' link_bottom_stress (): & Error allocating ( bottom_stress ) ' bottom_stress = 0._rke call model % link_horizontal_data ( & id_bottom_stress , bottom_stress ) end if end subroutine link_bottom_stress c----------------------------------------------------------------------- subroutine update_bottom_stress ( joff ) !! calculate the bottom stress in Pa integer , intent ( in ) :: joff !! offset row in global window real ( rke ), parameter :: x = 1 0._rke !! dynes/cm2 --> Pa integer i , j , jrow ! local loop counters if ( model % variable_needs_values ( id_bottom_stress )) then do j = 2 , jmt - 1 jrow = j + joff do i = 2 , imt - 1 if ( kmt ( i , jrow ) > 0 ) then bottom_stress ( i , j ) = x * sqrt ( & bmf ( i , jrow , 1 ) ** 2 + bmf ( i , jrow , 2 ) ** 2 ) end if end do end do end if end subroutine update_bottom_stress c----------------------------------------------------------------------- subroutine link_downwelling_photosynthetic_radiative_flux () !! get salinity FABM standard variable and if needed by FABM !! allocate memory integer rc ! status variable id_downwelling_photosynthetic_radiative_flux = & model % get_interior_variable_id ( & fabm_standard_variables % & downwelling_photosynthetic_radiative_flux ) if ( model % variable_needs_values ( & id_downwelling_photosynthetic_radiative_flux )) then allocate ( & downwelling_photosynthetic_radiative_flux ( imt , km , jmt ), & stat = rc ) if ( rc /= 0 ) stop ' link_salinity (): & Error allocating & ( downwelling_photosynthetic_radiative_flux ) ' downwelling_photosynthetic_radiative_flux = 0._rke call model % link_interior_data ( & id_downwelling_photosynthetic_radiative_flux , & downwelling_photosynthetic_radiative_flux ) end if end subroutine link_downwelling_photosynthetic_radiative_flux c----------------------------------------------------------------------- subroutine update_downwelling_photosynthetic_radiative_flux () !! calculate salinity in PSU according to S = 35 + 1000*S_{UVic} integer i , j , k ! local loop counters if ( model % variable_needs_values ( & id_downwelling_photosynthetic_radiative_flux )) then do j = 2 , jmt - 1 do k = 1 , km do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) then downwelling_photosynthetic_radiative_flux ( i , k , j ) & = 3 5._rk + 100 0._rke * t ( i , k , j , isalt , 0 ) end if end do end do end do end if end subroutine update_downwelling_photosynthetic_radiative_flux c----------------------------------------------------------------------- subroutine link_salinity () !! get salinity FABM standard variable and if needed by FABM !! allocate memory integer rc ! status variable id_practical_salinity = model % get_interior_variable_id ( & fabm_standard_variables % practical_salinity ) if ( model % variable_needs_values ( id_practical_salinity )) then allocate ( salt ( imt , km , jmt ), stat = rc ) if ( rc /= 0 ) stop ' link_salinity (): & Error allocating ( salt ) ' salt = 0._rke call model % link_interior_data ( id_practical_salinity , salt ) end if end subroutine link_salinity c----------------------------------------------------------------------- subroutine update_salinity () !! calculate salinity in PSU according to S = 35 + !! 1000*S_{UVic} integer i , j , k ! local loop counters if ( model % variable_needs_values ( id_practical_salinity )) then do j = 2 , jmt - 1 do k = 1 , km do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) then salt ( i , k , j ) = 3 5._rk + 100 0._rke * t ( i , k , j , isalt , 0 ) end if end do end do end do end if end subroutine update_salinity c----------------------------------------------------------------------- subroutine link_density () !! get density FABM standard variable and if needed by FABM !! allocate  memory integer rc ! status variable id_density = model % get_interior_variable_id ( & fabm_standard_variables % density ) if ( model % variable_needs_values ( id_density )) then allocate ( rho_fabm ( imt , km , jmt ), stat = rc ) if ( rc /= 0 ) stop ' link_density (): & Error allocating ( rho_fabm ) ' rho_fabm = 0._rke call model % link_interior_data ( id_density , rho_fabm ) end if end subroutine link_density c----------------------------------------------------------------------- subroutine update_density () !! calculate density in kg/m³ according to !! \\rho = 1000*(\\rho_0 + \\rho_{UVic}) !! with \\rho_0 = 1.035. MUST match rho0 from UVic_ESCM.F90 !! @note !! loadmw.F: l 154 !! !! imt=102, km=19, jsmw=2, jmw=jmt --- jemw=jmw-1 !! !! declared: rho(imt,km,jsmw:jmw) calculated rho(1:102,2:102) !! rho !! @endnote !! @note !! KB check depth dependent reference density !! @endnote integer i , j , k ! local loop counters real ( rke ), parameter :: rho0 = 1.035 ! reference density if ( model % variable_needs_values ( id_density )) then c do j=1,jmt do j = jsmw , jmw ! must be 2:102 do k = 1 , km do i = 2 , imt - 1 if ( kmt ( i , j ) > 0 ) then rho_fabm ( i , k , j ) = 100 0._rke * ( rho0 + rho ( i , k , j )) end if end do end do end do end if #if 0 print * , rho_fabm ( 53 ,:, 53 ) stop 'kurt' #endif end subroutine update_density c----------------------------------------------------------------------- end module uvic_fabm c-----------------------------------------------------------------------","tags":"","loc":"sourcefile/fabm.f.html"}]}