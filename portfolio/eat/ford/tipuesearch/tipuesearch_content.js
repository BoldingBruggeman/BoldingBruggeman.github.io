var tipuesearch = {"pages":[{"title":" EAT ","text":"EAT Developer Info Karsten Bolding and Jorn Bruggeman","tags":"home","loc":"index.html"},{"title":"eat_config.F90 – EAT","text":"Files dependent on this one sourcefile~~eat_config.f90~~AfferentGraph sourcefile~eat_config.f90 eat_config.F90 sourcefile~pdaf_wrapper.f90 pdaf_wrapper.F90 sourcefile~pdaf_wrapper.f90->sourcefile~eat_config.f90 sourcefile~eat_filter_pdaf.f90 eat_filter_pdaf.F90 sourcefile~eat_filter_pdaf.f90->sourcefile~eat_config.f90 sourcefile~eat_filter_pdaf.f90->sourcefile~pdaf_wrapper.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules eat_config Source Code eat_config.F90 Source Code ! Copyright (C) 2021 Bolding & Bruggeman module eat_config !! Initialize the MPI environment - Fortran side. !! Defined constants here must be matched by Python USE , INTRINSIC :: ISO_FORTRAN_ENV #ifdef _F08_ use mpi_f08 #else use mpi #endif IMPLICIT NONE private public :: init_eat_config , version_mpi_config ! constants used to define communicators integer , parameter , public :: color_obs = 1 integer , parameter , public :: color_model = 2 integer , parameter , public :: color_filter = 4 ! MPI tags integer , parameter , public :: tag_timestr = 1 integer , parameter , public :: tag_nobs = 1 integer , parameter , public :: tag_iobs = 2 integer , parameter , public :: tag_obs = 3 integer , parameter , public :: tag_analysis = 1 integer , parameter , public :: tag_forecast = 2 ! signals used to guide integration integer , parameter , public :: signal_initialize = 1 integer , parameter , public :: signal_integrate = 2 integer , parameter , public :: signal_finalize = 4 integer , parameter , public :: signal_recv_state = 8 integer , parameter , public :: signal_send_state = 16 ! constants used to define logging verbosity integer , parameter , public :: debug = 2048 integer , parameter , public :: info = 1024 integer , parameter , public :: warn = 512 integer , parameter , public :: error = 256 integer , parameter , public :: fatal = 128 integer , parameter , public :: silent = 64 #ifdef _F08_ TYPE ( mpi_comm ), public :: MPI_COMM_obs , MPI_COMM_model #else integer , public :: EAT_COMM_obs = MPI_COMM_NULL integer , public :: EAT_COMM_model = MPI_COMM_NULL integer , public :: EAT_COMM_filter = MPI_COMM_NULL integer , public :: EAT_COMM_obs_model = MPI_COMM_NULL integer , public :: EAT_COMM_obs_filter = MPI_COMM_NULL integer , public :: EAT_COMM_model_filter = MPI_COMM_NULL #endif integer , public :: size_obs_comm =- 1 integer , public :: size_model_comm =- 1 integer , public :: size_filter_comm =- 1 integer , public :: size_obs_model_comm =- 1 integer , public :: size_obs_filter_comm =- 1 integer , public :: size_model_filter_comm =- 1 integer , public :: rank_obs_comm =- 1 integer , public :: rank_model_comm =- 1 integer , public :: rank_filter_comm =- 1 integer , public :: rank_obs_model_comm =- 1 integer , public :: rank_obs_filter_comm =- 1 integer , public :: rank_model_filter_comm =- 1 integer , public :: rank , nprocs integer :: ierr integer :: stderr = error_unit , stdout = output_unit !----------------------------------------------------------------------- contains !----------------------------------------------------------------------- subroutine init_eat_config ( color ) !! Initialize MPI, define communicators and set variables IMPLICIT NONE ! Subroutine arguments integer , intent ( in ) :: color ! Local variables CHARACTER ( LEN = MPI_MAX_PROCESSOR_NAME ) :: pname integer :: len integer :: n logical :: flag !------------------------------------------------------------------------- call MPI_init ( ierr ) if ( ierr /= MPI_SUCCESS ) then write ( 0 , * ) 'Fatal error: unable to initialize MPI.' call MPI_Abort ( MPI_COMM_WORLD , - 1 , ierr ) end if ! Get number of processes call MPI_COMM_SIZE ( MPI_COMM_WORLD , nprocs , ierr ) if ( ierr /= MPI_SUCCESS ) THEN write ( stderr , * ) 'Fatal error: unable to get number of processes.' call MPI_Abort ( MPI_COMM_WORLD , - 1 , ierr ) end if !  Get rank of current in MPI_COMM_WORLD call MPI_COMM_RANK ( MPI_COMM_WORLD , rank , ierr ) if ( ierr /= MPI_SUCCESS ) THEN write ( stderr , * ) 'Fatal error: unable to get RANK.' call MPI_Abort ( MPI_COMM_WORLD , - 1 , ierr ) end if ! Get the processor names call MPI_GET_PROCESSOR_NAME ( pname , len , ierr ) if ( ierr /= MPI_SUCCESS ) THEN write ( stderr , * ) 'Fatal error: unable to get processor name.' call MPI_Abort ( MPI_COMM_WORLD , - 1 , ierr ) end if if ( color >= debug ) then write ( stderr , '(A,I4,A,I4,2A)' ) 'MPI_COMM_WORLD(process) ' , rank , ' of ' , nprocs , ' is alive on ' , pname ( 1 : len ) end if ! Setup inter/intra communicators ! Observations only if ( iand ( color , color_obs ) == color_obs ) then call MPI_Comm_split ( MPI_COMM_WORLD , color_obs , rank , EAT_COMM_obs , ierr ) else call MPI_Comm_split ( MPI_COMM_WORLD , MPI_UNDEFINED , rank , EAT_COMM_obs , ierr ) end if if ( EAT_COMM_obs /= MPI_COMM_NULL ) then call MPI_COMM_SIZE ( EAT_COMM_obs , size_obs_comm , ierr ) call MPI_COMM_RANK ( EAT_COMM_obs , rank_obs_comm , ierr ) else size_obs_comm = 0 end if ! Model only if ( iand ( color , color_model ) == color_model ) then call MPI_Comm_split ( MPI_COMM_WORLD , color_model , rank , EAT_COMM_model , ierr ) else call MPI_Comm_split ( MPI_COMM_WORLD , MPI_UNDEFINED , rank , EAT_COMM_model , ierr ) end if if ( EAT_COMM_model /= MPI_COMM_NULL ) then call MPI_COMM_SIZE ( EAT_COMM_model , size_model_comm , ierr ) call MPI_COMM_RANK ( EAT_COMM_model , rank_model_comm , ierr ) else size_model_comm = 0 end if ! Filter only if ( iand ( color , color_filter ) == color_filter ) then call MPI_Comm_split ( MPI_COMM_WORLD , color_filter , rank , EAT_COMM_filter , ierr ) else call MPI_Comm_split ( MPI_COMM_WORLD , MPI_UNDEFINED , rank , EAT_COMM_filter , ierr ) end if if ( EAT_COMM_filter /= MPI_COMM_NULL ) then call MPI_COMM_SIZE ( EAT_COMM_filter , size_filter_comm , ierr ) call MPI_COMM_RANK ( EAT_COMM_filter , rank_filter_comm , ierr ) else size_filter_comm = 0 end if ! Observations and model if ( iand ( color , color_obs ) == color_obs . or . iand ( color , color_model ) == color_model ) then call MPI_Comm_split ( MPI_COMM_WORLD , color_obs + color_model , rank , EAT_COMM_obs_model , ierr ) else call MPI_Comm_split ( MPI_COMM_WORLD , MPI_UNDEFINED , rank , EAT_COMM_obs_model , ierr ) end if if ( EAT_COMM_obs_model /= MPI_COMM_NULL ) then call MPI_COMM_SIZE ( EAT_COMM_obs_model , size_obs_model_comm , ierr ) end if if ( iand ( color , color_obs ) == color_obs . and . size_obs_comm == size_obs_model_comm ) then EAT_COMM_obs_model = MPI_COMM_NULL end if if ( iand ( color , color_model ) == color_model . and . size_model_comm == size_obs_model_comm ) then EAT_COMM_obs_model = MPI_COMM_NULL end if if ( EAT_COMM_obs_model /= MPI_COMM_NULL ) then call MPI_COMM_RANK ( EAT_COMM_obs_model , rank_obs_model_comm , ierr ) else size_obs_model_comm =- 1 end if ! Observations and filter if ( iand ( color , color_obs ) == color_obs . or . iand ( color , color_filter ) == color_filter ) then call MPI_Comm_split ( MPI_COMM_WORLD , color_obs + color_filter , rank , EAT_COMM_obs_filter , ierr ) else call MPI_Comm_split ( MPI_COMM_WORLD , MPI_UNDEFINED , rank , EAT_COMM_obs_filter , ierr ) end if if ( EAT_COMM_obs_filter /= MPI_COMM_NULL ) then call MPI_COMM_SIZE ( EAT_COMM_obs_filter , size_obs_filter_comm , ierr ) end if if ( iand ( color , color_obs ) == color_obs . and . size_obs_comm == size_obs_filter_comm ) then EAT_COMM_obs_filter = MPI_COMM_NULL end if if ( iand ( color , color_filter ) == color_filter . and . size_filter_comm == size_obs_filter_comm ) then EAT_COMM_obs_filter = MPI_COMM_NULL end if if ( EAT_COMM_obs_filter /= MPI_COMM_NULL ) then call MPI_COMM_RANK ( EAT_COMM_obs_filter , rank_obs_filter_comm , ierr ) else size_obs_filter_comm =- 1 end if ! Model and filter if ( iand ( color , color_model ) == color_model . or . iand ( color , color_filter ) == color_filter ) then call MPI_Comm_split ( MPI_COMM_WORLD , color_model + color_filter , rank , EAT_COMM_model_filter , ierr ) else call MPI_Comm_split ( MPI_COMM_WORLD , MPI_UNDEFINED , rank , EAT_COMM_model_filter , ierr ) end if if ( EAT_COMM_model_filter /= MPI_COMM_NULL ) then call MPI_COMM_SIZE ( EAT_COMM_model_filter , size_model_filter_comm , ierr ) end if if ( iand ( color , color_model ) == color_model . and . size_model_comm == size_model_filter_comm ) then EAT_COMM_model_filter = MPI_COMM_NULL end if if ( iand ( color , color_filter ) == color_filter . and . size_filter_comm == size_model_filter_comm ) then EAT_COMM_model_filter = MPI_COMM_NULL end if if ( EAT_COMM_model_filter /= MPI_COMM_NULL ) then call MPI_COMM_RANK ( EAT_COMM_model_filter , rank_model_filter_comm , ierr ) else size_model_filter_comm =- 1 end if if ( iand ( color , color_obs ) == color_obs . and . color >= info ) then #if 0 write ( stderr , '(A,*(I5))' ) ' obs(ranks: O-OM-OF):    ' , rank_obs_comm , rank_obs_model_comm , rank_obs_filter_comm write ( stderr , '(A,*(I5))' ) ' obs(sizes: O-OM-OF):    ' , size_obs_comm , size_obs_model_comm , size_obs_filter_comm #else write ( stderr , '(A,*(I5))' ) ' obs(ranks and sizes: O-OM-OF):    ' , rank_obs_comm , rank_obs_model_comm , rank_obs_filter_comm , & size_obs_comm , size_obs_model_comm , size_obs_filter_comm #endif end if if ( iand ( color , color_model ) == color_model . and . color >= info ) then #if 0 write ( stderr , '(A,*(I5))' ) ' model(ranks: M-OM-MF):  ' , rank_model_comm , rank_obs_model_comm , rank_model_filter_comm write ( stderr , '(A,*(I5))' ) ' model(sizes: M-OM-OF):  ' , size_model_comm , size_obs_model_comm , size_model_filter_comm #else write ( stderr , '(A,*(I5))' ) ' model(ranks and sizes: M-OM-MF):  ' , rank_model_comm , rank_obs_model_comm , rank_model_filter_comm , & size_model_comm , size_obs_model_comm , size_model_filter_comm #endif end if if ( iand ( color , color_filter ) == color_filter . and . color >= info ) then #if 0 write ( stderr , '(A,*(I5))' ) ' filter(ranks: F-OF-MF): ' , rank_filter_comm , rank_obs_filter_comm , rank_model_filter_comm write ( stderr , '(A,*(I5))' ) ' filter(sizes: F-OF-MF): ' , size_filter_comm , size_obs_filter_comm , size_model_filter_comm #else write ( stderr , '(A,*(I5))' ) ' filter(ranks and sizes: F-OF-MF): ' , rank_filter_comm , rank_obs_filter_comm , rank_model_filter_comm ,& size_filter_comm , size_obs_filter_comm , size_model_filter_comm #endif end if call MPI_Barrier ( MPI_COMM_WORLD , ierr ) end subroutine init_eat_config !----------------------------------------------------------------------- subroutine version_mpi_config ( mpi_version , library_version ) !! Collect MPI and MPI Library version info IMPLICIT NONE ! Subroutine arguments character ( len =* ), intent ( inout ) :: mpi_version , library_version ! Local variables integer :: v , sv , len !------------------------------------------------------------------------- call MPI_get_version ( v , sv , ierr ) write ( mpi_version , '(i1,a1,i1)' ) v , '.' , sv call MPI_Get_library_version ( library_version , len , ierr ) end subroutine version_mpi_config !----------------------------------------------------------------------- end module eat_config","tags":"","loc":"sourcefile/eat_config.f90.html"},{"title":"pdaf_wrapper.F90 – EAT","text":"This file depends on sourcefile~~pdaf_wrapper.f90~~EfferentGraph sourcefile~pdaf_wrapper.f90 pdaf_wrapper.F90 sourcefile~eat_config.f90 eat_config.F90 sourcefile~pdaf_wrapper.f90->sourcefile~eat_config.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pdaf_wrapper.f90~~AfferentGraph sourcefile~pdaf_wrapper.f90 pdaf_wrapper.F90 sourcefile~eat_filter_pdaf.f90 eat_filter_pdaf.F90 sourcefile~eat_filter_pdaf.f90->sourcefile~pdaf_wrapper.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pdaf_wrapper Source Code pdaf_wrapper.F90 Source Code ! Copyright (C) 2021 Bolding & Bruggeman #undef _USE_PDAF_ #define _USE_PDAF_ module pdaf_wrapper !! A wrapper around 'PDAF' USE , INTRINSIC :: ISO_FORTRAN_ENV use eat_config , only : info , debug use pdaf_mod_filter use PDAF_interfaces_module use iso_c_binding , only : c_ptr , c_null_ptr , c_loc , c_int , c_double IMPLICIT NONE private public init_pdaf , assimilation_pdaf , finish_pdaf , iobs , obs , pcvt_callback integer :: stderr = error_unit , stdout = output_unit integer :: verbosity = info integer , pointer , contiguous :: iobs (:) => null () !! map observations to state real ( real64 ), pointer , contiguous :: obs (:) => null () !! observation vector integer :: filtertype = 6 !! PDAF filter selection ! filtertype = 6 ! Type of filter !  (1) SEIK !  (2) EnKF !  (3) LSEIK !  (4) ETKF !  (5) LETKF !  (6) ESTKF !  (7) LESTKF ! (13) 3D-var integer :: subtype = 0 !! PDAF subtype selection REAL ( real64 ) :: timenow integer :: doexit , steps real ( real64 ) :: rms_obs = 0.05 !! Observation error standard deviation !KB shall be replaced interface subroutine cvt_callback_interface ( cb_type , iter , dim_p , dim_cvec , dim_cvec_ens , ens_p , v_p , Vv_p ) bind ( c ) import C_PTR , C_INT INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: cb_type INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: iter !!< Iteration of optimization INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: dim_p !!< PE-local observation dimension INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: dim_cvec !!< Dimension of control vector INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: dim_cvec_ens !!< Dimension of control vector TYPE ( C_PTR ), VALUE , INTENT ( IN ) :: ens_p !!< PE-local ensemble TYPE ( C_PTR ), VALUE , INTENT ( IN ) :: v_p !!< PE-local control vector TYPE ( C_PTR ), VALUE , INTENT ( IN ) :: Vv_p !!< PE-local result vector end subroutine end interface procedure ( cvt_callback_interface ), pointer , save :: pcvt_callback => null () !! user implemented routine (in Python) !----------------------------------------------------------------------- contains !----------------------------------------------------------------------- ! Below are the routines implemented to link to the PDAF library - pdaf-d. SUBROUTINE init_pdaf ( EAT_COMM_filter , state_size , ensemble_size , model_states , stat ) !! Initialize various variable and call PDAF_init() integer , intent ( in ), value :: EAT_COMM_filter , state_size , ensemble_size real ( real64 ), pointer , contiguous :: model_states (:,:) integer , intent ( out ) :: stat INTEGER :: filter_param_i ( 7 ) !! Integer parameter array for filter REAL ( REAL64 ) :: filter_param_r ( 2 ) !! Real parameter array for filter INTEGER :: status_pdaf !! PDAF status flag integer :: screen = 2 !! Write screen output (1) for output, (2) add timings integer :: dim_state_p = - 1 integer :: comm_couple , comm_filter , comm_model , n_modeltasks , task_id logical :: filterpe = . true . ! Filter specific variables integer :: & type_trans = 0 ! Type of ensemble transformation !   SEIK/LSEIK and ESTKF/LESTKF: !     (0) use deterministic omega !     (1) use random orthonormal omega orthogonal to (1,...,1)&#94;T !     (2) use product of (0) with random orthonormal matrix with !         eigenvector (1,...,1)&#94;T !   ETKF/LETKF: !     (0) use deterministic symmetric transformation !     (2) use product of (0) with random orthonormal matrix with !         eigenvector (1,...,1)&#94;T integer :: & type_forget = 0 ! Type of forgetting factor in SEIK/LSEIK/ETKF/LETKF/ESTKF/LESTKF !   (0) fixed !   (1) global adaptive !   (2) local adaptive for LSEIK/LETKF/LESTKF real :: & forget = 1.0 ! Forgetting factor real :: & type_sqrt = 0 ! Type of transform matrix square-root !   (0) symmetric square root, (1) Cholesky decomposition integer :: & incremental = 0 ! (1) to perform incremental updating (only in SEIK/LSEIK!) integer :: & covartype = 1 ! Definition of factor in covar. matrix used in SEIK !   (0) for dim_ens&#94;-1 (old SEIK) !   (1) for (dim_ens-1)&#94;-1 (real ensemble covariance matrix) !   This parameter has also to be set internally in PDAF_init. integer :: & rank_analysis_enkf = 0 ! rank to be considered for inversion of HPH ! in analysis of EnKF; (0) for analysis w/o eigendecomposition ! *** Localization settings integer :: & locweight = 0 ! Type of localizating weighting !   (0) constant weight of 1 !   (1) exponentially decreasing with SRANGE !   (2) use 5th-order polynomial !   (3) regulated localization of R with mean error variance !   (4) regulated localization of R with single-point error variance integer :: & local_range = 0 ! Range in grid points for observation domain in local filters !KB  srange = local_range  ! Support range for 5th-order polynomial ! or range for 1/e for exponential weighting ! File handling logical :: fileexists character ( len = 128 ) :: filename = 'output.dat' character ( len =* ), parameter :: nmlfile = 'eat_pdaf.nml' integer :: nmlunit namelist / nml_config_pdaf / screen , filtertype , subtype , & type_trans , type_forget , forget , & dim_cvec , dim_cvec_ens , beta_3dvar INQUIRE ( FILE = nmlfile , EXIST = fileexists ) if ( fileexists ) then open ( newunit = nmlunit , file = nmlfile , status = 'old' , action = 'read' ) read ( nmlunit , nml = nml_config_pdaf ) close ( nmlunit ) end if ! initialize variables for call to PDAF_init() dim_ens = ensemble_size dim_state_p = state_size comm_couple = EAT_COMM_filter ! suggested by Lars comm_filter = EAT_COMM_filter comm_model = EAT_COMM_filter ! suggested by Lars filterpe = . true . task_id = 1 n_modeltasks = 1 ! values must be provided via namelist dim_cvec =- 1 dim_cvec_ens = dim_ens select case ( filtertype ) case ( 2 ) ! *** EnKF with Monte Carlo init *** filter_param_i ( 1 ) = dim_state_p ! State dimension filter_param_i ( 2 ) = dim_ens ! Size of ensemble filter_param_i ( 3 ) = rank_analysis_enkf ! Rank of speudo-inverse in analysis filter_param_i ( 4 ) = incremental ! Whether to perform incremental analysis filter_param_i ( 5 ) = 0 ! Smoother lag (not implemented here) filter_param_r ( 1 ) = forget ! Forgetting factor call PDAF_set_comm_pdaf ( EAT_COMM_filter ) CALL PDAF_init ( filtertype , subtype , 0 , & filter_param_i , 6 ,& filter_param_r , 2 , & COMM_model , COMM_filter , COMM_couple , & task_id , n_modeltasks , filterpe , init_ens_pdaf , & screen , status_pdaf ) case ( 1 , 3 , 4 , 5 , 6 , 7 ) ! *** All other filters                       *** ! *** SEIK, LSEIK, ETKF, LETKF, ESTKF, LESTKF *** filter_param_i ( 1 ) = dim_state_p ! State dimension filter_param_i ( 2 ) = dim_ens ! Size of ensemble filter_param_i ( 3 ) = 0 ! Smoother lag (not implemented here) filter_param_i ( 4 ) = incremental ! Whether to perform incremental analysis filter_param_i ( 5 ) = type_forget ! Type of forgetting factor filter_param_i ( 6 ) = type_trans ! Type of ensemble transformation filter_param_i ( 7 ) = type_sqrt ! Type of transform square-root (SEIK-sub4/ESTKF) filter_param_r ( 1 ) = forget ! Forgetting factor call PDAF_set_comm_pdaf ( EAT_COMM_filter ) CALL PDAF_init ( filtertype , subtype , 0 , & filter_param_i , 7 ,& filter_param_r , 2 , & COMM_model , COMM_filter , COMM_couple , & task_id , n_modeltasks , filterpe , init_ens_pdaf , & screen , status_pdaf ) case ( 13 ) filter_param_i ( 1 ) = dim_state_p ! State dimension filter_param_i ( 2 ) = dim_ens ! Size of ensemble filter_param_i ( 3 ) = type_opt ! Choose type of optimizer filter_param_i ( 4 ) = dim_cvec ! Dimension of control vector (parameterized part) filter_param_i ( 5 ) = dim_cvec_ens ! Dimension of control vector (ensemble part) filter_param_r ( 1 ) = forget ! Forgetting factor filter_param_r ( 2 ) = beta_3dvar ! Hybrid weight for hybrid 3D-Var select case ( subtype ) case ( 0 ) ! parameterized 3D-Var if ( dim_cvec < 0 ) then call abort ( 'init_pdaf(): dim_cvec < 0' ) end if CALL PDAF_init ( filtertype , subtype , 0 , & filter_param_i , 5 ,& filter_param_r , 1 , & COMM_model , COMM_filter , COMM_couple , & task_id , n_modeltasks , filterpe , init_3dvar_pdaf , & screen , status_pdaf ) case ( 1 ) ! Ensemble or hybrid 3D-Var if ( dim_cvec_ens < 0 ) then call abort ( 'init_pdaf(): dim_cvec_ens < 0' ) end if CALL PDAF_init ( filtertype , subtype , 0 , & filter_param_i , 5 ,& filter_param_r , 2 , & COMM_model , COMM_filter , COMM_couple , & task_id , n_modeltasks , filterpe , init_ens_pdaf , & screen , status_pdaf ) end select case default stop 'init_pdaf(): Non-valid filtertype' end select if ( status_pdaf /= 0 ) stop 'init_pdaf(): status_pdaf /= 0' CALL PDAF_get_state ( steps , timenow , doexit , next_observation_pdaf , & distribute_state_pdaf , prepoststep_ens_pdaf , status_pdaf ) stat = status_pdaf call PDAF_set_ens_pointer ( model_states , stat ) END SUBROUTINE init_pdaf !----------------------------------------------------------------------- SUBROUTINE assimilation_pdaf () bind ( c ) !! local variables INTEGER :: status_pdaf ! Status flag for filter routines call PDAF_force_analysis () ! Suggested by Lars select case ( filtertype ) case ( 1 ) CALL PDAF_put_state_seik ( collect_state_pdaf , init_dim_obs_pdaf , obs_op_pdaf , & init_obs_pdaf , prepoststep_ens_pdaf , prodRinvA_pdaf , init_obsvar_pdaf , status_pdaf ) case ( 2 ) CALL PDAF_put_state_enkf ( collect_state_pdaf , init_dim_obs_pdaf , obs_op_pdaf , & init_obs_pdaf , prepoststep_ens_pdaf , add_obs_error_pdaf , init_obscovar_pdaf , & status_pdaf ) case ( 3 ) CALL PDAF_put_state_lseik ( & collect_state_pdaf , init_dim_obs_f_pdaf , obs_op_f_pdaf , & init_obs_f_pdaf , init_obs_l_pdaf , prepoststep_ens_pdaf , & prodRinvA_l_pdaf , init_n_domains_pdaf , init_dim_l_pdaf , & init_dim_obs_l_pdaf , g2l_state_pdaf , l2g_state_pdaf , & g2l_obs_pdaf , init_obsvar_pdaf , init_obsvar_l_pdaf , status_pdaf ) case ( 4 ) CALL PDAF_put_state_etkf ( collect_state_pdaf , init_dim_obs_pdaf , obs_op_pdaf , & init_obs_pdaf , prepoststep_ens_pdaf , prodRinvA_pdaf , init_obsvar_pdaf , status_pdaf ) case ( 5 ) CALL PDAF_put_state_letkf ( & collect_state_pdaf , init_dim_obs_f_pdaf , obs_op_f_pdaf , & init_obs_f_pdaf , init_obs_l_pdaf , prepoststep_ens_pdaf , & prodRinvA_l_pdaf , init_n_domains_pdaf , init_dim_l_pdaf , & init_dim_obs_l_pdaf , g2l_state_pdaf , l2g_state_pdaf , & g2l_obs_pdaf , init_obsvar_pdaf , init_obsvar_l_pdaf , status_pdaf ) case ( 6 ) CALL PDAF_put_state_estkf ( collect_state_pdaf , init_dim_obs_pdaf , obs_op_pdaf , & init_obs_pdaf , prepoststep_ens_pdaf , prodRinvA_pdaf , init_obsvar_pdaf , status_pdaf ) case ( 7 ) CALL PDAF_put_state_lestkf ( & collect_state_pdaf , init_dim_obs_f_pdaf , obs_op_f_pdaf , & init_obs_f_pdaf , init_obs_l_pdaf , prepoststep_ens_pdaf , & prodRinvA_l_pdaf , init_n_domains_pdaf , init_dim_l_pdaf , & init_dim_obs_l_pdaf , g2l_state_pdaf , l2g_state_pdaf , & g2l_obs_pdaf , init_obsvar_pdaf , init_obsvar_l_pdaf , status_pdaf ) case ( 13 ) ! From .../PDAF_V1.16_var_devel/models/lorenz96/assimilation_pdaf.F90 ! tkdiff ./tutorial/3dvar/online_2D_serialmodel/prepoststep_3dvar_pdaf.F90 ./tutorial/3dvar/online_2D_serialmodel/prepoststep_ens_pdaf.F90 select case ( subtype ) case ( 0 ) #if 1 CALL PDAF_put_state_3dvar ( collect_state_pdaf , & init_dim_obs_pdaf , obs_op_pdaf , init_obs_pdaf , prodRinvA_pdaf , & cvt_pdaf , cvt_adj_pdaf , obs_op_pdaf , obs_op_adj_pdaf , & prepoststep_3dvar_pdaf , status_pdaf ) #endif case ( 1 ) #if 0 ! Ensemble 3D-Var with local ESTKF update of ensemble perturbations CALL PDAF_put_state_en3dvar_lestkf ( collect_state_pdaf , & init_dim_obs_pdaf , obs_op_pdaf , init_obs_pdaf , prodRinvA_pdaf , & cvt_ens_pdaf , cvt_adj_ens_pdaf , obs_op_lin_pdaf , obs_op_adj_pdaf , & init_dim_obs_f_pdaf , obs_op_f_pdaf , init_obs_f_pdaf , init_obs_l_pdaf , & prodRinvA_l_pdaf , init_n_domains_pdaf , init_dim_l_pdaf , & init_dim_obs_l_pdaf , g2l_state_pdaf , l2g_state_pdaf , & g2l_obs_pdaf , init_obsvar_pdaf , init_obsvar_l_pdaf , & prepoststep_pdaf , status_pdaf ) #endif case ( 4 ) #if 0 ! Ensemble 3D-Var with global ESTKF update of ensemble perturbations CALL PDAF_put_state_en3dvar_estkf ( collect_state_pdaf , & init_dim_obs_pdaf , obs_op_pdaf , init_obs_pdaf , prodRinvA_pdaf , & cvt_ens_pdaf , cvt_adj_ens_pdaf , obs_op_lin_pdaf , obs_op_adj_pdaf , & init_obsvar_pdaf , & prepoststep_pdaf , status_pdaf ) #endif case ( 6 ) #if 0 ! Hybrid 3D-Var with local ESTKF update of ensmeble perturbations CALL PDAF_put_state_hyb3dvar_lestkf ( collect_state_pdaf , & init_dim_obs_pdaf , obs_op_pdaf , init_obs_pdaf , prodRinvA_pdaf , & cvt_ens_pdaf , cvt_adj_ens_pdaf , cvt_pdaf , cvt_adj_pdaf , & obs_op_lin_pdaf , obs_op_adj_pdaf , & init_dim_obs_f_pdaf , obs_op_f_pdaf , init_obs_f_pdaf , init_obs_l_pdaf , & prodRinvA_l_pdaf , init_n_domains_pdaf , init_dim_l_pdaf , & init_dim_obs_l_pdaf , g2l_state_pdaf , l2g_state_pdaf , & g2l_obs_pdaf , init_obsvar_pdaf , init_obsvar_l_pdaf , & prepoststep_pdaf , status_pdaf ) #endif case ( 7 ) #if 0 ! Hybrid 3D-Var with global ESTKF update of ensemble perturbations CALL PDAF_put_state_hyb3dvar_estkf ( collect_state_pdaf , & init_dim_obs_pdaf , obs_op_pdaf , init_obs_pdaf , prodRinvA_pdaf , & cvt_ens_pdaf , cvt_adj_ens_pdaf , cvt_pdaf , cvt_adj_pdaf , & obs_op_lin_pdaf , obs_op_adj_pdaf , init_obsvar_pdaf , & prepoststep_pdaf , status_pdaf ) #endif end select end select if ( status_pdaf /= 0 ) stop 'assimilation_pdaf(): status_pdaf /= 0' if ( verbosity >= debug ) write ( stderr , * ) 'PDAF PUT STATUS= ' , status_pdaf CALL PDAF_get_state ( steps , timenow , doexit , next_observation_pdaf , & distribute_state_pdaf , prepoststep_ens_pdaf , status_pdaf ) if ( verbosity >= debug ) write ( stderr , * ) 'PDAF GET STATUS= ' , status_pdaf END SUBROUTINE assimilation_pdaf !----------------------------------------------------------------------- subroutine finish_pdaf () bind ( c ) !! Cleanup and finalize the EAT/PDAF component !----------------------------------------------------------------------- #ifdef _USE_PDAF__ CALL finalize_pdaf ( 0 ) ! Basically CALL PDAF_deallocate() #endif end subroutine finish_pdaf !----------------------------------------------------------------------- ! Below a number of callback routines implemented by the user. ! At present it is unclear how many - and which - are needed for the EAT implementation. #define _CLASSICAL_OFFLINE_SERIAL_ #ifdef _CLASSICAL_OFFLINE_SERIAL_ SUBROUTINE init_ens_pdaf ( filtertype , dim_p , dim_ens , state_p , Uinv , ens_p , flag ) INTEGER , INTENT ( in ) :: filtertype !! Type of filter to initialize INTEGER , INTENT ( in ) :: dim_p !! PE-local state dimension INTEGER , INTENT ( in ) :: dim_ens !! Size of ensemble REAL ( REAL64 ), INTENT ( inout ) :: state_p ( dim_p ) !! PE-local model state ! It is not necessary to initialize the array 'state_p' for SEIK. ! It is available here only for convenience and can be used freely. REAL ( REAL64 ), INTENT ( inout ) :: Uinv ( dim_ens - 1 , dim_ens - 1 ) !! Array not referenced for SEIK REAL ( REAL64 ), INTENT ( out ) :: ens_p ( dim_p , dim_ens ) !! PE-local state ensemble INTEGER , INTENT ( inout ) :: flag !! PDAF status flag if ( verbosity >= debug ) write ( stderr , * ) 'init_ens_pdaf() ' , filtertype , dim_p , dim_ens END SUBROUTINE init_ens_pdaf !----------------------------------------------------------------------- ! Routine to collect a state vector from model fields SUBROUTINE collect_state_pdaf ( dim_p , state_p ) INTEGER , INTENT ( in ) :: dim_p INTEGER , INTENT ( inout ) :: state_p ( dim_p ) ! can be empty as all states have already been collected if ( verbosity >= debug ) write ( stderr , * ) 'collect_state_pdaf()' END SUBROUTINE collect_state_pdaf !----------------------------------------------------------------------- ! Routine to distribute a state vector to model fields SUBROUTINE distribute_state_pdaf ( dim_p , state_p ) INTEGER , INTENT ( in ) :: dim_p INTEGER , INTENT ( inout ) :: state_p ( dim_p ) ! can be empty as all states have already been distrubuted if ( verbosity >= debug ) write ( stderr , * ) 'distribute_state_pdaf()' END SUBROUTINE distribute_state_pdaf !----------------------------------------------------------------------- ! Initialize dimension of observation vector SUBROUTINE init_dim_obs_pdaf ( step , dim_obs_p ) INTEGER , INTENT ( in ) :: step !! Current time step INTEGER , INTENT ( out ) :: dim_obs_p !! Dimension of observation vector if ( verbosity >= debug ) write ( stderr , * ) 'init_dim_obs_pdaf() ' , step , dim_obs_p dim_obs_p = size ( obs ) END SUBROUTINE init_dim_obs_pdaf !----------------------------------------------------------------------- ! Implementation of the Observation operator SUBROUTINE obs_op_pdaf ( step , dim_p , dim_obs_p , state_p , m_state_p ) INTEGER , INTENT ( in ) :: step !! Currrent time step INTEGER , INTENT ( in ) :: dim_p !! PE-local dimension of state INTEGER , INTENT ( in ) :: dim_obs_p !! Dimension of observed state REAL ( REAL64 ), INTENT ( in ) :: state_p ( dim_p ) !! PE-local model state REAL ( REAL64 ), INTENT ( out ) :: m_state_p ( dim_obs_p ) !! PE-local observed state integer :: i if ( verbosity >= debug ) write ( stderr , * ) 'obs_op_pdaf() ' , dim_p , dim_obs_p DO i = 1 , dim_obs_p m_state_p ( i ) = state_p ( iobs ( i )) END DO END SUBROUTINE obs_op_pdaf !----------------------------------------------------------------------- ! Routine to provide vector of measurements SUBROUTINE init_obs_pdaf ( step , dim_obs_f , observation_f ) INTEGER , INTENT ( in ) :: step !! Current time step INTEGER , INTENT ( in ) :: dim_obs_f !! Dimension of full observation vector REAL ( REAL64 ), INTENT ( out ) :: observation_f ( dim_obs_f ) !! Full observation vector if ( verbosity >= debug ) write ( stderr , * ) 'init_obs_pdaf() ' , dim_obs_f , size ( observation_f ) observation_f = obs ( 1 : dim_obs_f ) END SUBROUTINE init_obs_pdaf !----------------------------------------------------------------------- ! ! Subroutine used in SEIK and ETKF ! User supplied pre/poststep routine SUBROUTINE prepoststep_ens_pdaf ( step , dim_p , dim_ens , dim_ens_p , dim_obs_p , state_p , Uinv , ens_p , flag ) INTEGER , INTENT ( in ) :: step !! Current time step (not relevant for offline mode) INTEGER , INTENT ( in ) :: dim_p !! PE-local state dimension INTEGER , INTENT ( in ) :: dim_ens !! Size of state ensemble INTEGER , INTENT ( in ) :: dim_ens_p !! PE-local size of ensemble INTEGER , INTENT ( in ) :: dim_obs_p !! PE-local dimension of observation vector REAL ( REAL64 ), INTENT ( inout ) :: state_p ( dim_p ) !! PE-local forecast/analysis state ! The array 'state_p' is not generally not initialized in the case of SEIK. ! It can be used freely here. REAL ( REAL64 ), INTENT ( inout ) :: Uinv ( dim_ens - 1 , dim_ens - 1 ) !! Inverse of matrix U REAL ( REAL64 ), INTENT ( inout ) :: ens_p ( dim_p , dim_ens ) !! PE-local state ensemble INTEGER , INTENT ( in ) :: flag !! PDAF status flag !! local variables INTEGER :: i , j , member !! Counters LOGICAL , SAVE :: firsttime = . TRUE . !! Routine is called for first time? REAL :: invdim_ens !! Inverse ensemble size REAL :: invdim_ensm1 !! Inverse of ensemble size minus 1 REAL :: rmserror_est !! estimated RMS error REAL , ALLOCATABLE :: variance (:) !! model state variances REAL , ALLOCATABLE :: field (:,:) !! global model field CHARACTER ( len = 2 ) :: ensstr !! String for ensemble member CHARACTER ( len = 2 ) :: stepstr !! String for time step CHARACTER ( len = 3 ) :: anastr !! String for call type (initial, forecast, analysis) if ( verbosity >= debug ) write ( stderr , * ) 'prepoststep_ens_pdaf()' , dim_p , dim_ens , dim_ens_p , dim_obs_p ! ********************** ! *** INITIALIZATION *** ! ********************** IF ( firsttime ) THEN WRITE ( * , '(8x, a)' ) 'Analyze initial state ensemble' anastr = 'ini' ELSE IF ( step < 0 ) THEN WRITE ( * , '(8x, a)' ) 'Analyze and write forecasted state ensemble' anastr = 'for' ELSE WRITE ( * , '(8x, a)' ) 'Analyze and write assimilated state ensemble' anastr = 'ana' END IF END IF ! Allocate fields ALLOCATE ( variance ( dim_p )) ! Initialize numbers rmserror_est = 0.0 invdim_ens = 1.0 / REAL ( dim_ens ) invdim_ensm1 = 1.0 / REAL ( dim_ens - 1 ) ! **************************************************************** ! *** Perform prepoststep. The state and error information is  *** ! *** completely in the ensemble.                              *** ! **************************************************************** ! *** Compute mean state WRITE ( * , '(8x, a)' ) '--- compute ensemble mean' state_p = 0.0 DO member = 1 , dim_ens DO i = 1 , dim_p state_p ( i ) = state_p ( i ) + ens_p ( i , member ) END DO END DO state_p (:) = invdim_ens * state_p (:) ! *** Compute sampled variances *** variance (:) = 0.0 DO member = 1 , dim_ens DO j = 1 , dim_p variance ( j ) = variance ( j ) & + ( ens_p ( j , member ) - state_p ( j )) & * ( ens_p ( j , member ) - state_p ( j )) END DO END DO variance (:) = invdim_ensm1 * variance (:) block real ( real64 ) :: s = 0._real64 , ss = 0._real64 real ( real64 ) :: mean , var , std real ( real64 ) :: x s = 0._real64 ss = 0._real64 DO i = 1 , dim_obs_p x = obs ( i ) - state_p ( iobs ( i )) s = s + x ss = ss + x * x END DO mean = s / dim_obs_p var = ( ss - s * s / dim_obs_p ) / ( dim_obs_p - 1 ) std = sqrt ( var ) if ( verbosity >= debug ) then write ( stderr , * ) 'prepoststep_ens_pdaf() - mean, var, std' , steps , mean , var , std end if end block ! ************************************************************ ! *** Compute RMS errors according to sampled covar matrix *** ! ************************************************************ ! total estimated RMS error DO i = 1 , dim_p rmserror_est = rmserror_est + variance ( i ) ENDDO rmserror_est = SQRT ( rmserror_est / dim_p ) DEALLOCATE ( variance ) ! ***************** ! *** Screen IO *** ! ***************** ! Output RMS errors given by sampled covar matrix WRITE ( * , '(12x, a, es12.4)' ) & 'RMS error according to sampled variance: ' , rmserror_est #if 0 block integer :: u integer :: i = 1 , n character ( len = 32 ) :: fn if ( step > 0 ) then write ( fn , '(A,I0.4,A)' ) 'mean_' , i , '.dat' open ( newunit = u , file = trim ( fn )) write ( u , * ) 'step# ' , i do n = 1 , dim_p write ( u , '(F9.6)' ) sum ( model_states ( n ,:)) / dim_ens end do close ( u ) i = i + 1 end if end block #endif END SUBROUTINE prepoststep_ens_pdaf !----------------------------------------------------------------------- ! Initialize mean observation error variance SUBROUTINE init_obsvar_pdaf ( step , dim_obs_p , obs_p , meanvar ) INTEGER , INTENT ( in ) :: step !! Current time step INTEGER , INTENT ( in ) :: dim_obs_p !! PE-local dimension of observation vector REAL ( REAL64 ), INTENT ( in ) :: obs_p ( dim_obs_p ) !! PE-local observation vector REAL ( REAL64 ), INTENT ( out ) :: meanvar !! Mean observation error variance if ( verbosity >= debug ) write ( stderr , * ) 'init_obsvar_pdaf() ' , rms_obs meanvar = rms_obs ** 2 END SUBROUTINE init_obsvar_pdaf !----------------------------------------------------------------------- SUBROUTINE next_observation_pdaf ( stepnow , nsteps , doexit , time ) INTEGER , INTENT ( in ) :: stepnow !! Number of the current time step INTEGER , INTENT ( out ) :: nsteps !! Number of time steps until next obs INTEGER , INTENT ( out ) :: doexit !! Whether to exit forecasting (1 for exit) REAL ( REAL64 ), INTENT ( out ) :: time !! Current model (physical) time if ( verbosity >= debug ) write ( stderr , * ) 'next_observation_pdaf() ' nsteps = 1 doexit = 1 END SUBROUTINE next_observation_pdaf !----------------------------------------------------------------------- ! ! Subroutines used in EnKF ! Add obs. error covariance R to HPH in EnKF SUBROUTINE add_obs_error_pdaf () call abort ( 'add_obs_error_pdaf' ) END SUBROUTINE add_obs_error_pdaf !----------------------------------------------------------------------- ! Initialize obs error covar R in EnKF SUBROUTINE init_obscovar_pdaf () call abort ( 'init_obscovar_pdaf' ) END SUBROUTINE init_obscovar_pdaf !----------------------------------------------------------------------- ! ! Subroutine used in SEIK and ETKF ! Provide product R&#94;-1 A for some matrix A SUBROUTINE prodRinvA_pdaf ( step , dim_obs_p , rank , obs_p , A_p , C_p ) INTEGER , INTENT ( in ) :: step !! Current time step INTEGER , INTENT ( in ) :: dim_obs_p !! PE-local dimension of obs. vector INTEGER , INTENT ( in ) :: rank !! Rank of initial covariance matrix REAL ( REAL64 ), INTENT ( in ) :: obs_p ( dim_obs_p ) !! PE-local vector of observations REAL ( REAL64 ), INTENT ( in ) :: A_p ( dim_obs_p , rank ) !! Input matrix from SEEK_ANALYSIS REAL ( REAL64 ), INTENT ( out ) :: C_p ( dim_obs_p , rank ) !! Output matrix !! local variables integer :: i , j REAL ( REAL64 ) :: ivariance_obs if ( verbosity >= debug ) write ( stderr , * ) 'prodRinvA_pdaf() ' , dim_obs_p , rank , rms_obs ivariance_obs = 1.0 / rms_obs ** 2 DO j = 1 , rank DO i = 1 , dim_obs_p C_p ( i , j ) = ivariance_obs * A_p ( i , j ) END DO END DO END SUBROUTINE prodRinvA_pdaf !----------------------------------------------------------------------- ! 3Dvar specific routines !----------------------------------------------------------------------- ! ~PDAF_V2.0/tutorial/3dvar/online_2D_serialmodel/cvt_pdaf.F90 SUBROUTINE cvt_pdaf ( iter , dim_p , dim_cvec , v_p , Vv_p ) ! *** Arguments *** INTEGER , INTENT ( in ) :: iter !!< Iteration of optimization INTEGER , INTENT ( in ) :: dim_p !!< PE-local observation dimension INTEGER , INTENT ( in ) :: dim_cvec !!< Dimension of control vector REAL , TARGET , INTENT ( in ) :: v_p ( dim_cvec ) !!< PE-local control vector REAL , TARGET , INTENT ( inout ) :: Vv_p ( dim_p ) !!< PE-local result vector IF ( ASSOCIATED ( pcvt_callback )) CALL pcvt_callback ( 1 , iter , dim_p , - 1 , dim_cvec , & c_null_ptr , c_loc ( v_p ), c_loc ( Vv_p )) END SUBROUTINE cvt_pdaf !----------------------------------------------------------------------- ! ~PDAF_V2.0/tutorial/3dvar/online_2D_serialmodel/cvt_adj_pdaf.F90 SUBROUTINE cvt_adj_pdaf ( iter , dim_p , dim_cvec , Vv_p , v_p ) !  *** Arguments *** INTEGER , INTENT ( in ) :: iter !!< Iteration of optimization INTEGER , INTENT ( in ) :: dim_p !!< PE-local observation dimension INTEGER , INTENT ( in ) :: dim_cvec !!< Dimension of control vector REAL , TARGET , INTENT ( in ) :: Vv_p ( dim_p ) !!< PE-local input vector REAL , TARGET , INTENT ( inout ) :: v_p ( dim_cvec ) !!< PE-local result vector IF ( ASSOCIATED ( pcvt_callback )) CALL pcvt_callback ( 2 , iter , dim_p , - 1 , dim_cvec , & c_null_ptr , c_loc ( v_p ), c_loc ( Vv_p )) END SUBROUTINE cvt_adj_pdaf !----------------------------------------------------------------------- ! ~PDAF_V2.0/tutorial/3dvar/online_2D_serialmodel/cvt_ens_pdaf.F90 SUBROUTINE cvt_ens_pdaf ( iter , dim_p , dim_ens , dim_cvec_ens , ens_p , v_p , Vv_p ) INTEGER , INTENT ( in ) :: iter !!< Iteration of optimization INTEGER , INTENT ( in ) :: dim_p !!< PE-local dimension of state INTEGER , INTENT ( in ) :: dim_ens !!< Ensemble size INTEGER , INTENT ( in ) :: dim_cvec_ens !!< Dimension of control vector REAL , TARGET , INTENT ( in ) :: ens_p ( dim_p , dim_ens ) !!< PE-local ensemble REAL , TARGET , INTENT ( in ) :: v_p ( dim_cvec_ens ) !!< PE-local control vector REAL , TARGET , INTENT ( inout ) :: Vv_p ( dim_p ) !!< PE-local state increment IF ( ASSOCIATED ( pcvt_callback )) CALL pcvt_callback ( 3 , iter , dim_p , dim_ens , dim_cvec_ens , & c_loc ( ens_p ), c_loc ( v_p ), c_loc ( Vv_p )) END SUBROUTINE cvt_ens_pdaf !----------------------------------------------------------------------- ! ~PDAF_V2.0/tutorial/3dvar/online_2D_serialmodel/cvt_adj_ens_pdaf.F90 SUBROUTINE cvt_adj_ens_pdaf ( iter , dim_p , dim_ens , dim_cvec_ens , ens_p , Vv_p , v_p ) ! *** Arguments *** INTEGER , INTENT ( in ) :: iter !!< Iteration of optimization INTEGER , INTENT ( in ) :: dim_p !!< PE-local dimension of state INTEGER , INTENT ( in ) :: dim_ens !!< Ensemble size INTEGER , INTENT ( in ) :: dim_cvec_ens !!< Number of columns in HV_p REAL , TARGET , INTENT ( in ) :: ens_p ( dim_p , dim_ens ) !!< PE-local ensemble REAL , TARGET , INTENT ( in ) :: Vv_p ( dim_p ) !!< PE-local input vector REAL , TARGET , INTENT ( inout ) :: v_p ( dim_cvec_ens ) !!< PE-local result vector IF ( ASSOCIATED ( pcvt_callback )) CALL pcvt_callback ( 4 , iter , dim_p , dim_ens , dim_cvec_ens , & c_loc ( ens_p ), c_loc ( v_p ), c_loc ( Vv_p )) END SUBROUTINE cvt_adj_ens_pdaf !----------------------------------------------------------------------- ! Implementation of the adjoint Observation operator SUBROUTINE obs_op_adj_pdaf ( step , dim_p , dim_obs_p , m_state_p , state_p ) INTEGER , INTENT ( in ) :: step !! Currrent time step INTEGER , INTENT ( in ) :: dim_p !! PE-local dimension of state INTEGER , INTENT ( in ) :: dim_obs_p !! Dimension of observed state REAL ( REAL64 ), INTENT ( in ) :: m_state_p ( dim_obs_p ) !! PE-local observed state REAL ( REAL64 ), INTENT ( out ) :: state_p ( dim_p ) !! PE-local model state !! local variables integer :: i if ( verbosity >= debug ) write ( stderr , * ) 'obs_op_adj_pdaf() ' , dim_p , dim_obs_p state_p = 0.0 DO i = 1 , dim_obs_p state_p ( iobs ( i )) = m_state_p ( i ) END DO END SUBROUTINE obs_op_adj_pdaf !----------------------------------------------------------------------- !KB - this routine needs content SUBROUTINE obs_op_lin_pdaf () call abort ( 'obs_op_lin_pdaf' ) END SUBROUTINE obs_op_lin_pdaf !KB - this routine needs content SUBROUTINE prepoststep_pdaf () call abort ( 'prepoststep_pdaf' ) END SUBROUTINE prepoststep_pdaf !KB - this routine needs content SUBROUTINE init_3dvar_pdaf () call abort ( 'init_3dvar_pdaf' ) END SUBROUTINE init_3dvar_pdaf !KB - this routine needs content SUBROUTINE prepoststep_3dvar_pdaf () call abort ( 'prepoststep_3dvar_pdaf' ) END SUBROUTINE prepoststep_3dvar_pdaf SUBROUTINE abort ( msg ) character ( len =* ), intent ( in ) :: msg write ( stderr , '(a)' ) msg stop 1 ! call MPI_Abort(MPI_COMM_WORLD,-3,ierr) END SUBROUTINE ! ! Subroutines used in LSEIK and LETKF ! Provide number of local analysis domains SUBROUTINE init_n_domains_pdaf () call abort ( 'init_n_domains_pdaf' ) END SUBROUTINE init_n_domains_pdaf ! Initialize state dimension for local ana. domain SUBROUTINE init_dim_l_pdaf () call abort ( 'init_dim_l_pdaf' ) END SUBROUTINE init_dim_l_pdaf ! Initialize dim. of obs. vector for local ana. domain SUBROUTINE init_dim_obs_l_pdaf () call abort ( 'init_dim_obs_l_pdaf' ) END SUBROUTINE init_dim_obs_l_pdaf ! Get state on local ana. domain from global state SUBROUTINE g2l_state_pdaf () call abort ( 'g2l_state_pdaf' ) END SUBROUTINE g2l_state_pdaf ! Init global state from state on local analysis domain SUBROUTINE g2l_obs_pdaf () call abort ( 'g2l_obs_pdaf' ) END SUBROUTINE g2l_obs_pdaf ! Restrict a global obs. vector to local analysis domain SUBROUTINE l2g_state_pdaf () call abort ( 'l2g_state_pdaf' ) END SUBROUTINE l2g_state_pdaf ! Provide vector of measurements for local ana. domain SUBROUTINE init_obs_l_pdaf () call abort ( 'init_obs_l_pdaf' ) END SUBROUTINE init_obs_l_pdaf ! Provide product R&#94;-1 A for some matrix A (for LSEIK) SUBROUTINE prodRinvA_l_pdaf () call abort ( 'prodRinvA_l_pdaf' ) END SUBROUTINE prodRinvA_l_pdaf ! Initialize local mean observation error variance SUBROUTINE init_obsvar_l_pdaf () call abort ( 'init_obsvar_l_pdaf' ) END SUBROUTINE init_obsvar_l_pdaf ! Provide full vector of measurements for PE-local domain SUBROUTINE init_obs_f_pdaf () call abort ( 'init_obs_f_pdaf' ) END SUBROUTINE init_obs_f_pdaf ! Obs. operator for full obs. vector for PE-local domain SUBROUTINE obs_op_f_pdaf () call abort ( 'obs_op_f_pdaf' ) END SUBROUTINE obs_op_f_pdaf ! Get dimension of full obs. vector for PE-local domain SUBROUTINE init_dim_obs_f_pdaf () call abort ( 'init_dim_obs_f_pdaf' ) END SUBROUTINE init_dim_obs_f_pdaf #endif end module pdaf_wrapper","tags":"","loc":"sourcefile/pdaf_wrapper.f90.html"},{"title":"eat_filter_pdaf.F90 – EAT","text":"This file depends on sourcefile~~eat_filter_pdaf.f90~~EfferentGraph sourcefile~eat_filter_pdaf.f90 eat_filter_pdaf.F90 sourcefile~pdaf_wrapper.f90 pdaf_wrapper.F90 sourcefile~eat_filter_pdaf.f90->sourcefile~pdaf_wrapper.f90 sourcefile~eat_config.f90 eat_config.F90 sourcefile~eat_filter_pdaf.f90->sourcefile~eat_config.f90 sourcefile~pdaf_wrapper.f90->sourcefile~eat_config.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs eat_filter_pdaf Source Code eat_filter_pdaf.F90 Source Code ! Copyright (C) 2021 Bolding & Bruggeman #undef _USE_PDAF_ #define _USE_PDAF_ program eat_filter_pdaf !! A wrapper around the 'off_line PDAF' implmentation to keep it alive during !! ensemble simulations USE , INTRINSIC :: ISO_FORTRAN_ENV use mpi use eat_config use pdaf_wrapper IMPLICIT NONE integer :: nobs = 0 logical :: have_obs = . true . logical :: have_model = . true . integer :: state_size , ensemble_size integer , allocatable :: reqs (:) integer , allocatable :: stats (:,:) real ( real64 ), pointer , contiguous :: model_states (:,:) integer , parameter :: stderr = error_unit , stdout = output_unit integer :: verbosity = info !----------------------------------------------------------------------- call eat_init_pdaf () call eat_do_pdaf () call eat_finish_pdaf () !----------------------------------------------------------------------- contains !----------------------------------------------------------------------- subroutine eat_init_pdaf () !! Initialize EAT/PDAF component ! Local variables integer :: stat ( MPI_STATUS_SIZE ) integer :: ierr logical :: fileexists character ( len =* ), parameter :: nmlfile = 'eat_pdaf.nml' integer :: nmlunit namelist / nml_filter_pdaf / verbosity !----------------------------------------------------------------------- INQUIRE ( FILE = nmlfile , EXIST = fileexists ) if ( fileexists ) then open ( newunit = nmlunit , file = nmlfile , status = 'old' , action = 'read' ) read ( nmlunit , nml = nml_filter_pdaf ) close ( nmlunit ) if ( verbosity >= warn ) write ( stderr , * ) 'filter(read namelist)' end if call init_eat_config ( color_filter + verbosity ) if ( EAT_COMM_obs_filter == MPI_COMM_NULL ) then if ( verbosity >= info ) write ( stderr , * ) \"filter(no observation executable present)\" have_obs = . false . end if if ( EAT_COMM_model_filter == MPI_COMM_NULL ) then if ( verbosity >= info ) write ( stderr , * ) \"filter(no model executable present)\" have_model = . false . else call MPI_RECV ( state_size , 1 , MPI_INTEGER , 1 , MPI_ANY_TAG , EAT_COMM_model_filter , stat , ierr ) if ( verbosity >= info ) write ( stderr , '(A,I6)' ) ' filter(<-- state_size) ' , state_size ensemble_size = size_model_filter_comm - size_filter_comm allocate ( reqs ( 2 + ensemble_size )) allocate ( stats ( MPI_STATUS_SIZE , 2 + ensemble_size )) end if #ifdef _USE_PDAF_ CALL init_pdaf ( EAT_COMM_filter , state_size , ensemble_size , model_states , ierr ) if ( ierr /= 0 ) then call MPI_ABORT ( MPI_COMM_WORLD , - 1 , ierr ) else write ( error_unit , * ) 'filter(PDAF is initialized): ' , shape ( model_states ) end if #else allocate ( model_states ( state_size , ensemble_size )) #endif end subroutine eat_init_pdaf !----------------------------------------------------------------------- subroutine eat_do_pdaf () !! Get observations and states and do the PDAF/assimilation step ! Local variables real ( real64 ), allocatable :: states (:,:) integer :: stat ( MPI_STATUS_SIZE ) integer :: obs_stats ( MPI_STATUS_SIZE , 2 ) integer :: obs_requests ( 2 ) integer :: m integer :: ierr character ( len = 19 ) :: timestr !----------------------------------------------------------------------- do if ( have_obs ) then call MPI_RECV ( timestr , 19 , MPI_CHARACTER , 0 , tag_timestr , EAT_COMM_obs_filter , stat , ierr ) call MPI_RECV ( nobs , 1 , MPI_INTEGER , 0 , tag_nobs , EAT_COMM_obs_filter , stat , ierr ) if ( verbosity >= info ) write ( stderr , '(A,I6)' ) ' filter(<-- nobs) ' , nobs end if if ( have_obs . and . nobs > 0 ) then if (. not . associated ( iobs )) allocate ( iobs ( nobs )) if ( nobs > size ( iobs )) then deallocate ( iobs ) allocate ( iobs ( nobs )) end if if (. not . associated ( obs )) allocate ( obs ( nobs )) if ( nobs > size ( obs )) then deallocate ( obs ) allocate ( obs ( nobs )) end if call MPI_IRECV ( iobs ( 1 : nobs ), nobs , MPI_INTEGER , 0 , tag_iobs , EAT_COMM_obs_filter , reqs ( 1 ), ierr ) call MPI_IRECV ( obs ( 1 : nobs ), nobs , MPI_DOUBLE , 0 , tag_obs , EAT_COMM_obs_filter , reqs ( 2 ), ierr ) if ( verbosity >= info ) write ( stderr , '(A,I6)' ) ' filter(<-- iobs, obs)' end if if ( have_model . and . nobs > 0 ) then !KB      if (have_model) then do m = 1 , ensemble_size call MPI_IRECV ( model_states (:, m ), state_size , MPI_DOUBLE , m , tag_forecast , EAT_COMM_model_filter , reqs ( 2 + m ), ierr ) if ( ierr /= MPI_SUCCESS ) THEN write ( stderr , * ) 'Fatal error (PDAF): Unable to receive: ' , m call MPI_Abort ( MPI_COMM_WORLD , - 1 , ierr ) end if end do end if if ( verbosity >= info ) write ( stderr , '(x,A)' ) 'filter(<-- state)' call MPI_WAITALL ( ensemble_size , reqs , stats (:,:), ierr ) if ( have_obs . and . have_model . and . nobs > 0 ) then #ifdef _USE_PDAF_ ! Begin PDAF specific part ! from .../tutorial/classical/offline_2D_serial/main_offline.F90 if ( verbosity >= info ) write ( stderr , '(x,A)' ) 'filter(--> PDAF)' CALL assimilation_pdaf () if ( verbosity >= info ) write ( stderr , '(x,A)' ) 'filter(<-- PDAF)' ! End PDAF specific part #endif do m = 1 , ensemble_size call MPI_ISEND ( model_states (:, m ), state_size , MPI_DOUBLE , m , tag_analysis , EAT_COMM_model_filter , reqs ( 2 + m ), ierr ) if ( ierr /= MPI_SUCCESS ) THEN write ( stderr , * ) 'Fatal error (PDAF): Unable to send: ' , m call MPI_Abort ( MPI_COMM_WORLD , - 1 , ierr ) end if end do m = 2 + ensemble_size call MPI_WAITALL ( ensemble_size , reqs ( 3 : m ), stats (:, 3 : m ), ierr ) if ( ierr /= MPI_SUCCESS ) THEN write ( stderr , * ) 'Fatal error (PDAF): Unable to wait' ; call flush ( stderr ) call MPI_Abort ( MPI_COMM_WORLD , - 1 , ierr ) end if if ( verbosity >= info ) write ( stderr , '(x,A)' ) 'filter(--> state)' end if if ( nobs < 0 ) then if ( verbosity >= info ) write ( stderr , * ) 'filter(exit)' exit end if end do end subroutine eat_do_pdaf !----------------------------------------------------------------------- subroutine eat_finish_pdaf () !! Cleanup and finalize the EAT/PDAF component !----------------------------------------------------------------------- integer :: ierr call finish_pdaf () call MPI_Finalize ( ierr ) end subroutine eat_finish_pdaf end program eat_filter_pdaf","tags":"","loc":"sourcefile/eat_filter_pdaf.f90.html"},{"title":"init_eat_config – EAT","text":"public subroutine init_eat_config(color) Initialize MPI, define communicators and set variables Arguments Type Intent Optional Attributes Name integer, intent(in) :: color Calls proc~~init_eat_config~~CallsGraph proc~init_eat_config init_eat_config mpi_comm_rank mpi_comm_rank proc~init_eat_config->mpi_comm_rank mpi_comm_size mpi_comm_size proc~init_eat_config->mpi_comm_size mpi_init mpi_init proc~init_eat_config->mpi_init mpi_abort mpi_abort proc~init_eat_config->mpi_abort mpi_barrier mpi_barrier proc~init_eat_config->mpi_barrier mpi_get_processor_name mpi_get_processor_name proc~init_eat_config->mpi_get_processor_name mpi_comm_split mpi_comm_split proc~init_eat_config->mpi_comm_split Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~init_eat_config~~CalledByGraph proc~init_eat_config init_eat_config proc~eat_init_pdaf eat_init_pdaf proc~eat_init_pdaf->proc~init_eat_config program~eat_filter_pdaf eat_filter_pdaf program~eat_filter_pdaf->proc~eat_init_pdaf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_eat_config.html"},{"title":"version_mpi_config – EAT","text":"public subroutine version_mpi_config(mpi_version, library_version) Collect MPI and MPI Library version info Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: mpi_version character(len=*), intent(inout) :: library_version Calls proc~~version_mpi_config~~CallsGraph proc~version_mpi_config version_mpi_config mpi_get_version mpi_get_version proc~version_mpi_config->mpi_get_version mpi_get_library_version mpi_get_library_version proc~version_mpi_config->mpi_get_library_version Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/version_mpi_config.html"},{"title":"init_pdaf – EAT","text":"public subroutine init_pdaf(EAT_COMM_filter, state_size, ensemble_size, model_states, stat) Initialize various variable and call PDAF_init() Arguments Type Intent Optional Attributes Name integer, intent(in), value :: EAT_COMM_filter integer, intent(in), value :: state_size integer, intent(in), value :: ensemble_size real(kind=real64), pointer, contiguous :: model_states (:,:) integer, intent(out) :: stat Calls proc~~init_pdaf~~CallsGraph proc~init_pdaf init_pdaf pdaf_init pdaf_init proc~init_pdaf->pdaf_init pdaf_set_comm_pdaf pdaf_set_comm_pdaf proc~init_pdaf->pdaf_set_comm_pdaf pdaf_set_ens_pointer pdaf_set_ens_pointer proc~init_pdaf->pdaf_set_ens_pointer pdaf_get_state pdaf_get_state proc~init_pdaf->pdaf_get_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~init_pdaf~~CalledByGraph proc~init_pdaf init_pdaf proc~eat_init_pdaf eat_init_pdaf proc~eat_init_pdaf->proc~init_pdaf program~eat_filter_pdaf eat_filter_pdaf program~eat_filter_pdaf->proc~eat_init_pdaf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_pdaf.html"},{"title":"assimilation_pdaf – EAT","text":"public subroutine assimilation_pdaf() bind(c) local variables Arguments None Calls proc~~assimilation_pdaf~~CallsGraph proc~assimilation_pdaf assimilation_pdaf pdaf_put_state_letkf pdaf_put_state_letkf proc~assimilation_pdaf->pdaf_put_state_letkf pdaf_put_state_3dvar pdaf_put_state_3dvar proc~assimilation_pdaf->pdaf_put_state_3dvar pdaf_put_state_enkf pdaf_put_state_enkf proc~assimilation_pdaf->pdaf_put_state_enkf pdaf_put_state_lseik pdaf_put_state_lseik proc~assimilation_pdaf->pdaf_put_state_lseik pdaf_put_state_etkf pdaf_put_state_etkf proc~assimilation_pdaf->pdaf_put_state_etkf pdaf_get_state pdaf_get_state proc~assimilation_pdaf->pdaf_get_state pdaf_force_analysis pdaf_force_analysis proc~assimilation_pdaf->pdaf_force_analysis pdaf_put_state_seik pdaf_put_state_seik proc~assimilation_pdaf->pdaf_put_state_seik pdaf_put_state_lestkf pdaf_put_state_lestkf proc~assimilation_pdaf->pdaf_put_state_lestkf pdaf_put_state_estkf pdaf_put_state_estkf proc~assimilation_pdaf->pdaf_put_state_estkf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assimilation_pdaf~~CalledByGraph proc~assimilation_pdaf assimilation_pdaf proc~eat_do_pdaf eat_do_pdaf proc~eat_do_pdaf->proc~assimilation_pdaf program~eat_filter_pdaf eat_filter_pdaf program~eat_filter_pdaf->proc~eat_do_pdaf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/assimilation_pdaf.html"},{"title":"finish_pdaf – EAT","text":"public subroutine finish_pdaf() bind(c) Cleanup and finalize the EAT/PDAF component Arguments None Called by proc~~finish_pdaf~~CalledByGraph proc~finish_pdaf finish_pdaf proc~eat_finish_pdaf eat_finish_pdaf proc~eat_finish_pdaf->proc~finish_pdaf program~eat_filter_pdaf eat_filter_pdaf program~eat_filter_pdaf->proc~eat_finish_pdaf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/finish_pdaf.html"},{"title":"init_ens_pdaf – EAT","text":"private subroutine init_ens_pdaf(filtertype, dim_p, dim_ens, state_p, Uinv, ens_p, flag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: filtertype Type of filter to initialize integer, intent(in) :: dim_p PE-local state dimension integer, intent(in) :: dim_ens Size of ensemble real(kind=REAL64), intent(inout) :: state_p (dim_p) PE-local model state real(kind=REAL64), intent(inout) :: Uinv (dim_ens-1,dim_ens-1) Array not referenced for SEIK real(kind=REAL64), intent(out) :: ens_p (dim_p,dim_ens) PE-local state ensemble integer, intent(inout) :: flag PDAF status flag Contents None","tags":"","loc":"proc/init_ens_pdaf.html"},{"title":"collect_state_pdaf – EAT","text":"private subroutine collect_state_pdaf(dim_p, state_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim_p integer, intent(inout) :: state_p (dim_p) Contents None","tags":"","loc":"proc/collect_state_pdaf.html"},{"title":"distribute_state_pdaf – EAT","text":"private subroutine distribute_state_pdaf(dim_p, state_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim_p integer, intent(inout) :: state_p (dim_p) Contents None","tags":"","loc":"proc/distribute_state_pdaf.html"},{"title":"init_dim_obs_pdaf – EAT","text":"private subroutine init_dim_obs_pdaf(step, dim_obs_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: step Current time step integer, intent(out) :: dim_obs_p Dimension of observation vector Contents None","tags":"","loc":"proc/init_dim_obs_pdaf.html"},{"title":"obs_op_pdaf – EAT","text":"private subroutine obs_op_pdaf(step, dim_p, dim_obs_p, state_p, m_state_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: step Currrent time step integer, intent(in) :: dim_p PE-local dimension of state integer, intent(in) :: dim_obs_p Dimension of observed state real(kind=REAL64), intent(in) :: state_p (dim_p) PE-local model state real(kind=REAL64), intent(out) :: m_state_p (dim_obs_p) PE-local observed state Contents None","tags":"","loc":"proc/obs_op_pdaf.html"},{"title":"init_obs_pdaf – EAT","text":"private subroutine init_obs_pdaf(step, dim_obs_f, observation_f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: step Current time step integer, intent(in) :: dim_obs_f Dimension of full observation vector real(kind=REAL64), intent(out) :: observation_f (dim_obs_f) Full observation vector Contents None","tags":"","loc":"proc/init_obs_pdaf.html"},{"title":"prepoststep_ens_pdaf – EAT","text":"private subroutine prepoststep_ens_pdaf(step, dim_p, dim_ens, dim_ens_p, dim_obs_p, state_p, Uinv, ens_p, flag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: step Current time step (not relevant for offline mode) integer, intent(in) :: dim_p PE-local state dimension integer, intent(in) :: dim_ens Size of state ensemble integer, intent(in) :: dim_ens_p PE-local size of ensemble integer, intent(in) :: dim_obs_p PE-local dimension of observation vector real(kind=REAL64), intent(inout) :: state_p (dim_p) PE-local forecast/analysis state real(kind=REAL64), intent(inout) :: Uinv (dim_ens-1,dim_ens-1) Inverse of matrix U real(kind=REAL64), intent(inout) :: ens_p (dim_p,dim_ens) PE-local state ensemble integer, intent(in) :: flag PDAF status flag local variables Contents None","tags":"","loc":"proc/prepoststep_ens_pdaf.html"},{"title":"init_obsvar_pdaf – EAT","text":"private subroutine init_obsvar_pdaf(step, dim_obs_p, obs_p, meanvar) Arguments Type Intent Optional Attributes Name integer, intent(in) :: step Current time step integer, intent(in) :: dim_obs_p PE-local dimension of observation vector real(kind=REAL64), intent(in) :: obs_p (dim_obs_p) PE-local observation vector real(kind=REAL64), intent(out) :: meanvar Mean observation error variance Contents None","tags":"","loc":"proc/init_obsvar_pdaf.html"},{"title":"next_observation_pdaf – EAT","text":"private subroutine next_observation_pdaf(stepnow, nsteps, doexit, time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: stepnow Number of the current time step integer, intent(out) :: nsteps Number of time steps until next obs integer, intent(out) :: doexit Whether to exit forecasting (1 for exit) real(kind=REAL64), intent(out) :: time Current model (physical) time Contents None","tags":"","loc":"proc/next_observation_pdaf.html"},{"title":"add_obs_error_pdaf – EAT","text":"private subroutine add_obs_error_pdaf() Arguments None Contents None","tags":"","loc":"proc/add_obs_error_pdaf.html"},{"title":"init_obscovar_pdaf – EAT","text":"private subroutine init_obscovar_pdaf() Arguments None Contents None","tags":"","loc":"proc/init_obscovar_pdaf.html"},{"title":"prodRinvA_pdaf – EAT","text":"private subroutine prodRinvA_pdaf(step, dim_obs_p, rank, obs_p, A_p, C_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: step Current time step integer, intent(in) :: dim_obs_p PE-local dimension of obs. vector integer, intent(in) :: rank Rank of initial covariance matrix real(kind=REAL64), intent(in) :: obs_p (dim_obs_p) PE-local vector of observations real(kind=REAL64), intent(in) :: A_p (dim_obs_p,rank) Input matrix from SEEK_ANALYSIS real(kind=REAL64), intent(out) :: C_p (dim_obs_p,rank) Output matrix local variables Contents None","tags":"","loc":"proc/prodrinva_pdaf.html"},{"title":"cvt_pdaf – EAT","text":"private subroutine cvt_pdaf(iter, dim_p, dim_cvec, v_p, Vv_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter < Iteration of optimization integer, intent(in) :: dim_p < PE-local observation dimension integer, intent(in) :: dim_cvec < Dimension of control vector real, intent(in), TARGET :: v_p (dim_cvec) < PE-local control vector real, intent(inout), TARGET :: Vv_p (dim_p) < PE-local result vector Contents None","tags":"","loc":"proc/cvt_pdaf.html"},{"title":"cvt_adj_pdaf – EAT","text":"private subroutine cvt_adj_pdaf(iter, dim_p, dim_cvec, Vv_p, v_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter < Iteration of optimization integer, intent(in) :: dim_p < PE-local observation dimension integer, intent(in) :: dim_cvec < Dimension of control vector real, intent(in), TARGET :: Vv_p (dim_p) < PE-local input vector real, intent(inout), TARGET :: v_p (dim_cvec) < PE-local result vector Contents None","tags":"","loc":"proc/cvt_adj_pdaf.html"},{"title":"cvt_ens_pdaf – EAT","text":"private subroutine cvt_ens_pdaf(iter, dim_p, dim_ens, dim_cvec_ens, ens_p, v_p, Vv_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter < Iteration of optimization integer, intent(in) :: dim_p < PE-local dimension of state integer, intent(in) :: dim_ens < Ensemble size integer, intent(in) :: dim_cvec_ens < Dimension of control vector real, intent(in), TARGET :: ens_p (dim_p,dim_ens) < PE-local ensemble real, intent(in), TARGET :: v_p (dim_cvec_ens) < PE-local control vector real, intent(inout), TARGET :: Vv_p (dim_p) < PE-local state increment Contents None","tags":"","loc":"proc/cvt_ens_pdaf.html"},{"title":"cvt_adj_ens_pdaf – EAT","text":"private subroutine cvt_adj_ens_pdaf(iter, dim_p, dim_ens, dim_cvec_ens, ens_p, Vv_p, v_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter < Iteration of optimization integer, intent(in) :: dim_p < PE-local dimension of state integer, intent(in) :: dim_ens < Ensemble size integer, intent(in) :: dim_cvec_ens < Number of columns in HV_p real, intent(in), TARGET :: ens_p (dim_p,dim_ens) < PE-local ensemble real, intent(in), TARGET :: Vv_p (dim_p) < PE-local input vector real, intent(inout), TARGET :: v_p (dim_cvec_ens) < PE-local result vector Contents None","tags":"","loc":"proc/cvt_adj_ens_pdaf.html"},{"title":"obs_op_adj_pdaf – EAT","text":"private subroutine obs_op_adj_pdaf(step, dim_p, dim_obs_p, m_state_p, state_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: step Currrent time step integer, intent(in) :: dim_p PE-local dimension of state integer, intent(in) :: dim_obs_p Dimension of observed state real(kind=REAL64), intent(in) :: m_state_p (dim_obs_p) PE-local observed state real(kind=REAL64), intent(out) :: state_p (dim_p) PE-local model state local variables Contents None","tags":"","loc":"proc/obs_op_adj_pdaf.html"},{"title":"obs_op_lin_pdaf – EAT","text":"private subroutine obs_op_lin_pdaf() Arguments None Contents None","tags":"","loc":"proc/obs_op_lin_pdaf.html"},{"title":"prepoststep_pdaf – EAT","text":"private subroutine prepoststep_pdaf() Arguments None Contents None","tags":"","loc":"proc/prepoststep_pdaf.html"},{"title":"init_3dvar_pdaf – EAT","text":"private subroutine init_3dvar_pdaf() Arguments None Contents None","tags":"","loc":"proc/init_3dvar_pdaf.html"},{"title":"prepoststep_3dvar_pdaf – EAT","text":"private subroutine prepoststep_3dvar_pdaf() Arguments None Contents None","tags":"","loc":"proc/prepoststep_3dvar_pdaf.html"},{"title":"abort – EAT","text":"private subroutine abort(msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Contents None","tags":"","loc":"proc/abort.html"},{"title":"init_n_domains_pdaf – EAT","text":"private subroutine init_n_domains_pdaf() Arguments None Contents None","tags":"","loc":"proc/init_n_domains_pdaf.html"},{"title":"init_dim_l_pdaf – EAT","text":"private subroutine init_dim_l_pdaf() Arguments None Contents None","tags":"","loc":"proc/init_dim_l_pdaf.html"},{"title":"init_dim_obs_l_pdaf – EAT","text":"private subroutine init_dim_obs_l_pdaf() Arguments None Contents None","tags":"","loc":"proc/init_dim_obs_l_pdaf.html"},{"title":"g2l_state_pdaf – EAT","text":"private subroutine g2l_state_pdaf() Arguments None Contents None","tags":"","loc":"proc/g2l_state_pdaf.html"},{"title":"g2l_obs_pdaf – EAT","text":"private subroutine g2l_obs_pdaf() Arguments None Contents None","tags":"","loc":"proc/g2l_obs_pdaf.html"},{"title":"l2g_state_pdaf – EAT","text":"private subroutine l2g_state_pdaf() Arguments None Contents None","tags":"","loc":"proc/l2g_state_pdaf.html"},{"title":"init_obs_l_pdaf – EAT","text":"private subroutine init_obs_l_pdaf() Arguments None Contents None","tags":"","loc":"proc/init_obs_l_pdaf.html"},{"title":"prodRinvA_l_pdaf – EAT","text":"private subroutine prodRinvA_l_pdaf() Arguments None Contents None","tags":"","loc":"proc/prodrinva_l_pdaf.html"},{"title":"init_obsvar_l_pdaf – EAT","text":"private subroutine init_obsvar_l_pdaf() Arguments None Contents None","tags":"","loc":"proc/init_obsvar_l_pdaf.html"},{"title":"init_obs_f_pdaf – EAT","text":"private subroutine init_obs_f_pdaf() Arguments None Contents None","tags":"","loc":"proc/init_obs_f_pdaf.html"},{"title":"obs_op_f_pdaf – EAT","text":"private subroutine obs_op_f_pdaf() Arguments None Contents None","tags":"","loc":"proc/obs_op_f_pdaf.html"},{"title":"init_dim_obs_f_pdaf – EAT","text":"private subroutine init_dim_obs_f_pdaf() Arguments None Contents None","tags":"","loc":"proc/init_dim_obs_f_pdaf.html"},{"title":"cvt_callback_interface – EAT","text":"interface private subroutine cvt_callback_interface(cb_type, iter, dim_p, dim_cvec, dim_cvec_ens, ens_p, v_p, Vv_p) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: cb_type integer(kind=C_INT), intent(in), VALUE :: iter < Iteration of optimization integer(kind=C_INT), intent(in), VALUE :: dim_p < PE-local observation dimension integer(kind=C_INT), intent(in), VALUE :: dim_cvec < Dimension of control vector integer(kind=C_INT), intent(in), VALUE :: dim_cvec_ens < Dimension of control vector type(C_PTR), intent(in), VALUE :: ens_p < PE-local ensemble type(C_PTR), intent(in), VALUE :: v_p < PE-local control vector type(C_PTR), intent(in), VALUE :: Vv_p < PE-local result vector","tags":"","loc":"interface/cvt_callback_interface.html"},{"title":"eat_init_pdaf – EAT","text":"subroutine eat_init_pdaf() Initialize EAT/PDAF component Arguments None Calls proc~~eat_init_pdaf~~CallsGraph proc~eat_init_pdaf eat_init_pdaf proc~init_eat_config init_eat_config proc~eat_init_pdaf->proc~init_eat_config mpi_recv mpi_recv proc~eat_init_pdaf->mpi_recv mpi_abort mpi_abort proc~eat_init_pdaf->mpi_abort proc~init_pdaf init_pdaf proc~eat_init_pdaf->proc~init_pdaf proc~init_eat_config->mpi_abort mpi_comm_rank mpi_comm_rank proc~init_eat_config->mpi_comm_rank mpi_comm_size mpi_comm_size proc~init_eat_config->mpi_comm_size mpi_init mpi_init proc~init_eat_config->mpi_init mpi_barrier mpi_barrier proc~init_eat_config->mpi_barrier mpi_get_processor_name mpi_get_processor_name proc~init_eat_config->mpi_get_processor_name mpi_comm_split mpi_comm_split proc~init_eat_config->mpi_comm_split pdaf_init pdaf_init proc~init_pdaf->pdaf_init pdaf_get_state pdaf_get_state proc~init_pdaf->pdaf_get_state pdaf_set_comm_pdaf pdaf_set_comm_pdaf proc~init_pdaf->pdaf_set_comm_pdaf pdaf_set_ens_pointer pdaf_set_ens_pointer proc~init_pdaf->pdaf_set_ens_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~eat_init_pdaf~~CalledByGraph proc~eat_init_pdaf eat_init_pdaf program~eat_filter_pdaf eat_filter_pdaf program~eat_filter_pdaf->proc~eat_init_pdaf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/eat_init_pdaf.html"},{"title":"eat_do_pdaf – EAT","text":"subroutine eat_do_pdaf() Get observations and states and do the PDAF/assimilation step Arguments None Calls proc~~eat_do_pdaf~~CallsGraph proc~eat_do_pdaf eat_do_pdaf mpi_waitall mpi_waitall proc~eat_do_pdaf->mpi_waitall mpi_isend mpi_isend proc~eat_do_pdaf->mpi_isend mpi_irecv mpi_irecv proc~eat_do_pdaf->mpi_irecv mpi_abort mpi_abort proc~eat_do_pdaf->mpi_abort proc~assimilation_pdaf assimilation_pdaf proc~eat_do_pdaf->proc~assimilation_pdaf mpi_recv mpi_recv proc~eat_do_pdaf->mpi_recv pdaf_put_state_letkf pdaf_put_state_letkf proc~assimilation_pdaf->pdaf_put_state_letkf pdaf_put_state_3dvar pdaf_put_state_3dvar proc~assimilation_pdaf->pdaf_put_state_3dvar pdaf_put_state_enkf pdaf_put_state_enkf proc~assimilation_pdaf->pdaf_put_state_enkf pdaf_put_state_lseik pdaf_put_state_lseik proc~assimilation_pdaf->pdaf_put_state_lseik pdaf_put_state_etkf pdaf_put_state_etkf proc~assimilation_pdaf->pdaf_put_state_etkf pdaf_get_state pdaf_get_state proc~assimilation_pdaf->pdaf_get_state pdaf_force_analysis pdaf_force_analysis proc~assimilation_pdaf->pdaf_force_analysis pdaf_put_state_seik pdaf_put_state_seik proc~assimilation_pdaf->pdaf_put_state_seik pdaf_put_state_lestkf pdaf_put_state_lestkf proc~assimilation_pdaf->pdaf_put_state_lestkf pdaf_put_state_estkf pdaf_put_state_estkf proc~assimilation_pdaf->pdaf_put_state_estkf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~eat_do_pdaf~~CalledByGraph proc~eat_do_pdaf eat_do_pdaf program~eat_filter_pdaf eat_filter_pdaf program~eat_filter_pdaf->proc~eat_do_pdaf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/eat_do_pdaf.html"},{"title":"eat_finish_pdaf – EAT","text":"subroutine eat_finish_pdaf() Cleanup and finalize the EAT/PDAF component Arguments None Calls proc~~eat_finish_pdaf~~CallsGraph proc~eat_finish_pdaf eat_finish_pdaf proc~finish_pdaf finish_pdaf proc~eat_finish_pdaf->proc~finish_pdaf mpi_finalize mpi_finalize proc~eat_finish_pdaf->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~eat_finish_pdaf~~CalledByGraph proc~eat_finish_pdaf eat_finish_pdaf program~eat_filter_pdaf eat_filter_pdaf program~eat_filter_pdaf->proc~eat_finish_pdaf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/eat_finish_pdaf.html"},{"title":"eat_config – EAT","text":"Initialize the MPI environment - Fortran side.\nDefined constants here must be matched by Python Uses mpi iso_fortran_env module~~eat_config~~UsesGraph module~eat_config eat_config mpi mpi module~eat_config->mpi iso_fortran_env iso_fortran_env module~eat_config->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~eat_config~~UsedByGraph module~eat_config eat_config program~eat_filter_pdaf eat_filter_pdaf program~eat_filter_pdaf->module~eat_config module~pdaf_wrapper pdaf_wrapper program~eat_filter_pdaf->module~pdaf_wrapper module~pdaf_wrapper->module~eat_config Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables color_obs color_model color_filter tag_timestr tag_nobs tag_iobs tag_obs tag_analysis tag_forecast signal_initialize signal_integrate signal_finalize signal_recv_state signal_send_state debug info warn error fatal silent EAT_COMM_obs EAT_COMM_model EAT_COMM_filter EAT_COMM_obs_model EAT_COMM_obs_filter EAT_COMM_model_filter size_obs_comm size_model_comm size_filter_comm size_obs_model_comm size_obs_filter_comm size_model_filter_comm rank_obs_comm rank_model_comm rank_filter_comm rank_obs_model_comm rank_obs_filter_comm rank_model_filter_comm rank nprocs ierr stderr stdout Subroutines init_eat_config version_mpi_config Variables Type Visibility Attributes Name Initial integer, public, parameter :: color_obs = 1 integer, public, parameter :: color_model = 2 integer, public, parameter :: color_filter = 4 integer, public, parameter :: tag_timestr = 1 integer, public, parameter :: tag_nobs = 1 integer, public, parameter :: tag_iobs = 2 integer, public, parameter :: tag_obs = 3 integer, public, parameter :: tag_analysis = 1 integer, public, parameter :: tag_forecast = 2 integer, public, parameter :: signal_initialize = 1 integer, public, parameter :: signal_integrate = 2 integer, public, parameter :: signal_finalize = 4 integer, public, parameter :: signal_recv_state = 8 integer, public, parameter :: signal_send_state = 16 integer, public, parameter :: debug = 2048 integer, public, parameter :: info = 1024 integer, public, parameter :: warn = 512 integer, public, parameter :: error = 256 integer, public, parameter :: fatal = 128 integer, public, parameter :: silent = 64 integer, public :: EAT_COMM_obs = MPI_COMM_NULL integer, public :: EAT_COMM_model = MPI_COMM_NULL integer, public :: EAT_COMM_filter = MPI_COMM_NULL integer, public :: EAT_COMM_obs_model = MPI_COMM_NULL integer, public :: EAT_COMM_obs_filter = MPI_COMM_NULL integer, public :: EAT_COMM_model_filter = MPI_COMM_NULL integer, public :: size_obs_comm = -1 integer, public :: size_model_comm = -1 integer, public :: size_filter_comm = -1 integer, public :: size_obs_model_comm = -1 integer, public :: size_obs_filter_comm = -1 integer, public :: size_model_filter_comm = -1 integer, public :: rank_obs_comm = -1 integer, public :: rank_model_comm = -1 integer, public :: rank_filter_comm = -1 integer, public :: rank_obs_model_comm = -1 integer, public :: rank_obs_filter_comm = -1 integer, public :: rank_model_filter_comm = -1 integer, public :: rank integer, public :: nprocs integer, private :: ierr integer, private :: stderr = error_unit integer, private :: stdout = output_unit Subroutines public subroutine init_eat_config (color) Initialize MPI, define communicators and set variables Arguments Type Intent Optional Attributes Name integer, intent(in) :: color public subroutine version_mpi_config (mpi_version, library_version) Collect MPI and MPI Library version info Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: mpi_version character(len=*), intent(inout) :: library_version","tags":"","loc":"module/eat_config.html"},{"title":"pdaf_wrapper – EAT","text":"A wrapper around 'PDAF' Uses PDAF_interfaces_module iso_fortran_env eat_config pdaf_mod_filter iso_c_binding module~~pdaf_wrapper~~UsesGraph module~pdaf_wrapper pdaf_wrapper PDAF_interfaces_module PDAF_interfaces_module module~pdaf_wrapper->PDAF_interfaces_module iso_fortran_env iso_fortran_env module~pdaf_wrapper->iso_fortran_env module~eat_config eat_config module~pdaf_wrapper->module~eat_config iso_c_binding iso_c_binding module~pdaf_wrapper->iso_c_binding pdaf_mod_filter pdaf_mod_filter module~pdaf_wrapper->pdaf_mod_filter module~eat_config->iso_fortran_env mpi mpi module~eat_config->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pdaf_wrapper~~UsedByGraph module~pdaf_wrapper pdaf_wrapper program~eat_filter_pdaf eat_filter_pdaf program~eat_filter_pdaf->module~pdaf_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables stderr stdout verbosity iobs obs filtertype subtype timenow doexit steps rms_obs pcvt_callback Interfaces cvt_callback_interface Subroutines init_pdaf assimilation_pdaf finish_pdaf init_ens_pdaf collect_state_pdaf distribute_state_pdaf init_dim_obs_pdaf obs_op_pdaf init_obs_pdaf prepoststep_ens_pdaf init_obsvar_pdaf next_observation_pdaf add_obs_error_pdaf init_obscovar_pdaf prodRinvA_pdaf cvt_pdaf cvt_adj_pdaf cvt_ens_pdaf cvt_adj_ens_pdaf obs_op_adj_pdaf obs_op_lin_pdaf prepoststep_pdaf init_3dvar_pdaf prepoststep_3dvar_pdaf abort init_n_domains_pdaf init_dim_l_pdaf init_dim_obs_l_pdaf g2l_state_pdaf g2l_obs_pdaf l2g_state_pdaf init_obs_l_pdaf prodRinvA_l_pdaf init_obsvar_l_pdaf init_obs_f_pdaf obs_op_f_pdaf init_dim_obs_f_pdaf Variables Type Visibility Attributes Name Initial integer, private :: stderr = error_unit integer, private :: stdout = output_unit integer, private :: verbosity = info integer, public, pointer, contiguous :: iobs (:) => null() map observations to state real(kind=real64), public, pointer, contiguous :: obs (:) => null() observation vector integer, private :: filtertype = 6 PDAF filter selection integer, private :: subtype = 0 PDAF subtype selection real(kind=real64), private :: timenow integer, private :: doexit integer, private :: steps real(kind=real64), private :: rms_obs = 0.05 Observation error standard deviation !KB shall be replaced procedure( cvt_callback_interface ), public, pointer, save :: pcvt_callback => null() user implemented routine (in Python) Interfaces interface private subroutine cvt_callback_interface(cb_type, iter, dim_p, dim_cvec, dim_cvec_ens, ens_p, v_p, Vv_p) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: cb_type integer(kind=C_INT), intent(in), VALUE :: iter < Iteration of optimization integer(kind=C_INT), intent(in), VALUE :: dim_p < PE-local observation dimension integer(kind=C_INT), intent(in), VALUE :: dim_cvec < Dimension of control vector integer(kind=C_INT), intent(in), VALUE :: dim_cvec_ens < Dimension of control vector type(C_PTR), intent(in), VALUE :: ens_p < PE-local ensemble type(C_PTR), intent(in), VALUE :: v_p < PE-local control vector type(C_PTR), intent(in), VALUE :: Vv_p < PE-local result vector Subroutines public subroutine init_pdaf (EAT_COMM_filter, state_size, ensemble_size, model_states, stat) Initialize various variable and call PDAF_init() Arguments Type Intent Optional Attributes Name integer, intent(in), value :: EAT_COMM_filter integer, intent(in), value :: state_size integer, intent(in), value :: ensemble_size real(kind=real64), pointer, contiguous :: model_states (:,:) integer, intent(out) :: stat public subroutine assimilation_pdaf () bind(c) local variables Arguments None public subroutine finish_pdaf () bind(c) Cleanup and finalize the EAT/PDAF component Arguments None private subroutine init_ens_pdaf (filtertype, dim_p, dim_ens, state_p, Uinv, ens_p, flag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: filtertype Type of filter to initialize integer, intent(in) :: dim_p PE-local state dimension integer, intent(in) :: dim_ens Size of ensemble real(kind=REAL64), intent(inout) :: state_p (dim_p) PE-local model state real(kind=REAL64), intent(inout) :: Uinv (dim_ens-1,dim_ens-1) Array not referenced for SEIK real(kind=REAL64), intent(out) :: ens_p (dim_p,dim_ens) PE-local state ensemble integer, intent(inout) :: flag PDAF status flag private subroutine collect_state_pdaf (dim_p, state_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim_p integer, intent(inout) :: state_p (dim_p) private subroutine distribute_state_pdaf (dim_p, state_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim_p integer, intent(inout) :: state_p (dim_p) private subroutine init_dim_obs_pdaf (step, dim_obs_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: step Current time step integer, intent(out) :: dim_obs_p Dimension of observation vector private subroutine obs_op_pdaf (step, dim_p, dim_obs_p, state_p, m_state_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: step Currrent time step integer, intent(in) :: dim_p PE-local dimension of state integer, intent(in) :: dim_obs_p Dimension of observed state real(kind=REAL64), intent(in) :: state_p (dim_p) PE-local model state real(kind=REAL64), intent(out) :: m_state_p (dim_obs_p) PE-local observed state private subroutine init_obs_pdaf (step, dim_obs_f, observation_f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: step Current time step integer, intent(in) :: dim_obs_f Dimension of full observation vector real(kind=REAL64), intent(out) :: observation_f (dim_obs_f) Full observation vector private subroutine prepoststep_ens_pdaf (step, dim_p, dim_ens, dim_ens_p, dim_obs_p, state_p, Uinv, ens_p, flag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: step Current time step (not relevant for offline mode) integer, intent(in) :: dim_p PE-local state dimension integer, intent(in) :: dim_ens Size of state ensemble integer, intent(in) :: dim_ens_p PE-local size of ensemble integer, intent(in) :: dim_obs_p PE-local dimension of observation vector real(kind=REAL64), intent(inout) :: state_p (dim_p) PE-local forecast/analysis state real(kind=REAL64), intent(inout) :: Uinv (dim_ens-1,dim_ens-1) Inverse of matrix U real(kind=REAL64), intent(inout) :: ens_p (dim_p,dim_ens) PE-local state ensemble integer, intent(in) :: flag PDAF status flag local variables private subroutine init_obsvar_pdaf (step, dim_obs_p, obs_p, meanvar) Arguments Type Intent Optional Attributes Name integer, intent(in) :: step Current time step integer, intent(in) :: dim_obs_p PE-local dimension of observation vector real(kind=REAL64), intent(in) :: obs_p (dim_obs_p) PE-local observation vector real(kind=REAL64), intent(out) :: meanvar Mean observation error variance private subroutine next_observation_pdaf (stepnow, nsteps, doexit, time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: stepnow Number of the current time step integer, intent(out) :: nsteps Number of time steps until next obs integer, intent(out) :: doexit Whether to exit forecasting (1 for exit) real(kind=REAL64), intent(out) :: time Current model (physical) time private subroutine add_obs_error_pdaf () Arguments None private subroutine init_obscovar_pdaf () Arguments None private subroutine prodRinvA_pdaf (step, dim_obs_p, rank, obs_p, A_p, C_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: step Current time step integer, intent(in) :: dim_obs_p PE-local dimension of obs. vector integer, intent(in) :: rank Rank of initial covariance matrix real(kind=REAL64), intent(in) :: obs_p (dim_obs_p) PE-local vector of observations real(kind=REAL64), intent(in) :: A_p (dim_obs_p,rank) Input matrix from SEEK_ANALYSIS real(kind=REAL64), intent(out) :: C_p (dim_obs_p,rank) Output matrix local variables private subroutine cvt_pdaf (iter, dim_p, dim_cvec, v_p, Vv_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter < Iteration of optimization integer, intent(in) :: dim_p < PE-local observation dimension integer, intent(in) :: dim_cvec < Dimension of control vector real, intent(in), TARGET :: v_p (dim_cvec) < PE-local control vector real, intent(inout), TARGET :: Vv_p (dim_p) < PE-local result vector private subroutine cvt_adj_pdaf (iter, dim_p, dim_cvec, Vv_p, v_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter < Iteration of optimization integer, intent(in) :: dim_p < PE-local observation dimension integer, intent(in) :: dim_cvec < Dimension of control vector real, intent(in), TARGET :: Vv_p (dim_p) < PE-local input vector real, intent(inout), TARGET :: v_p (dim_cvec) < PE-local result vector private subroutine cvt_ens_pdaf (iter, dim_p, dim_ens, dim_cvec_ens, ens_p, v_p, Vv_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter < Iteration of optimization integer, intent(in) :: dim_p < PE-local dimension of state integer, intent(in) :: dim_ens < Ensemble size integer, intent(in) :: dim_cvec_ens < Dimension of control vector real, intent(in), TARGET :: ens_p (dim_p,dim_ens) < PE-local ensemble real, intent(in), TARGET :: v_p (dim_cvec_ens) < PE-local control vector real, intent(inout), TARGET :: Vv_p (dim_p) < PE-local state increment private subroutine cvt_adj_ens_pdaf (iter, dim_p, dim_ens, dim_cvec_ens, ens_p, Vv_p, v_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter < Iteration of optimization integer, intent(in) :: dim_p < PE-local dimension of state integer, intent(in) :: dim_ens < Ensemble size integer, intent(in) :: dim_cvec_ens < Number of columns in HV_p real, intent(in), TARGET :: ens_p (dim_p,dim_ens) < PE-local ensemble real, intent(in), TARGET :: Vv_p (dim_p) < PE-local input vector real, intent(inout), TARGET :: v_p (dim_cvec_ens) < PE-local result vector private subroutine obs_op_adj_pdaf (step, dim_p, dim_obs_p, m_state_p, state_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: step Currrent time step integer, intent(in) :: dim_p PE-local dimension of state integer, intent(in) :: dim_obs_p Dimension of observed state real(kind=REAL64), intent(in) :: m_state_p (dim_obs_p) PE-local observed state real(kind=REAL64), intent(out) :: state_p (dim_p) PE-local model state local variables private subroutine obs_op_lin_pdaf () Arguments None private subroutine prepoststep_pdaf () Arguments None private subroutine init_3dvar_pdaf () Arguments None private subroutine prepoststep_3dvar_pdaf () Arguments None private subroutine abort (msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg private subroutine init_n_domains_pdaf () Arguments None private subroutine init_dim_l_pdaf () Arguments None private subroutine init_dim_obs_l_pdaf () Arguments None private subroutine g2l_state_pdaf () Arguments None private subroutine g2l_obs_pdaf () Arguments None private subroutine l2g_state_pdaf () Arguments None private subroutine init_obs_l_pdaf () Arguments None private subroutine prodRinvA_l_pdaf () Arguments None private subroutine init_obsvar_l_pdaf () Arguments None private subroutine init_obs_f_pdaf () Arguments None private subroutine obs_op_f_pdaf () Arguments None private subroutine init_dim_obs_f_pdaf () Arguments None","tags":"","loc":"module/pdaf_wrapper.html"},{"title":"eat_filter_pdaf – EAT","text":"Uses pdaf_wrapper eat_config mpi iso_fortran_env program~~eat_filter_pdaf~~UsesGraph program~eat_filter_pdaf eat_filter_pdaf mpi mpi program~eat_filter_pdaf->mpi module~pdaf_wrapper pdaf_wrapper program~eat_filter_pdaf->module~pdaf_wrapper iso_fortran_env iso_fortran_env program~eat_filter_pdaf->iso_fortran_env module~eat_config eat_config program~eat_filter_pdaf->module~eat_config module~pdaf_wrapper->iso_fortran_env module~pdaf_wrapper->module~eat_config iso_c_binding iso_c_binding module~pdaf_wrapper->iso_c_binding pdaf_mod_filter pdaf_mod_filter module~pdaf_wrapper->pdaf_mod_filter PDAF_interfaces_module PDAF_interfaces_module module~pdaf_wrapper->PDAF_interfaces_module module~eat_config->mpi module~eat_config->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. A wrapper around the 'off_line PDAF' implmentation to keep it alive during\nensemble simulations Calls program~~eat_filter_pdaf~~CallsGraph program~eat_filter_pdaf eat_filter_pdaf proc~eat_init_pdaf eat_init_pdaf program~eat_filter_pdaf->proc~eat_init_pdaf proc~eat_do_pdaf eat_do_pdaf program~eat_filter_pdaf->proc~eat_do_pdaf proc~eat_finish_pdaf eat_finish_pdaf program~eat_filter_pdaf->proc~eat_finish_pdaf proc~init_pdaf init_pdaf proc~eat_init_pdaf->proc~init_pdaf mpi_abort mpi_abort proc~eat_init_pdaf->mpi_abort mpi_recv mpi_recv proc~eat_init_pdaf->mpi_recv proc~init_eat_config init_eat_config proc~eat_init_pdaf->proc~init_eat_config mpi_waitall mpi_waitall proc~eat_do_pdaf->mpi_waitall mpi_irecv mpi_irecv proc~eat_do_pdaf->mpi_irecv mpi_isend mpi_isend proc~eat_do_pdaf->mpi_isend proc~eat_do_pdaf->mpi_abort proc~assimilation_pdaf assimilation_pdaf proc~eat_do_pdaf->proc~assimilation_pdaf proc~eat_do_pdaf->mpi_recv mpi_finalize mpi_finalize proc~eat_finish_pdaf->mpi_finalize proc~finish_pdaf finish_pdaf proc~eat_finish_pdaf->proc~finish_pdaf pdaf_get_state pdaf_get_state proc~init_pdaf->pdaf_get_state pdaf_set_ens_pointer pdaf_set_ens_pointer proc~init_pdaf->pdaf_set_ens_pointer pdaf_set_comm_pdaf pdaf_set_comm_pdaf proc~init_pdaf->pdaf_set_comm_pdaf pdaf_init pdaf_init proc~init_pdaf->pdaf_init proc~assimilation_pdaf->pdaf_get_state pdaf_put_state_3dvar pdaf_put_state_3dvar proc~assimilation_pdaf->pdaf_put_state_3dvar pdaf_put_state_letkf pdaf_put_state_letkf proc~assimilation_pdaf->pdaf_put_state_letkf pdaf_put_state_enkf pdaf_put_state_enkf proc~assimilation_pdaf->pdaf_put_state_enkf pdaf_put_state_etkf pdaf_put_state_etkf proc~assimilation_pdaf->pdaf_put_state_etkf pdaf_force_analysis pdaf_force_analysis proc~assimilation_pdaf->pdaf_force_analysis pdaf_put_state_seik pdaf_put_state_seik proc~assimilation_pdaf->pdaf_put_state_seik pdaf_put_state_estkf pdaf_put_state_estkf proc~assimilation_pdaf->pdaf_put_state_estkf pdaf_put_state_lseik pdaf_put_state_lseik proc~assimilation_pdaf->pdaf_put_state_lseik pdaf_put_state_lestkf pdaf_put_state_lestkf proc~assimilation_pdaf->pdaf_put_state_lestkf proc~init_eat_config->mpi_abort mpi_comm_rank mpi_comm_rank proc~init_eat_config->mpi_comm_rank mpi_comm_size mpi_comm_size proc~init_eat_config->mpi_comm_size mpi_barrier mpi_barrier proc~init_eat_config->mpi_barrier mpi_get_processor_name mpi_get_processor_name proc~init_eat_config->mpi_get_processor_name mpi_comm_split mpi_comm_split proc~init_eat_config->mpi_comm_split mpi_init mpi_init proc~init_eat_config->mpi_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables nobs have_obs have_model state_size ensemble_size reqs stats model_states stderr stdout verbosity Subroutines eat_init_pdaf eat_do_pdaf eat_finish_pdaf Variables Type Attributes Name Initial integer :: nobs = 0 logical :: have_obs = .true. logical :: have_model = .true. integer :: state_size integer :: ensemble_size integer, allocatable :: reqs (:) integer, allocatable :: stats (:,:) real(kind=real64), pointer, contiguous :: model_states (:,:) integer, parameter :: stderr = error_unit integer, parameter :: stdout = output_unit integer :: verbosity = info Subroutines subroutine eat_init_pdaf () Initialize EAT/PDAF component Arguments None subroutine eat_do_pdaf () Get observations and states and do the PDAF/assimilation step Arguments None subroutine eat_finish_pdaf () Cleanup and finalize the EAT/PDAF component Arguments None","tags":"","loc":"program/eat_filter_pdaf.html"}]}